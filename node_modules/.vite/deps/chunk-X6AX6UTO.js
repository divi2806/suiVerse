import {
  base58
} from "./chunk-NVVIVNFB.js";

// node_modules/@mysten/utils/dist/esm/b64.js
function fromBase64(base64String) {
  return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i, i + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// node_modules/@mysten/utils/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

// node_modules/@mysten/utils/dist/esm/hex.js
function fromHex(hexStr) {
  var _a;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = ((_a = padded.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : _a.map((byte) => parseInt(byte, 16))) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@mysten/utils/dist/esm/chunk.js
function chunk(array, size) {
  return Array.from({ length: Math.ceil(array.length / size) }, (_, i) => {
    return array.slice(i * size, (i + 1) * size);
  });
}

// node_modules/@mysten/utils/dist/esm/with-resolver.js
function promiseWithResolvers() {
  let resolver;
  let rejecter;
  const promise = new Promise((resolve, reject) => {
    resolver = resolve;
    rejecter = reject;
  });
  return {
    promise,
    resolve: resolver,
    reject: rejecter
  };
}

export {
  toBase58,
  fromBase58,
  fromBase64,
  toBase64,
  fromHex,
  toHex,
  chunk,
  promiseWithResolvers
};
//# sourceMappingURL=chunk-X6AX6UTO.js.map
