{
  "version": 3,
  "sources": ["../../@mysten/utils/src/b64.ts", "../../@mysten/utils/src/b58.ts", "../../@mysten/utils/src/hex.ts", "../../@mysten/utils/src/chunk.ts", "../../@mysten/utils/src/with-resolver.ts", "../../valibot/dist/index.js"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base58 } from '@scure/base';\n\nexport const toBase58 = (buffer: Uint8Array) => base58.encode(buffer);\nexport const fromBase58 = (str: string) => base58.decode(str);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n\tconst intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\tif (intArr.length !== padded.length / 2) {\n\t\tthrow new Error(`Invalid hex string ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function chunk<T>(array: T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(array.length / size) }, (_, i) => {\n\t\treturn array.slice(i * size, (i + 1) * size);\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface PromiseWithResolvers<T> {\n\tpromise: Promise<T>;\n\tresolve: (value: T) => void;\n\treject: (error: unknown) => void;\n}\n\nexport function promiseWithResolvers<T>(): PromiseWithResolvers<T> {\n\tlet resolver!: (value: T) => void;\n\tlet rejecter!: (error: unknown) => void;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tresolver = resolve;\n\t\trejecter = reject;\n\t});\n\n\treturn {\n\t\tpromise,\n\t\tresolve: resolver,\n\t\treject: rejecter,\n\t};\n}\n", "// src/actions/await/awaitAsync.ts\r\nfunction awaitAsync() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"await\",\r\n    reference: awaitAsync,\r\n    async: true,\r\n    async _run(dataset) {\r\n      dataset.value = await dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/regex.ts\r\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\r\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\r\nvar DECIMAL_REGEX = /^\\d+$/u;\r\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\r\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\r\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\r\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\r\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\r\nvar IPV4_REGEX = (\r\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\r\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\r\n);\r\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\r\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\r\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\r\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\r\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\r\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\r\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\r\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\r\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\r\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\r\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\r\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\r\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\r\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\r\n\r\n// src/storages/globalConfig/globalConfig.ts\r\nvar store;\r\nfunction setGlobalConfig(config2) {\r\n  store = { ...store, ...config2 };\r\n}\r\nfunction getGlobalConfig(config2) {\r\n  return {\r\n    lang: config2?.lang ?? store?.lang,\r\n    message: config2?.message,\r\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\r\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\r\n  };\r\n}\r\nfunction deleteGlobalConfig() {\r\n  store = void 0;\r\n}\r\n\r\n// src/storages/globalMessage/globalMessage.ts\r\nvar store2;\r\nfunction setGlobalMessage(message, lang) {\r\n  if (!store2) store2 = /* @__PURE__ */ new Map();\r\n  store2.set(lang, message);\r\n}\r\nfunction getGlobalMessage(lang) {\r\n  return store2?.get(lang);\r\n}\r\nfunction deleteGlobalMessage(lang) {\r\n  store2?.delete(lang);\r\n}\r\n\r\n// src/storages/schemaMessage/schemaMessage.ts\r\nvar store3;\r\nfunction setSchemaMessage(message, lang) {\r\n  if (!store3) store3 = /* @__PURE__ */ new Map();\r\n  store3.set(lang, message);\r\n}\r\nfunction getSchemaMessage(lang) {\r\n  return store3?.get(lang);\r\n}\r\nfunction deleteSchemaMessage(lang) {\r\n  store3?.delete(lang);\r\n}\r\n\r\n// src/storages/specificMessage/specificMessage.ts\r\nvar store4;\r\nfunction setSpecificMessage(reference, message, lang) {\r\n  if (!store4) store4 = /* @__PURE__ */ new Map();\r\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\r\n  store4.get(reference).set(lang, message);\r\n}\r\nfunction getSpecificMessage(reference, lang) {\r\n  return store4?.get(reference)?.get(lang);\r\n}\r\nfunction deleteSpecificMessage(reference, lang) {\r\n  store4?.get(reference)?.delete(lang);\r\n}\r\n\r\n// src/utils/_stringify/_stringify.ts\r\nfunction _stringify(input) {\r\n  const type = typeof input;\r\n  if (type === \"string\") {\r\n    return `\"${input}\"`;\r\n  }\r\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\r\n    return `${input}`;\r\n  }\r\n  if (type === \"object\" || type === \"function\") {\r\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\r\n  }\r\n  return type;\r\n}\r\n\r\n// src/utils/_addIssue/_addIssue.ts\r\nfunction _addIssue(context, label, dataset, config2, other) {\r\n  const input = other && \"input\" in other ? other.input : dataset.value;\r\n  const expected = other?.expected ?? context.expects ?? null;\r\n  const received = other?.received ?? _stringify(input);\r\n  const issue = {\r\n    kind: context.kind,\r\n    type: context.type,\r\n    input,\r\n    expected,\r\n    received,\r\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\r\n    // @ts-expect-error\r\n    requirement: context.requirement,\r\n    path: other?.path,\r\n    issues: other?.issues,\r\n    lang: config2.lang,\r\n    abortEarly: config2.abortEarly,\r\n    abortPipeEarly: config2.abortPipeEarly\r\n  };\r\n  const isSchema = context.kind === \"schema\";\r\n  const message = other?.message ?? // @ts-expect-error\r\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\r\n  if (message) {\r\n    issue.message = typeof message === \"function\" ? message(issue) : message;\r\n  }\r\n  if (isSchema) {\r\n    dataset.typed = false;\r\n  }\r\n  if (dataset.issues) {\r\n    dataset.issues.push(issue);\r\n  } else {\r\n    dataset.issues = [issue];\r\n  }\r\n}\r\n\r\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\r\nvar NON_DIGIT_REGEX = /\\D/gu;\r\nfunction _isLuhnAlgo(input) {\r\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\r\n  let length2 = number2.length;\r\n  let bit = 1;\r\n  let sum = 0;\r\n  while (length2) {\r\n    const value2 = +number2[--length2];\r\n    bit ^= 1;\r\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\r\n  }\r\n  return sum % 10 === 0;\r\n}\r\n\r\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\r\nfunction _isValidObjectKey(object2, key) {\r\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\r\n}\r\n\r\n// src/utils/entriesFromList/entriesFromList.ts\r\nfunction entriesFromList(list, schema) {\r\n  const entries = {};\r\n  for (const key of list) {\r\n    entries[key] = schema;\r\n  }\r\n  return entries;\r\n}\r\n\r\n// src/utils/getDotPath/getDotPath.ts\r\nfunction getDotPath(issue) {\r\n  if (issue.path) {\r\n    let key = \"\";\r\n    for (const item of issue.path) {\r\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\r\n        if (key) {\r\n          key += `.${item.key}`;\r\n        } else {\r\n          key += item.key;\r\n        }\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    return key;\r\n  }\r\n  return null;\r\n}\r\n\r\n// src/utils/isOfKind/isOfKind.ts\r\nfunction isOfKind(kind, object2) {\r\n  return object2.kind === kind;\r\n}\r\n\r\n// src/utils/isOfType/isOfType.ts\r\nfunction isOfType(type, object2) {\r\n  return object2.type === type;\r\n}\r\n\r\n// src/utils/isValiError/isValiError.ts\r\nfunction isValiError(error) {\r\n  return error instanceof ValiError;\r\n}\r\n\r\n// src/utils/ValiError/ValiError.ts\r\nvar ValiError = class extends Error {\r\n  /**\r\n   * The error issues.\r\n   */\r\n  issues;\r\n  /**\r\n   * Creates a Valibot error with useful information.\r\n   *\r\n   * @param issues The error issues.\r\n   */\r\n  constructor(issues) {\r\n    super(issues[0].message);\r\n    this.name = \"ValiError\";\r\n    this.issues = issues;\r\n  }\r\n};\r\n\r\n// src/actions/bic/bic.ts\r\nfunction bic(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"bic\",\r\n    reference: bic,\r\n    async: false,\r\n    expects: null,\r\n    requirement: BIC_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"BIC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/brand/brand.ts\r\nfunction brand(name) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"brand\",\r\n    reference: brand,\r\n    async: false,\r\n    name,\r\n    _run(dataset) {\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/bytes/bytes.ts\r\nfunction bytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"bytes\",\r\n    reference: bytes,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 !== this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/check/check.ts\r\nfunction check(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check\",\r\n    reference: check,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/check/checkAsync.ts\r\nfunction checkAsync(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check\",\r\n    reference: checkAsync,\r\n    async: true,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.typed && !await this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/checkItems/checkItems.ts\r\nfunction checkItems(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"check_items\",\r\n    reference: checkItems,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        for (let index = 0; index < dataset.value.length; index++) {\r\n          const item = dataset.value[index];\r\n          if (!this.requirement(item, index, dataset.value)) {\r\n            _addIssue(this, \"item\", dataset, config2, {\r\n              input: item,\r\n              path: [\r\n                {\r\n                  type: \"array\",\r\n                  origin: \"value\",\r\n                  input: dataset.value,\r\n                  key: index,\r\n                  value: item\r\n                }\r\n              ]\r\n            });\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/creditCard/creditCard.ts\r\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\r\nvar SANITIZE_REGEX = /[- ]/gu;\r\nvar PROVIDER_REGEX_LIST = [\r\n  // American Express\r\n  /^3[47]\\d{13}$/u,\r\n  // Diners Club\r\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\r\n  // Discover\r\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\r\n  // JCB\r\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\r\n  // Mastercard\r\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\r\n  // UnionPay\r\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\r\n  // Visa\r\n  /^4\\d{12}(?:\\d{3,6})?$/u\r\n];\r\nfunction creditCard(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"credit_card\",\r\n    reference: creditCard,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      let sanitized;\r\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\r\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\r\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\r\n      _isLuhnAlgo(sanitized);\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"credit card\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/cuid2/cuid2.ts\r\nfunction cuid2(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"cuid2\",\r\n    reference: cuid2,\r\n    async: false,\r\n    expects: null,\r\n    requirement: CUID2_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"Cuid2\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/decimal/decimal.ts\r\nfunction decimal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"decimal\",\r\n    reference: decimal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: DECIMAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"decimal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/email/email.ts\r\nfunction email(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"email\",\r\n    reference: email,\r\n    expects: null,\r\n    async: false,\r\n    requirement: EMAIL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"email\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/emoji/emoji.ts\r\nfunction emoji(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"emoji\",\r\n    reference: emoji,\r\n    async: false,\r\n    expects: null,\r\n    requirement: EMOJI_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"emoji\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/empty/empty.ts\r\nfunction empty(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"empty\",\r\n    reference: empty,\r\n    async: false,\r\n    expects: \"0\",\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length > 0) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/endsWith/endsWith.ts\r\nfunction endsWith(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ends_with\",\r\n    reference: endsWith,\r\n    async: false,\r\n    expects: `\"${requirement}\"`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\r\n        _addIssue(this, \"end\", dataset, config2, {\r\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/everyItem/everyItem.ts\r\nfunction everyItem(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"every_item\",\r\n    reference: everyItem,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\r\n        _addIssue(this, \"item\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/excludes/excludes.ts\r\nfunction excludes(requirement, message) {\r\n  const received = _stringify(requirement);\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"excludes\",\r\n    reference: excludes,\r\n    async: false,\r\n    expects: `!${received}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\r\n        _addIssue(this, \"content\", dataset, config2, { received });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/filterItems/filterItems.ts\r\nfunction filterItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"filter_items\",\r\n    reference: filterItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.filter(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/findItem/findItem.ts\r\nfunction findItem(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"find_item\",\r\n    reference: findItem,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.find(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/finite/finite.ts\r\nfunction finite(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"finite\",\r\n    reference: finite,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isFinite,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"finite\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hash/hash.ts\r\nvar HASH_LENGTHS = {\r\n  md4: 32,\r\n  md5: 32,\r\n  sha1: 40,\r\n  sha256: 64,\r\n  sha384: 96,\r\n  sha512: 128,\r\n  ripemd128: 32,\r\n  ripemd160: 40,\r\n  tiger128: 32,\r\n  tiger160: 40,\r\n  tiger192: 48,\r\n  crc32: 8,\r\n  crc32b: 8,\r\n  adler32: 8\r\n};\r\nfunction hash(types, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hash\",\r\n    reference: hash,\r\n    expects: null,\r\n    async: false,\r\n    requirement: RegExp(\r\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\r\n      \"iu\"\r\n    ),\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hash\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hexadecimal/hexadecimal.ts\r\nfunction hexadecimal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hexadecimal\",\r\n    reference: hexadecimal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: HEXADECIMAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hexadecimal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/hexColor/hexColor.ts\r\nfunction hexColor(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"hex_color\",\r\n    reference: hexColor,\r\n    async: false,\r\n    expects: null,\r\n    requirement: HEX_COLOR_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"hex color\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/imei/imei.ts\r\nfunction imei(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"imei\",\r\n    reference: imei,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"IMEI\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/includes/includes.ts\r\nfunction includes(requirement, message) {\r\n  const expects = _stringify(requirement);\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"includes\",\r\n    reference: includes,\r\n    async: false,\r\n    expects,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\r\n        _addIssue(this, \"content\", dataset, config2, {\r\n          received: `!${expects}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/integer/integer.ts\r\nfunction integer(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"integer\",\r\n    reference: integer,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isInteger,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"integer\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ip/ip.ts\r\nfunction ip(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ip\",\r\n    reference: ip,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IP_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IP\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ipv4/ipv4.ts\r\nfunction ipv4(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ipv4\",\r\n    reference: ipv4,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IPV4_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IPv4\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ipv6/ipv6.ts\r\nfunction ipv6(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ipv6\",\r\n    reference: ipv6,\r\n    async: false,\r\n    expects: null,\r\n    requirement: IPV6_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"IPv6\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoDate/isoDate.ts\r\nfunction isoDate(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_date\",\r\n    reference: isoDate,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_DATE_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"date\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoDateTime/isoDateTime.ts\r\nfunction isoDateTime(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_date_time\",\r\n    reference: isoDateTime,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_DATE_TIME_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"date-time\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTime/isoTime.ts\r\nfunction isoTime(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_time\",\r\n    reference: isoTime,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIME_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"time\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTimeSecond/isoTimeSecond.ts\r\nfunction isoTimeSecond(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_time_second\",\r\n    reference: isoTimeSecond,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIME_SECOND_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"time-second\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoTimestamp/isoTimestamp.ts\r\nfunction isoTimestamp(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_timestamp\",\r\n    reference: isoTimestamp,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_TIMESTAMP_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"timestamp\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/isoWeek/isoWeek.ts\r\nfunction isoWeek(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"iso_week\",\r\n    reference: isoWeek,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ISO_WEEK_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"week\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/length/length.ts\r\nfunction length(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"length\",\r\n    reference: length,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length !== this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac/mac.ts\r\nfunction mac(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac\",\r\n    reference: mac,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac48/mac48.ts\r\nfunction mac48(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac48\",\r\n    reference: mac48,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC48_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mac64/mac64.ts\r\nfunction mac64(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mac64\",\r\n    reference: mac64,\r\n    async: false,\r\n    expects: null,\r\n    requirement: MAC64_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mapItems/mapItems.ts\r\nfunction mapItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"map_items\",\r\n    reference: mapItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.map(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxBytes/maxBytes.ts\r\nfunction maxBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_bytes\",\r\n    reference: maxBytes,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 > this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxLength/maxLength.ts\r\nfunction maxLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_length\",\r\n    reference: maxLength,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length > this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxSize/maxSize.ts\r\nfunction maxSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_size\",\r\n    reference: maxSize,\r\n    async: false,\r\n    expects: `<=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size > this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/maxValue/maxValue.ts\r\nfunction maxValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"max_value\",\r\n    reference: maxValue,\r\n    async: false,\r\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value > this.requirement) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/mimeType/mimeType.ts\r\nfunction mimeType(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"mime_type\",\r\n    reference: mimeType,\r\n    async: false,\r\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\r\n        _addIssue(this, \"MIME type\", dataset, config2, {\r\n          received: `\"${dataset.value.type}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minBytes/minBytes.ts\r\nfunction minBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_bytes\",\r\n    reference: minBytes,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 < this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minLength/minLength.ts\r\nfunction minLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_length\",\r\n    reference: minLength,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length < this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minSize/minSize.ts\r\nfunction minSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_size\",\r\n    reference: minSize,\r\n    async: false,\r\n    expects: `>=${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size < this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/minValue/minValue.ts\r\nfunction minValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"min_value\",\r\n    reference: minValue,\r\n    async: false,\r\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value < this.requirement) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/multipleOf/multipleOf.ts\r\nfunction multipleOf(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"multiple_of\",\r\n    reference: multipleOf,\r\n    async: false,\r\n    expects: `%${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\r\n        _addIssue(this, \"multiple\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/nonEmpty/nonEmpty.ts\r\nfunction nonEmpty(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"non_empty\",\r\n    reference: nonEmpty,\r\n    async: false,\r\n    expects: \"!0\",\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length === 0) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: \"0\"\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/normalize/normalize.ts\r\nfunction normalize(form) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"normalize\",\r\n    reference: normalize,\r\n    async: false,\r\n    form,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.normalize(this.form);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notBytes/notBytes.ts\r\nfunction notBytes(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_bytes\",\r\n    reference: notBytes,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed) {\r\n        const length2 = new TextEncoder().encode(dataset.value).length;\r\n        if (length2 === this.requirement) {\r\n          _addIssue(this, \"bytes\", dataset, config2, {\r\n            received: `${length2}`\r\n          });\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notLength/notLength.ts\r\nfunction notLength(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_length\",\r\n    reference: notLength,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.length === this.requirement) {\r\n        _addIssue(this, \"length\", dataset, config2, {\r\n          received: `${dataset.value.length}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notSize/notSize.ts\r\nfunction notSize(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_size\",\r\n    reference: notSize,\r\n    async: false,\r\n    expects: `!${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size === this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/notValue/notValue.ts\r\nfunction notValue(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"not_value\",\r\n    reference: notValue,\r\n    async: false,\r\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/octal/octal.ts\r\nfunction octal(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"octal\",\r\n    reference: octal,\r\n    async: false,\r\n    expects: null,\r\n    requirement: OCTAL_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"octal\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\r\nfunction _isPartiallyTyped(dataset, pathList) {\r\n  if (dataset.issues) {\r\n    for (const path of pathList) {\r\n      for (const issue of dataset.issues) {\r\n        let typed = false;\r\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\r\n        for (let index = 0; index < bound; index++) {\r\n          if (path[index] !== issue.path[index].key) {\r\n            typed = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!typed) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// src/actions/partialCheck/partialCheck.ts\r\nfunction partialCheck(pathList, requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"partial_check\",\r\n    reference: partialCheck,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\r\n      !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/partialCheck/partialCheckAsync.ts\r\nfunction partialCheckAsync(pathList, requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"partial_check\",\r\n    reference: partialCheckAsync,\r\n    async: true,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\r\n      !await this.requirement(dataset.value)) {\r\n        _addIssue(this, \"input\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawCheck/rawCheck.ts\r\nfunction rawCheck(action) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"raw_check\",\r\n    reference: rawCheck,\r\n    async: false,\r\n    expects: null,\r\n    _run(dataset, config2) {\r\n      action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\r\n      });\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawCheck/rawCheckAsync.ts\r\nfunction rawCheckAsync(action) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"raw_check\",\r\n    reference: rawCheckAsync,\r\n    async: true,\r\n    expects: null,\r\n    async _run(dataset, config2) {\r\n      await action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\r\n      });\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawTransform/rawTransform.ts\r\nfunction rawTransform(action) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"raw_transform\",\r\n    reference: rawTransform,\r\n    async: false,\r\n    _run(dataset, config2) {\r\n      const output = action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\r\n        NEVER: null\r\n      });\r\n      if (dataset.issues) {\r\n        dataset.typed = false;\r\n      } else {\r\n        dataset.value = output;\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/rawTransform/rawTransformAsync.ts\r\nfunction rawTransformAsync(action) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"raw_transform\",\r\n    reference: rawTransformAsync,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      const output = await action({\r\n        dataset,\r\n        config: config2,\r\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\r\n        NEVER: null\r\n      });\r\n      if (dataset.issues) {\r\n        dataset.typed = false;\r\n      } else {\r\n        dataset.value = output;\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/readonly/readonly.ts\r\nfunction readonly() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"readonly\",\r\n    reference: readonly,\r\n    async: false,\r\n    _run(dataset) {\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/reduceItems/reduceItems.ts\r\nfunction reduceItems(operation, initial) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"reduce_items\",\r\n    reference: reduceItems,\r\n    async: false,\r\n    operation,\r\n    initial,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/regex/regex.ts\r\nfunction regex(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"regex\",\r\n    reference: regex,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"format\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/safeInteger/safeInteger.ts\r\nfunction safeInteger(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"safe_integer\",\r\n    reference: safeInteger,\r\n    async: false,\r\n    expects: null,\r\n    requirement: Number.isSafeInteger,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"safe integer\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/size/size.ts\r\nfunction size(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"size\",\r\n    reference: size,\r\n    async: false,\r\n    expects: `${requirement}`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && dataset.value.size !== this.requirement) {\r\n        _addIssue(this, \"size\", dataset, config2, {\r\n          received: `${dataset.value.size}`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/someItem/someItem.ts\r\nfunction someItem(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"some_item\",\r\n    reference: someItem,\r\n    async: false,\r\n    expects: null,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\r\n        _addIssue(this, \"item\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/sortItems/sortItems.ts\r\nfunction sortItems(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"sort_items\",\r\n    reference: sortItems,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.sort(this.operation);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/startsWith/startsWith.ts\r\nfunction startsWith(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"starts_with\",\r\n    reference: startsWith,\r\n    async: false,\r\n    expects: `\"${requirement}\"`,\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\r\n        _addIssue(this, \"start\", dataset, config2, {\r\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toLowerCase/toLowerCase.ts\r\nfunction toLowerCase() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_lower_case\",\r\n    reference: toLowerCase,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.toLowerCase();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toMaxValue/toMaxValue.ts\r\nfunction toMaxValue(requirement) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_max_value\",\r\n    reference: toMaxValue,\r\n    async: false,\r\n    requirement,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toMinValue/toMinValue.ts\r\nfunction toMinValue(requirement) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_min_value\",\r\n    reference: toMinValue,\r\n    async: false,\r\n    requirement,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/toUpperCase/toUpperCase.ts\r\nfunction toUpperCase() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"to_upper_case\",\r\n    reference: toUpperCase,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.toUpperCase();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/transform/transform.ts\r\nfunction transform(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"transform\",\r\n    reference: transform,\r\n    async: false,\r\n    operation,\r\n    _run(dataset) {\r\n      dataset.value = this.operation(dataset.value);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/transform/transformAsync.ts\r\nfunction transformAsync(operation) {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"transform\",\r\n    reference: transformAsync,\r\n    async: true,\r\n    operation,\r\n    async _run(dataset) {\r\n      dataset.value = await this.operation(dataset.value);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trim/trim.ts\r\nfunction trim() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim\",\r\n    reference: trim,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trim();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trimEnd/trimEnd.ts\r\nfunction trimEnd() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim_end\",\r\n    reference: trimEnd,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trimEnd();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/trimStart/trimStart.ts\r\nfunction trimStart() {\r\n  return {\r\n    kind: \"transformation\",\r\n    type: \"trim_start\",\r\n    reference: trimStart,\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.value = dataset.value.trimStart();\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/ulid/ulid.ts\r\nfunction ulid(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"ulid\",\r\n    reference: ulid,\r\n    async: false,\r\n    expects: null,\r\n    requirement: ULID_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"ULID\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/url/url.ts\r\nfunction url(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"url\",\r\n    reference: url,\r\n    async: false,\r\n    expects: null,\r\n    requirement(input) {\r\n      try {\r\n        new URL(input);\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement(dataset.value)) {\r\n        _addIssue(this, \"URL\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/uuid/uuid.ts\r\nfunction uuid(message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"uuid\",\r\n    reference: uuid,\r\n    async: false,\r\n    expects: null,\r\n    requirement: UUID_REGEX,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\r\n        _addIssue(this, \"UUID\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/actions/value/value.ts\r\nfunction value(requirement, message) {\r\n  return {\r\n    kind: \"validation\",\r\n    type: \"value\",\r\n    reference: value,\r\n    async: false,\r\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\r\n    requirement,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\r\n        _addIssue(this, \"value\", dataset, config2, {\r\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/config/config.ts\r\nfunction config(schema, config2) {\r\n  return {\r\n    ...schema,\r\n    _run(dataset, config_) {\r\n      return schema._run(dataset, { ...config_, ...config2 });\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/getFallback/getFallback.ts\r\nfunction getFallback(schema, dataset, config2) {\r\n  return typeof schema.fallback === \"function\" ? (\r\n    // @ts-expect-error\r\n    schema.fallback(dataset, config2)\r\n  ) : (\r\n    // @ts-expect-error\r\n    schema.fallback\r\n  );\r\n}\r\n\r\n// src/methods/fallback/fallback.ts\r\nfunction fallback(schema, fallback2) {\r\n  return {\r\n    ...schema,\r\n    fallback: fallback2,\r\n    _run(dataset, config2) {\r\n      schema._run(dataset, config2);\r\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/fallback/fallbackAsync.ts\r\nfunction fallbackAsync(schema, fallback2) {\r\n  return {\r\n    ...schema,\r\n    fallback: fallback2,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      schema._run(dataset, config2);\r\n      return dataset.issues ? (\r\n        // @ts-expect-error\r\n        { typed: true, value: await getFallback(this, dataset, config2) }\r\n      ) : dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/flatten/flatten.ts\r\nfunction flatten(issues) {\r\n  const flatErrors = {};\r\n  for (const issue of issues) {\r\n    if (issue.path) {\r\n      const dotPath = getDotPath(issue);\r\n      if (dotPath) {\r\n        if (!flatErrors.nested) {\r\n          flatErrors.nested = {};\r\n        }\r\n        if (flatErrors.nested[dotPath]) {\r\n          flatErrors.nested[dotPath].push(issue.message);\r\n        } else {\r\n          flatErrors.nested[dotPath] = [issue.message];\r\n        }\r\n      } else {\r\n        if (flatErrors.other) {\r\n          flatErrors.other.push(issue.message);\r\n        } else {\r\n          flatErrors.other = [issue.message];\r\n        }\r\n      }\r\n    } else {\r\n      if (flatErrors.root) {\r\n        flatErrors.root.push(issue.message);\r\n      } else {\r\n        flatErrors.root = [issue.message];\r\n      }\r\n    }\r\n  }\r\n  return flatErrors;\r\n}\r\n\r\n// src/methods/forward/forward.ts\r\nfunction forward(action, pathKeys) {\r\n  return {\r\n    ...action,\r\n    _run(dataset, config2) {\r\n      const prevIssues = dataset.issues && [...dataset.issues];\r\n      action._run(dataset, config2);\r\n      if (dataset.issues) {\r\n        for (const issue of dataset.issues) {\r\n          if (!prevIssues?.includes(issue)) {\r\n            let pathInput = dataset.value;\r\n            for (const key of pathKeys) {\r\n              const pathValue = pathInput[key];\r\n              const pathItem = {\r\n                type: \"unknown\",\r\n                origin: \"value\",\r\n                input: pathInput,\r\n                key,\r\n                value: pathValue\r\n              };\r\n              if (issue.path) {\r\n                issue.path.push(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              if (!pathValue) {\r\n                break;\r\n              }\r\n              pathInput = pathValue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/forward/forwardAsync.ts\r\nfunction forwardAsync(action, pathKeys) {\r\n  return {\r\n    ...action,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      const prevIssues = dataset.issues && [...dataset.issues];\r\n      await action._run(dataset, config2);\r\n      if (dataset.issues) {\r\n        for (const issue of dataset.issues) {\r\n          if (!prevIssues?.includes(issue)) {\r\n            let pathInput = dataset.value;\r\n            for (const key of pathKeys) {\r\n              const pathValue = pathInput[key];\r\n              const pathItem = {\r\n                type: \"unknown\",\r\n                origin: \"value\",\r\n                input: pathInput,\r\n                key,\r\n                value: pathValue\r\n              };\r\n              if (issue.path) {\r\n                issue.path.push(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              if (!pathValue) {\r\n                break;\r\n              }\r\n              pathInput = pathValue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/getDefault/getDefault.ts\r\nfunction getDefault(schema, dataset, config2) {\r\n  return typeof schema.default === \"function\" ? (\r\n    // @ts-expect-error\r\n    schema.default(dataset, config2)\r\n  ) : (\r\n    // @ts-expect-error\r\n    schema.default\r\n  );\r\n}\r\n\r\n// src/methods/getDefaults/getDefaults.ts\r\nfunction getDefaults(schema) {\r\n  if (\"entries\" in schema) {\r\n    const object2 = {};\r\n    for (const key in schema.entries) {\r\n      object2[key] = getDefaults(schema.entries[key]);\r\n    }\r\n    return object2;\r\n  }\r\n  if (\"items\" in schema) {\r\n    return schema.items.map(getDefaults);\r\n  }\r\n  return getDefault(schema);\r\n}\r\n\r\n// src/methods/getDefaults/getDefaultsAsync.ts\r\nasync function getDefaultsAsync(schema) {\r\n  if (\"entries\" in schema) {\r\n    return Object.fromEntries(\r\n      await Promise.all(\r\n        Object.entries(schema.entries).map(async ([key, value2]) => [\r\n          key,\r\n          await getDefaultsAsync(value2)\r\n        ])\r\n      )\r\n    );\r\n  }\r\n  if (\"items\" in schema) {\r\n    return Promise.all(schema.items.map(getDefaultsAsync));\r\n  }\r\n  return getDefault(schema);\r\n}\r\n\r\n// src/methods/getFallbacks/getFallbacks.ts\r\nfunction getFallbacks(schema) {\r\n  if (\"entries\" in schema) {\r\n    const object2 = {};\r\n    for (const key in schema.entries) {\r\n      object2[key] = getFallbacks(schema.entries[key]);\r\n    }\r\n    return object2;\r\n  }\r\n  if (\"items\" in schema) {\r\n    return schema.items.map(getFallbacks);\r\n  }\r\n  return getFallback(schema);\r\n}\r\n\r\n// src/methods/getFallbacks/getFallbacksAsync.ts\r\nasync function getFallbacksAsync(schema) {\r\n  if (\"entries\" in schema) {\r\n    return Object.fromEntries(\r\n      await Promise.all(\r\n        Object.entries(schema.entries).map(async ([key, value2]) => [\r\n          key,\r\n          await getFallbacksAsync(value2)\r\n        ])\r\n      )\r\n    );\r\n  }\r\n  if (\"items\" in schema) {\r\n    return Promise.all(schema.items.map(getFallbacksAsync));\r\n  }\r\n  return getFallback(schema);\r\n}\r\n\r\n// src/methods/is/is.ts\r\nfunction is(schema, input) {\r\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\r\n}\r\n\r\n// src/schemas/any/any.ts\r\nfunction any() {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"any\",\r\n    reference: any,\r\n    expects: \"any\",\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.typed = true;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/array/array.ts\r\nfunction array(item, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"array\",\r\n    reference: array,\r\n    expects: \"Array\",\r\n    async: false,\r\n    item,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < input.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/array/arrayAsync.ts\r\nfunction arrayAsync(item, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"array\",\r\n    reference: arrayAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    item,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\r\n        );\r\n        for (let key = 0; key < itemDatasets.length; key++) {\r\n          const itemDataset = itemDatasets[key];\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: input[key]\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/bigint/bigint.ts\r\nfunction bigint(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"bigint\",\r\n    reference: bigint,\r\n    expects: \"bigint\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"bigint\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/blob/blob.ts\r\nfunction blob(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"blob\",\r\n    reference: blob,\r\n    expects: \"Blob\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Blob) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/boolean/boolean.ts\r\nfunction boolean(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"boolean\",\r\n    reference: boolean,\r\n    expects: \"boolean\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"boolean\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/custom/custom.ts\r\nfunction custom(check2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"custom\",\r\n    reference: custom,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    check: check2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.check(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/custom/customAsync.ts\r\nfunction customAsync(check2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"custom\",\r\n    reference: customAsync,\r\n    expects: \"unknown\",\r\n    async: true,\r\n    check: check2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (await this.check(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/date/date.ts\r\nfunction date(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"date\",\r\n    reference: date,\r\n    expects: \"Date\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Date) {\r\n        if (!isNaN(dataset.value)) {\r\n          dataset.typed = true;\r\n        } else {\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            received: '\"Invalid Date\"'\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/enum/enum.ts\r\nfunction enum_(enum__, message) {\r\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"enum\",\r\n    reference: enum_,\r\n    expects: options.map(_stringify).join(\" | \") || \"never\",\r\n    async: false,\r\n    enum: enum__,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.includes(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/file/file.ts\r\nfunction file(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"file\",\r\n    reference: file,\r\n    expects: \"File\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof File) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/function/function.ts\r\nfunction function_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"function\",\r\n    reference: function_,\r\n    expects: \"Function\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"function\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/instance/instance.ts\r\nfunction instance(class_, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"instance\",\r\n    reference: instance,\r\n    expects: class_.name,\r\n    async: false,\r\n    class: class_,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof this.class) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/intersect/utils/_merge/_merge.ts\r\nfunction _merge(value1, value2) {\r\n  if (typeof value1 === typeof value2) {\r\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\r\n      return { value: value1 };\r\n    }\r\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\r\n      for (const key in value2) {\r\n        if (key in value1) {\r\n          const dataset = _merge(value1[key], value2[key]);\r\n          if (dataset.issue) {\r\n            return dataset;\r\n          }\r\n          value1[key] = dataset.value;\r\n        } else {\r\n          value1[key] = value2[key];\r\n        }\r\n      }\r\n      return { value: value1 };\r\n    }\r\n    if (Array.isArray(value1) && Array.isArray(value2)) {\r\n      if (value1.length === value2.length) {\r\n        for (let index = 0; index < value1.length; index++) {\r\n          const dataset = _merge(value1[index], value2[index]);\r\n          if (dataset.issue) {\r\n            return dataset;\r\n          }\r\n          value1[index] = dataset.value;\r\n        }\r\n        return { value: value1 };\r\n      }\r\n    }\r\n  }\r\n  return { issue: true };\r\n}\r\n\r\n// src/schemas/intersect/intersect.ts\r\nfunction intersect(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"intersect\",\r\n    reference: intersect,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.length) {\r\n        const input = dataset.value;\r\n        let outputs;\r\n        dataset.typed = true;\r\n        for (const schema of this.options) {\r\n          const optionDataset = schema._run(\r\n            { typed: false, value: input },\r\n            config2\r\n          );\r\n          if (optionDataset.issues) {\r\n            if (dataset.issues) {\r\n              dataset.issues.push(...optionDataset.issues);\r\n            } else {\r\n              dataset.issues = optionDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!optionDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (dataset.typed) {\r\n            if (outputs) {\r\n              outputs.push(optionDataset.value);\r\n            } else {\r\n              outputs = [optionDataset.value];\r\n            }\r\n          }\r\n        }\r\n        if (dataset.typed) {\r\n          dataset.value = outputs[0];\r\n          for (let index = 1; index < outputs.length; index++) {\r\n            const mergeDataset = _merge(dataset.value, outputs[index]);\r\n            if (mergeDataset.issue) {\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                received: \"unknown\"\r\n              });\r\n              break;\r\n            }\r\n            dataset.value = mergeDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/intersect/intersectAsync.ts\r\nfunction intersectAsync(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"intersect\",\r\n    reference: intersectAsync,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\r\n    async: true,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (this.options.length) {\r\n        const input = dataset.value;\r\n        let outputs;\r\n        dataset.typed = true;\r\n        const optionDatasets = await Promise.all(\r\n          this.options.map(\r\n            (schema) => schema._run({ typed: false, value: input }, config2)\r\n          )\r\n        );\r\n        for (const optionDataset of optionDatasets) {\r\n          if (optionDataset.issues) {\r\n            if (dataset.issues) {\r\n              dataset.issues.push(...optionDataset.issues);\r\n            } else {\r\n              dataset.issues = optionDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!optionDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (dataset.typed) {\r\n            if (outputs) {\r\n              outputs.push(optionDataset.value);\r\n            } else {\r\n              outputs = [optionDataset.value];\r\n            }\r\n          }\r\n        }\r\n        if (dataset.typed) {\r\n          dataset.value = outputs[0];\r\n          for (let index = 1; index < outputs.length; index++) {\r\n            const mergeDataset = _merge(dataset.value, outputs[index]);\r\n            if (mergeDataset.issue) {\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                received: \"unknown\"\r\n              });\r\n              break;\r\n            }\r\n            dataset.value = mergeDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/lazy/lazy.ts\r\nfunction lazy(getter) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"lazy\",\r\n    reference: lazy,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    getter,\r\n    _run(dataset, config2) {\r\n      return this.getter(dataset.value)._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/lazy/lazyAsync.ts\r\nfunction lazyAsync(getter) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"lazy\",\r\n    reference: lazyAsync,\r\n    expects: \"unknown\",\r\n    async: true,\r\n    getter,\r\n    async _run(dataset, config2) {\r\n      return (await this.getter(dataset.value))._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/literal/literal.ts\r\nfunction literal(literal_, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"literal\",\r\n    reference: literal,\r\n    expects: _stringify(literal_),\r\n    async: false,\r\n    literal: literal_,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === this.literal) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseObject/looseObject.ts\r\nfunction looseObject(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_object\",\r\n    reference: looseObject,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              dataset.value[key] = input[key];\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseObject/looseObjectAsync.ts\r\nfunction looseObjectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_object\",\r\n    reference: looseObjectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              dataset.value[key] = input[key];\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseTuple/looseTuple.ts\r\nfunction looseTuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_tuple\",\r\n    reference: looseTuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            dataset.value.push(input[key]);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/looseTuple/looseTupleAsync.ts\r\nfunction looseTupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"loose_tuple\",\r\n    reference: looseTupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            dataset.value.push(input[key]);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/map/map.ts\r\nfunction map(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"map\",\r\n    reference: map,\r\n    expects: \"Map\",\r\n    async: false,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Map) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Map();\r\n        for (const [inputKey, inputValue] of input) {\r\n          const keyDataset = this.key._run(\r\n            { typed: false, value: inputKey },\r\n            config2\r\n          );\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"key\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          const valueDataset = this.value._run(\r\n            { typed: false, value: inputValue },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"value\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.set(keyDataset.value, valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/map/mapAsync.ts\r\nfunction mapAsync(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"map\",\r\n    reference: mapAsync,\r\n    expects: \"Map\",\r\n    async: true,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Map) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Map();\r\n        const datasets = await Promise.all(\r\n          [...input].map(\r\n            ([inputKey, inputValue]) => Promise.all([\r\n              inputKey,\r\n              inputValue,\r\n              this.key._run({ typed: false, value: inputKey }, config2),\r\n              this.value._run({ typed: false, value: inputValue }, config2)\r\n            ])\r\n          )\r\n        );\r\n        for (const [\r\n          inputKey,\r\n          inputValue,\r\n          keyDataset,\r\n          valueDataset\r\n        ] of datasets) {\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"key\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"map\",\r\n              origin: \"value\",\r\n              input,\r\n              key: inputKey,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.set(keyDataset.value, valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nan/nan.ts\r\nfunction nan(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"nan\",\r\n    reference: nan,\r\n    expects: \"NaN\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (Number.isNaN(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/never/never.ts\r\nfunction never(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"never\",\r\n    reference: never,\r\n    expects: \"never\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      _addIssue(this, \"type\", dataset, config2);\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullable/nonNullable.ts\r\nfunction nonNullable(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullable\",\r\n    reference: nonNullable,\r\n    expects: \"!null\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullable/nonNullableAsync.ts\r\nfunction nonNullableAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullable\",\r\n    reference: nonNullableAsync,\r\n    expects: \"!null\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullish/nonNullish.ts\r\nfunction nonNullish(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullish\",\r\n    reference: nonNullish,\r\n    expects: \"!null & !undefined\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonNullish/nonNullishAsync.ts\r\nfunction nonNullishAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_nullish\",\r\n    reference: nonNullishAsync,\r\n    expects: \"!null & !undefined\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonOptional/nonOptional.ts\r\nfunction nonOptional(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_optional\",\r\n    reference: nonOptional,\r\n    expects: \"!undefined\",\r\n    async: false,\r\n    wrapped,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nonOptional/nonOptionalAsync.ts\r\nfunction nonOptionalAsync(wrapped, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"non_optional\",\r\n    reference: nonOptionalAsync,\r\n    expects: \"!undefined\",\r\n    async: true,\r\n    wrapped,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n        return dataset;\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/null/null.ts\r\nfunction null_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"null\",\r\n    reference: null_,\r\n    expects: \"null\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/nullable/nullable.ts\r\nfunction nullable(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullable\",\r\n    reference: nullable,\r\n    expects: `${wrapped.expects} | null`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullable/nullableAsync.ts\r\nfunction nullableAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullable\",\r\n    reference: nullableAsync,\r\n    expects: `${wrapped.expects} | null`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullish/nullish.ts\r\nfunction nullish(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullish\",\r\n    reference: nullish,\r\n    expects: `${wrapped.expects} | null | undefined`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null || dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/nullish/nullishAsync.ts\r\nfunction nullishAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"nullish\",\r\n    reference: nullishAsync,\r\n    expects: `${wrapped.expects} | null | undefined`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === null || dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === null || dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/number/number.ts\r\nfunction number(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"number\",\r\n    reference: number,\r\n    expects: \"number\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/object/object.ts\r\nfunction object(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object\",\r\n    reference: object,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/object/objectAsync.ts\r\nfunction objectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object\",\r\n    reference: objectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/objectWithRest/objectWithRest.ts\r\nfunction objectWithRest(entries, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object_with_rest\",\r\n    reference: objectWithRest,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    rest,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\r\n              const value2 = input[key];\r\n              const valueDataset = this.rest._run(\r\n                { typed: false, value: value2 },\r\n                config2\r\n              );\r\n              if (valueDataset.issues) {\r\n                const pathItem = {\r\n                  type: \"object\",\r\n                  origin: \"value\",\r\n                  input,\r\n                  key,\r\n                  value: value2\r\n                };\r\n                for (const issue of valueDataset.issues) {\r\n                  if (issue.path) {\r\n                    issue.path.unshift(pathItem);\r\n                  } else {\r\n                    issue.path = [pathItem];\r\n                  }\r\n                  dataset.issues?.push(issue);\r\n                }\r\n                if (!dataset.issues) {\r\n                  dataset.issues = valueDataset.issues;\r\n                }\r\n                if (config2.abortEarly) {\r\n                  dataset.typed = false;\r\n                  break;\r\n                }\r\n              }\r\n              if (!valueDataset.typed) {\r\n                dataset.typed = false;\r\n              }\r\n              dataset.value[key] = valueDataset.value;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/objectWithRest/objectWithRestAsync.ts\r\nfunction objectWithRestAsync(entries, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"object_with_rest\",\r\n    reference: objectWithRestAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    rest,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const [normalDatasets, restDatasets] = await Promise.all([\r\n          // Parse schema of each normal entry\r\n          Promise.all(\r\n            Object.entries(this.entries).map(async ([key, schema]) => {\r\n              const value2 = input[key];\r\n              return [\r\n                key,\r\n                value2,\r\n                await schema._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          ),\r\n          // Parse other entries with rest schema\r\n          Promise.all(\r\n            Object.entries(input).filter(\r\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\r\n            ).map(\r\n              async ([key, value2]) => [\r\n                key,\r\n                value2,\r\n                await this.rest._run({ typed: false, value: value2 }, config2)\r\n              ]\r\n            )\r\n          )\r\n        ]);\r\n        for (const [key, value2, valueDataset] of normalDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const [key, value2, valueDataset] of restDatasets) {\r\n            if (valueDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of valueDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = valueDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!valueDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/optional/optional.ts\r\nfunction optional(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"optional\",\r\n    reference: optional,\r\n    expects: `${wrapped.expects} | undefined`,\r\n    async: false,\r\n    wrapped,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/optional/optionalAsync.ts\r\nfunction optionalAsync(wrapped, ...args) {\r\n  const schema = {\r\n    kind: \"schema\",\r\n    type: \"optional\",\r\n    reference: optionalAsync,\r\n    expects: `${wrapped.expects} | undefined`,\r\n    async: true,\r\n    wrapped,\r\n    async _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        if (\"default\" in this) {\r\n          dataset.value = await getDefault(\r\n            this,\r\n            dataset,\r\n            config2\r\n          );\r\n        }\r\n        if (dataset.value === void 0) {\r\n          dataset.typed = true;\r\n          return dataset;\r\n        }\r\n      }\r\n      return this.wrapped._run(dataset, config2);\r\n    }\r\n  };\r\n  if (0 in args) {\r\n    schema.default = args[0];\r\n  }\r\n  return schema;\r\n}\r\n\r\n// src/schemas/picklist/picklist.ts\r\nfunction picklist(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"picklist\",\r\n    reference: picklist,\r\n    expects: options.map(_stringify).join(\" | \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (this.options.includes(dataset.value)) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/promise/promise.ts\r\nfunction promise(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"promise\",\r\n    reference: promise,\r\n    expects: \"Promise\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value instanceof Promise) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/record/record.ts\r\nfunction record(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"record\",\r\n    reference: record,\r\n    expects: \"Object\",\r\n    async: false,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const entryKey in input) {\r\n          if (_isValidObjectKey(input, entryKey)) {\r\n            const entryValue = input[entryKey];\r\n            const keyDataset = this.key._run(\r\n              { typed: false, value: entryKey },\r\n              config2\r\n            );\r\n            if (keyDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"key\",\r\n                input,\r\n                key: entryKey,\r\n                value: entryValue\r\n              };\r\n              for (const issue of keyDataset.issues) {\r\n                issue.path = [pathItem];\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = keyDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            const valueDataset = this.value._run(\r\n              { typed: false, value: entryValue },\r\n              config2\r\n            );\r\n            if (valueDataset.issues) {\r\n              const pathItem = {\r\n                type: \"object\",\r\n                origin: \"value\",\r\n                input,\r\n                key: entryKey,\r\n                value: entryValue\r\n              };\r\n              for (const issue of valueDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = valueDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!keyDataset.typed || !valueDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            if (keyDataset.typed) {\r\n              dataset.value[keyDataset.value] = valueDataset.value;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/record/recordAsync.ts\r\nfunction recordAsync(key, value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"record\",\r\n    reference: recordAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    key,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const datasets = await Promise.all(\r\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\r\n            ([entryKey, entryValue]) => Promise.all([\r\n              entryKey,\r\n              entryValue,\r\n              this.key._run({ typed: false, value: entryKey }, config2),\r\n              this.value._run({ typed: false, value: entryValue }, config2)\r\n            ])\r\n          )\r\n        );\r\n        for (const [\r\n          entryKey,\r\n          entryValue,\r\n          keyDataset,\r\n          valueDataset\r\n        ] of datasets) {\r\n          if (keyDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"key\",\r\n              input,\r\n              key: entryKey,\r\n              value: entryValue\r\n            };\r\n            for (const issue of keyDataset.issues) {\r\n              issue.path = [pathItem];\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = keyDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: entryKey,\r\n              value: entryValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!keyDataset.typed || !valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (keyDataset.typed) {\r\n            dataset.value[keyDataset.value] = valueDataset.value;\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/set/set.ts\r\nfunction set(value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"set\",\r\n    reference: set,\r\n    expects: \"Set\",\r\n    async: false,\r\n    value: value2,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Set) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Set();\r\n        for (const inputValue of input) {\r\n          const valueDataset = this.value._run(\r\n            { typed: false, value: inputValue },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"set\",\r\n              origin: \"value\",\r\n              input,\r\n              key: null,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.add(valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/set/setAsync.ts\r\nfunction setAsync(value2, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"set\",\r\n    reference: setAsync,\r\n    expects: \"Set\",\r\n    async: true,\r\n    value: value2,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input instanceof Set) {\r\n        dataset.typed = true;\r\n        dataset.value = /* @__PURE__ */ new Set();\r\n        const valueDatasets = await Promise.all(\r\n          [...input].map(\r\n            async (inputValue) => [\r\n              inputValue,\r\n              await this.value._run(\r\n                { typed: false, value: inputValue },\r\n                config2\r\n              )\r\n            ]\r\n          )\r\n        );\r\n        for (const [inputValue, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"set\",\r\n              origin: \"value\",\r\n              input,\r\n              key: null,\r\n              value: inputValue\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.add(valueDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictObject/strictObject.ts\r\nfunction strictObject(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_object\",\r\n    reference: strictObject,\r\n    expects: \"Object\",\r\n    async: false,\r\n    entries,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        for (const key in this.entries) {\r\n          const value2 = input[key];\r\n          const valueDataset = this.entries[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (!(key in this.entries)) {\r\n              const value2 = input[key];\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                input: value2,\r\n                expected: \"never\",\r\n                path: [\r\n                  {\r\n                    type: \"object\",\r\n                    origin: \"value\",\r\n                    input,\r\n                    key,\r\n                    value: value2\r\n                  }\r\n                ]\r\n              });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictObject/strictObjectAsync.ts\r\nfunction strictObjectAsync(entries, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_object\",\r\n    reference: strictObjectAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    entries,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        dataset.typed = true;\r\n        dataset.value = {};\r\n        const valueDatasets = await Promise.all(\r\n          Object.entries(this.entries).map(async ([key, schema]) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await schema._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, valueDataset] of valueDatasets) {\r\n          if (valueDataset.issues) {\r\n            const pathItem = {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of valueDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = valueDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!valueDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          if (valueDataset.value !== void 0 || key in input) {\r\n            dataset.value[key] = valueDataset.value;\r\n          }\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const key in input) {\r\n            if (!(key in this.entries)) {\r\n              const value2 = input[key];\r\n              _addIssue(this, \"type\", dataset, config2, {\r\n                input: value2,\r\n                expected: \"never\",\r\n                path: [\r\n                  {\r\n                    type: \"object\",\r\n                    origin: \"value\",\r\n                    input,\r\n                    key,\r\n                    value: value2\r\n                  }\r\n                ]\r\n              });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictTuple/strictTuple.ts\r\nfunction strictTuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_tuple\",\r\n    reference: strictTuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\r\n          const value2 = input[items.length];\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            input: value2,\r\n            expected: \"never\",\r\n            path: [\r\n              {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key: this.items.length,\r\n                value: value2\r\n              }\r\n            ]\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/strictTuple/strictTupleAsync.ts\r\nfunction strictTupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"strict_tuple\",\r\n    reference: strictTupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\r\n          const value2 = input[items.length];\r\n          _addIssue(this, \"type\", dataset, config2, {\r\n            input: value2,\r\n            expected: \"never\",\r\n            path: [\r\n              {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key: this.items.length,\r\n                value: value2\r\n              }\r\n            ]\r\n          });\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/string/string.ts\r\nfunction string(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"string\",\r\n    reference: string,\r\n    expects: \"string\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"string\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/symbol/symbol.ts\r\nfunction symbol(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"symbol\",\r\n    reference: symbol,\r\n    expects: \"symbol\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (typeof dataset.value === \"symbol\") {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tuple/tuple.ts\r\nfunction tuple(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple\",\r\n    reference: tuple,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tuple/tupleAsync.ts\r\nfunction tupleAsync(items, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple\",\r\n    reference: tupleAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const itemDatasets = await Promise.all(\r\n          this.items.map(async (item, key) => {\r\n            const value2 = input[key];\r\n            return [\r\n              key,\r\n              value2,\r\n              await item._run({ typed: false, value: value2 }, config2)\r\n            ];\r\n          })\r\n        );\r\n        for (const [key, value2, itemDataset] of itemDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tupleWithRest/tupleWithRest.ts\r\nfunction tupleWithRest(items, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple_with_rest\",\r\n    reference: tupleWithRest,\r\n    expects: \"Array\",\r\n    async: false,\r\n    items,\r\n    rest,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        for (let key = 0; key < this.items.length; key++) {\r\n          const value2 = input[key];\r\n          const itemDataset = this.items[key]._run(\r\n            { typed: false, value: value2 },\r\n            config2\r\n          );\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (let key = this.items.length; key < input.length; key++) {\r\n            const value2 = input[key];\r\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\r\n            if (itemDataset.issues) {\r\n              const pathItem = {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of itemDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = itemDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!itemDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value.push(itemDataset.value);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\r\nfunction tupleWithRestAsync(items, rest, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"tuple_with_rest\",\r\n    reference: tupleWithRestAsync,\r\n    expects: \"Array\",\r\n    async: true,\r\n    items,\r\n    rest,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (Array.isArray(input)) {\r\n        dataset.typed = true;\r\n        dataset.value = [];\r\n        const [normalDatasets, restDatasets] = await Promise.all([\r\n          // Parse schema of each normal item\r\n          Promise.all(\r\n            this.items.map(async (item, key) => {\r\n              const value2 = input[key];\r\n              return [\r\n                key,\r\n                value2,\r\n                await item._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          ),\r\n          // Parse other items with rest schema\r\n          Promise.all(\r\n            input.slice(this.items.length).map(async (value2, key) => {\r\n              return [\r\n                key + this.items.length,\r\n                value2,\r\n                await this.rest._run({ typed: false, value: value2 }, config2)\r\n              ];\r\n            })\r\n          )\r\n        ]);\r\n        for (const [key, value2, itemDataset] of normalDatasets) {\r\n          if (itemDataset.issues) {\r\n            const pathItem = {\r\n              type: \"array\",\r\n              origin: \"value\",\r\n              input,\r\n              key,\r\n              value: value2\r\n            };\r\n            for (const issue of itemDataset.issues) {\r\n              if (issue.path) {\r\n                issue.path.unshift(pathItem);\r\n              } else {\r\n                issue.path = [pathItem];\r\n              }\r\n              dataset.issues?.push(issue);\r\n            }\r\n            if (!dataset.issues) {\r\n              dataset.issues = itemDataset.issues;\r\n            }\r\n            if (config2.abortEarly) {\r\n              dataset.typed = false;\r\n              break;\r\n            }\r\n          }\r\n          if (!itemDataset.typed) {\r\n            dataset.typed = false;\r\n          }\r\n          dataset.value.push(itemDataset.value);\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly) {\r\n          for (const [key, value2, itemDataset] of restDatasets) {\r\n            if (itemDataset.issues) {\r\n              const pathItem = {\r\n                type: \"array\",\r\n                origin: \"value\",\r\n                input,\r\n                key,\r\n                value: value2\r\n              };\r\n              for (const issue of itemDataset.issues) {\r\n                if (issue.path) {\r\n                  issue.path.unshift(pathItem);\r\n                } else {\r\n                  issue.path = [pathItem];\r\n                }\r\n                dataset.issues?.push(issue);\r\n              }\r\n              if (!dataset.issues) {\r\n                dataset.issues = itemDataset.issues;\r\n              }\r\n              if (config2.abortEarly) {\r\n                dataset.typed = false;\r\n                break;\r\n              }\r\n            }\r\n            if (!itemDataset.typed) {\r\n              dataset.typed = false;\r\n            }\r\n            dataset.value.push(itemDataset.value);\r\n          }\r\n        }\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/undefined/undefined.ts\r\nfunction undefined_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"undefined\",\r\n    reference: undefined_,\r\n    expects: \"undefined\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/union/utils/_subIssues/_subIssues.ts\r\nfunction _subIssues(datasets) {\r\n  let issues;\r\n  if (datasets) {\r\n    for (const dataset of datasets) {\r\n      if (issues) {\r\n        issues.push(...dataset.issues);\r\n      } else {\r\n        issues = dataset.issues;\r\n      }\r\n    }\r\n  }\r\n  return issues;\r\n}\r\n\r\n// src/schemas/union/union.ts\r\nfunction union(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"union\",\r\n    reference: union,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\r\n    async: false,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      let validDataset;\r\n      let typedDatasets;\r\n      let untypedDatasets;\r\n      for (const schema of this.options) {\r\n        const optionDataset = schema._run(\r\n          { typed: false, value: dataset.value },\r\n          config2\r\n        );\r\n        if (optionDataset.typed) {\r\n          if (optionDataset.issues) {\r\n            if (typedDatasets) {\r\n              typedDatasets.push(optionDataset);\r\n            } else {\r\n              typedDatasets = [optionDataset];\r\n            }\r\n          } else {\r\n            validDataset = optionDataset;\r\n            break;\r\n          }\r\n        } else {\r\n          if (untypedDatasets) {\r\n            untypedDatasets.push(optionDataset);\r\n          } else {\r\n            untypedDatasets = [optionDataset];\r\n          }\r\n        }\r\n      }\r\n      if (validDataset) {\r\n        return validDataset;\r\n      }\r\n      if (typedDatasets) {\r\n        if (typedDatasets.length === 1) {\r\n          return typedDatasets[0];\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(typedDatasets)\r\n        });\r\n        dataset.typed = true;\r\n      } else if (untypedDatasets?.length === 1) {\r\n        return untypedDatasets[0];\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(untypedDatasets)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/union/unionAsync.ts\r\nfunction unionAsync(options, message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"union\",\r\n    reference: unionAsync,\r\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\r\n    async: true,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      let validDataset;\r\n      let typedDatasets;\r\n      let untypedDatasets;\r\n      for (const schema of this.options) {\r\n        const optionDataset = await schema._run(\r\n          { typed: false, value: dataset.value },\r\n          config2\r\n        );\r\n        if (optionDataset.typed) {\r\n          if (optionDataset.issues) {\r\n            if (typedDatasets) {\r\n              typedDatasets.push(optionDataset);\r\n            } else {\r\n              typedDatasets = [optionDataset];\r\n            }\r\n          } else {\r\n            validDataset = optionDataset;\r\n            break;\r\n          }\r\n        } else {\r\n          if (untypedDatasets) {\r\n            untypedDatasets.push(optionDataset);\r\n          } else {\r\n            untypedDatasets = [optionDataset];\r\n          }\r\n        }\r\n      }\r\n      if (validDataset) {\r\n        return validDataset;\r\n      }\r\n      if (typedDatasets) {\r\n        if (typedDatasets.length === 1) {\r\n          return typedDatasets[0];\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(typedDatasets)\r\n        });\r\n        dataset.typed = true;\r\n      } else if (untypedDatasets?.length === 1) {\r\n        return untypedDatasets[0];\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          issues: _subIssues(untypedDatasets)\r\n        });\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/unknown/unknown.ts\r\nfunction unknown() {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"unknown\",\r\n    reference: unknown,\r\n    expects: \"unknown\",\r\n    async: false,\r\n    _run(dataset) {\r\n      dataset.typed = true;\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\r\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\r\n  for (const schema of options) {\r\n    if (schema.type === \"variant\") {\r\n      _discriminators(key, schema.options, set2);\r\n    } else {\r\n      set2.add(schema.entries[key].expects);\r\n    }\r\n  }\r\n  return set2;\r\n}\r\n\r\n// src/schemas/variant/variant.ts\r\nfunction variant(key, options, message) {\r\n  let expectedDiscriminators;\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"variant\",\r\n    reference: variant,\r\n    expects: \"Object\",\r\n    async: false,\r\n    key,\r\n    options,\r\n    message,\r\n    _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        const discriminator = input[this.key];\r\n        if (this.key in input) {\r\n          let outputDataset;\r\n          for (const schema of this.options) {\r\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\r\n              { typed: false, value: discriminator },\r\n              config2\r\n            ).issues) {\r\n              const optionDataset = schema._run(\r\n                { typed: false, value: input },\r\n                config2\r\n              );\r\n              if (!optionDataset.issues) {\r\n                return optionDataset;\r\n              }\r\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\r\n                outputDataset = optionDataset;\r\n              }\r\n            }\r\n          }\r\n          if (outputDataset) {\r\n            return outputDataset;\r\n          }\r\n        }\r\n        if (!expectedDiscriminators) {\r\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          input: discriminator,\r\n          expected: expectedDiscriminators,\r\n          path: [\r\n            {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: this.key,\r\n              value: discriminator\r\n            }\r\n          ]\r\n        });\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/variant/variantAsync.ts\r\nfunction variantAsync(key, options, message) {\r\n  let expectedDiscriminators;\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"variant\",\r\n    reference: variantAsync,\r\n    expects: \"Object\",\r\n    async: true,\r\n    key,\r\n    options,\r\n    message,\r\n    async _run(dataset, config2) {\r\n      const input = dataset.value;\r\n      if (input && typeof input === \"object\") {\r\n        const discriminator = input[this.key];\r\n        if (this.key in input) {\r\n          let outputDataset;\r\n          for (const schema of this.options) {\r\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\r\n              { typed: false, value: discriminator },\r\n              config2\r\n            )).issues) {\r\n              const optionDataset = await schema._run(\r\n                { typed: false, value: input },\r\n                config2\r\n              );\r\n              if (!optionDataset.issues) {\r\n                return optionDataset;\r\n              }\r\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\r\n                outputDataset = optionDataset;\r\n              }\r\n            }\r\n          }\r\n          if (outputDataset) {\r\n            return outputDataset;\r\n          }\r\n        }\r\n        if (!expectedDiscriminators) {\r\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\r\n        }\r\n        _addIssue(this, \"type\", dataset, config2, {\r\n          input: discriminator,\r\n          expected: expectedDiscriminators,\r\n          path: [\r\n            {\r\n              type: \"object\",\r\n              origin: \"value\",\r\n              input,\r\n              key: this.key,\r\n              value: discriminator\r\n            }\r\n          ]\r\n        });\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/schemas/void/void.ts\r\nfunction void_(message) {\r\n  return {\r\n    kind: \"schema\",\r\n    type: \"void\",\r\n    reference: void_,\r\n    expects: \"void\",\r\n    async: false,\r\n    message,\r\n    _run(dataset, config2) {\r\n      if (dataset.value === void 0) {\r\n        dataset.typed = true;\r\n      } else {\r\n        _addIssue(this, \"type\", dataset, config2);\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/keyof/keyof.ts\r\nfunction keyof(schema, message) {\r\n  return picklist(Object.keys(schema.entries), message);\r\n}\r\n\r\n// src/methods/omit/omit.ts\r\nfunction omit(schema, keys) {\r\n  const entries = {\r\n    ...schema.entries\r\n  };\r\n  for (const key of keys) {\r\n    delete entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/parse/parse.ts\r\nfunction parse(schema, input, config2) {\r\n  const dataset = schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  if (dataset.issues) {\r\n    throw new ValiError(dataset.issues);\r\n  }\r\n  return dataset.value;\r\n}\r\n\r\n// src/methods/parse/parseAsync.ts\r\nasync function parseAsync(schema, input, config2) {\r\n  const dataset = await schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  if (dataset.issues) {\r\n    throw new ValiError(dataset.issues);\r\n  }\r\n  return dataset.value;\r\n}\r\n\r\n// src/methods/parser/parser.ts\r\nfunction parser(schema, config2) {\r\n  const func = (input) => parse(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/parser/parserAsync.ts\r\nfunction parserAsync(schema, config2) {\r\n  const func = (input) => parseAsync(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/partial/partial.ts\r\nfunction partial(schema, keys) {\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/partial/partialAsync.ts\r\nfunction partialAsync(schema, keys) {\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/pick/pick.ts\r\nfunction pick(schema, keys) {\r\n  const entries = {};\r\n  for (const key of keys) {\r\n    entries[key] = schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/pipe/pipe.ts\r\nfunction pipe(...pipe2) {\r\n  return {\r\n    ...pipe2[0],\r\n    pipe: pipe2,\r\n    _run(dataset, config2) {\r\n      for (let index = 0; index < pipe2.length; index++) {\r\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\r\n          dataset.typed = false;\r\n          break;\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\r\n          dataset = pipe2[index]._run(dataset, config2);\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/pipe/pipeAsync.ts\r\nfunction pipeAsync(...pipe2) {\r\n  return {\r\n    ...pipe2[0],\r\n    pipe: pipe2,\r\n    async: true,\r\n    async _run(dataset, config2) {\r\n      for (let index = 0; index < pipe2.length; index++) {\r\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\r\n          dataset.typed = false;\r\n          break;\r\n        }\r\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\r\n          dataset = await pipe2[index]._run(dataset, config2);\r\n        }\r\n      }\r\n      return dataset;\r\n    }\r\n  };\r\n}\r\n\r\n// src/methods/required/required.ts\r\nfunction required(schema, arg2, arg3) {\r\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\r\n  const message = Array.isArray(arg2) ? arg3 : arg2;\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/required/requiredAsync.ts\r\nfunction requiredAsync(schema, arg2, arg3) {\r\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\r\n  const message = Array.isArray(arg2) ? arg3 : arg2;\r\n  const entries = {};\r\n  for (const key in schema.entries) {\r\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\r\n  }\r\n  return { ...schema, entries };\r\n}\r\n\r\n// src/methods/safeParse/safeParse.ts\r\nfunction safeParse(schema, input, config2) {\r\n  const dataset = schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  return {\r\n    typed: dataset.typed,\r\n    success: !dataset.issues,\r\n    output: dataset.value,\r\n    issues: dataset.issues\r\n  };\r\n}\r\n\r\n// src/methods/safeParse/safeParseAsync.ts\r\nasync function safeParseAsync(schema, input, config2) {\r\n  const dataset = await schema._run(\r\n    { typed: false, value: input },\r\n    getGlobalConfig(config2)\r\n  );\r\n  return {\r\n    typed: dataset.typed,\r\n    success: !dataset.issues,\r\n    output: dataset.value,\r\n    issues: dataset.issues\r\n  };\r\n}\r\n\r\n// src/methods/safeParser/safeParser.ts\r\nfunction safeParser(schema, config2) {\r\n  const func = (input) => safeParse(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/safeParser/safeParserAsync.ts\r\nfunction safeParserAsync(schema, config2) {\r\n  const func = (input) => safeParseAsync(schema, input, config2);\r\n  func.schema = schema;\r\n  func.config = config2;\r\n  return func;\r\n}\r\n\r\n// src/methods/unwrap/unwrap.ts\r\nfunction unwrap(schema) {\r\n  return schema.wrapped;\r\n}\r\nexport {\r\n  BIC_REGEX,\r\n  CUID2_REGEX,\r\n  DECIMAL_REGEX,\r\n  EMAIL_REGEX,\r\n  EMOJI_REGEX,\r\n  HEXADECIMAL_REGEX,\r\n  HEX_COLOR_REGEX,\r\n  IMEI_REGEX,\r\n  IPV4_REGEX,\r\n  IPV6_REGEX,\r\n  IP_REGEX,\r\n  ISO_DATE_REGEX,\r\n  ISO_DATE_TIME_REGEX,\r\n  ISO_TIMESTAMP_REGEX,\r\n  ISO_TIME_REGEX,\r\n  ISO_TIME_SECOND_REGEX,\r\n  ISO_WEEK_REGEX,\r\n  MAC48_REGEX,\r\n  MAC64_REGEX,\r\n  MAC_REGEX,\r\n  OCTAL_REGEX,\r\n  ULID_REGEX,\r\n  UUID_REGEX,\r\n  ValiError,\r\n  _addIssue,\r\n  _isLuhnAlgo,\r\n  _isValidObjectKey,\r\n  _stringify,\r\n  any,\r\n  array,\r\n  arrayAsync,\r\n  awaitAsync,\r\n  bic,\r\n  bigint,\r\n  blob,\r\n  boolean,\r\n  brand,\r\n  bytes,\r\n  check,\r\n  checkAsync,\r\n  checkItems,\r\n  config,\r\n  creditCard,\r\n  cuid2,\r\n  custom,\r\n  customAsync,\r\n  date,\r\n  decimal,\r\n  deleteGlobalConfig,\r\n  deleteGlobalMessage,\r\n  deleteSchemaMessage,\r\n  deleteSpecificMessage,\r\n  email,\r\n  emoji,\r\n  empty,\r\n  endsWith,\r\n  entriesFromList,\r\n  enum_ as enum,\r\n  enum_,\r\n  everyItem,\r\n  excludes,\r\n  fallback,\r\n  fallbackAsync,\r\n  file,\r\n  filterItems,\r\n  findItem,\r\n  finite,\r\n  flatten,\r\n  forward,\r\n  forwardAsync,\r\n  function_ as function,\r\n  function_,\r\n  getDefault,\r\n  getDefaults,\r\n  getDefaultsAsync,\r\n  getDotPath,\r\n  getFallback,\r\n  getFallbacks,\r\n  getFallbacksAsync,\r\n  getGlobalConfig,\r\n  getGlobalMessage,\r\n  getSchemaMessage,\r\n  getSpecificMessage,\r\n  hash,\r\n  hexColor,\r\n  hexadecimal,\r\n  imei,\r\n  includes,\r\n  instance,\r\n  integer,\r\n  intersect,\r\n  intersectAsync,\r\n  ip,\r\n  ipv4,\r\n  ipv6,\r\n  is,\r\n  isOfKind,\r\n  isOfType,\r\n  isValiError,\r\n  isoDate,\r\n  isoDateTime,\r\n  isoTime,\r\n  isoTimeSecond,\r\n  isoTimestamp,\r\n  isoWeek,\r\n  keyof,\r\n  lazy,\r\n  lazyAsync,\r\n  length,\r\n  literal,\r\n  looseObject,\r\n  looseObjectAsync,\r\n  looseTuple,\r\n  looseTupleAsync,\r\n  mac,\r\n  mac48,\r\n  mac64,\r\n  map,\r\n  mapAsync,\r\n  mapItems,\r\n  maxBytes,\r\n  maxLength,\r\n  maxSize,\r\n  maxValue,\r\n  mimeType,\r\n  minBytes,\r\n  minLength,\r\n  minSize,\r\n  minValue,\r\n  multipleOf,\r\n  nan,\r\n  never,\r\n  nonEmpty,\r\n  nonNullable,\r\n  nonNullableAsync,\r\n  nonNullish,\r\n  nonNullishAsync,\r\n  nonOptional,\r\n  nonOptionalAsync,\r\n  normalize,\r\n  notBytes,\r\n  notLength,\r\n  notSize,\r\n  notValue,\r\n  null_ as null,\r\n  null_,\r\n  nullable,\r\n  nullableAsync,\r\n  nullish,\r\n  nullishAsync,\r\n  number,\r\n  object,\r\n  objectAsync,\r\n  objectWithRest,\r\n  objectWithRestAsync,\r\n  octal,\r\n  omit,\r\n  optional,\r\n  optionalAsync,\r\n  parse,\r\n  parseAsync,\r\n  parser,\r\n  parserAsync,\r\n  partial,\r\n  partialAsync,\r\n  partialCheck,\r\n  partialCheckAsync,\r\n  pick,\r\n  picklist,\r\n  pipe,\r\n  pipeAsync,\r\n  promise,\r\n  rawCheck,\r\n  rawCheckAsync,\r\n  rawTransform,\r\n  rawTransformAsync,\r\n  readonly,\r\n  record,\r\n  recordAsync,\r\n  reduceItems,\r\n  regex,\r\n  required,\r\n  requiredAsync,\r\n  safeInteger,\r\n  safeParse,\r\n  safeParseAsync,\r\n  safeParser,\r\n  safeParserAsync,\r\n  set,\r\n  setAsync,\r\n  setGlobalConfig,\r\n  setGlobalMessage,\r\n  setSchemaMessage,\r\n  setSpecificMessage,\r\n  size,\r\n  someItem,\r\n  sortItems,\r\n  startsWith,\r\n  strictObject,\r\n  strictObjectAsync,\r\n  strictTuple,\r\n  strictTupleAsync,\r\n  string,\r\n  symbol,\r\n  toLowerCase,\r\n  toMaxValue,\r\n  toMinValue,\r\n  toUpperCase,\r\n  transform,\r\n  transformAsync,\r\n  trim,\r\n  trimEnd,\r\n  trimStart,\r\n  tuple,\r\n  tupleAsync,\r\n  tupleWithRest,\r\n  tupleWithRestAsync,\r\n  ulid,\r\n  undefined_ as undefined,\r\n  undefined_,\r\n  union,\r\n  unionAsync,\r\n  unknown,\r\n  unwrap,\r\n  url,\r\n  uuid,\r\n  value,\r\n  variant,\r\n  variantAsync,\r\n  void_ as void,\r\n  void_\r\n};\r\n"],
  "mappings": "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",
  "names": ["chunk", "array"]
}
