import {
  Field,
  aInRange,
  bytesToNumberBE,
  concatBytes,
  createCurve,
  createHasher,
  ed25519,
  ensureBytes,
  inRange,
  isogenyMap,
  mapToCurveSimpleSWU,
  mod,
  numberToBytesBE,
  pow2,
  require_poseidon_lite,
  secp256r1,
  sha256 as sha2562
} from "./chunk-Q4LL4FO2.js";
import {
  initGraphQLTada
} from "./chunk-M5E4BJCX.js";
import {
  print,
  sha256
} from "./chunk-AJWWCJMF.js";
import {
  require_react_dom
} from "./chunk-TRNWTHID.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  array,
  bigint,
  boolean,
  check,
  chunk,
  integer,
  is,
  lazy,
  literal,
  nullable,
  nullish,
  number,
  object,
  optional,
  parse,
  pipe,
  record,
  string,
  transform,
  tuple,
  union,
  unknown
} from "./chunk-43KOUUSD.js";
import {
  base58
} from "./chunk-NVVIVNFB.js";
import {
  blake2b,
  bytesToHex,
  hexToBytes,
  randomBytes
} from "./chunk-TE6664JB.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@suiet/wallet-kit/dist/index.js
var Q = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.28.2";
var TARGETED_RPC_VERSION = "1.48.0";

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/client/errors.js
var CODE_TO_ERROR_TYPE = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
var SuiHTTPTransportError = class extends Error {
};
var JsonRpcError = class extends SuiHTTPTransportError {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.type = CODE_TO_ERROR_TYPE[code] ?? "ServerError";
  }
};
var SuiHTTPStatusError = class extends SuiHTTPTransportError {
  constructor(message, status, statusText) {
    super(message);
    this.status = status;
    this.statusText = statusText;
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/client/rpc-websocket-client.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _requestId;
var _disconnects;
var _webSocket;
var _connectionPromise;
var _subscriptions;
var _pendingRequests;
var _WebsocketClient_instances;
var setupWebSocket_fn;
var reconnect_fn;
function getWebsocketUrl(httpUrl) {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  return url.toString();
}
var DEFAULT_CLIENT_OPTIONS = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket !== "undefined" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
var WebsocketClient = class {
  constructor(endpoint, options = {}) {
    __privateAdd(this, _WebsocketClient_instances);
    __privateAdd(this, _requestId, 0);
    __privateAdd(this, _disconnects, 0);
    __privateAdd(this, _webSocket, null);
    __privateAdd(this, _connectionPromise, null);
    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Set());
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
    this.endpoint = endpoint;
    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };
    if (!this.options.WebSocketConstructor) {
      throw new Error("Missing WebSocket constructor");
    }
    if (this.endpoint.startsWith("http")) {
      this.endpoint = getWebsocketUrl(this.endpoint);
    }
  }
  async makeRequest(method, params, signal) {
    const webSocket = await __privateMethod(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);
    return new Promise((resolve, reject) => {
      __privateSet(this, _requestId, __privateGet(this, _requestId) + 1);
      __privateGet(this, _pendingRequests).set(__privateGet(this, _requestId), {
        resolve,
        reject,
        timeout: setTimeout(() => {
          __privateGet(this, _pendingRequests).delete(__privateGet(this, _requestId));
          reject(new Error(`Request timeout: ${method}`));
        }, this.options.callTimeout)
      });
      signal == null ? void 0 : signal.addEventListener("abort", () => {
        __privateGet(this, _pendingRequests).delete(__privateGet(this, _requestId));
        reject(signal.reason);
      });
      webSocket.send(JSON.stringify({ jsonrpc: "2.0", id: __privateGet(this, _requestId), method, params }));
    }).then(({ error, result }) => {
      if (error) {
        throw new JsonRpcError(error.message, error.code);
      }
      return result;
    });
  }
  async subscribe(input) {
    const subscription = new RpcSubscription(input);
    __privateGet(this, _subscriptions).add(subscription);
    await subscription.subscribe(this);
    return () => subscription.unsubscribe(this);
  }
};
_requestId = /* @__PURE__ */ new WeakMap();
_disconnects = /* @__PURE__ */ new WeakMap();
_webSocket = /* @__PURE__ */ new WeakMap();
_connectionPromise = /* @__PURE__ */ new WeakMap();
_subscriptions = /* @__PURE__ */ new WeakMap();
_pendingRequests = /* @__PURE__ */ new WeakMap();
_WebsocketClient_instances = /* @__PURE__ */ new WeakSet();
setupWebSocket_fn = function() {
  if (__privateGet(this, _connectionPromise)) {
    return __privateGet(this, _connectionPromise);
  }
  __privateSet(this, _connectionPromise, new Promise((resolve) => {
    var _a2;
    (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
    __privateSet(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));
    __privateGet(this, _webSocket).addEventListener("open", () => {
      __privateSet(this, _disconnects, 0);
      resolve(__privateGet(this, _webSocket));
    });
    __privateGet(this, _webSocket).addEventListener("close", () => {
      __privateWrapper(this, _disconnects)._++;
      if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {
        setTimeout(() => {
          __privateMethod(this, _WebsocketClient_instances, reconnect_fn).call(this);
        }, this.options.reconnectTimeout);
      }
    });
    __privateGet(this, _webSocket).addEventListener("message", ({ data }) => {
      let json;
      try {
        json = JSON.parse(data);
      } catch (error) {
        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));
        return;
      }
      if ("id" in json && json.id != null && __privateGet(this, _pendingRequests).has(json.id)) {
        const { resolve: resolve2, timeout } = __privateGet(this, _pendingRequests).get(json.id);
        clearTimeout(timeout);
        resolve2(json);
      } else if ("params" in json) {
        const { params } = json;
        __privateGet(this, _subscriptions).forEach((subscription) => {
          if (subscription.subscriptionId === params.subscription) {
            if (params.subscription === subscription.subscriptionId) {
              subscription.onMessage(params.result);
            }
          }
        });
      }
    });
  }));
  return __privateGet(this, _connectionPromise);
};
reconnect_fn = async function() {
  var _a2;
  (_a2 = __privateGet(this, _webSocket)) == null ? void 0 : _a2.close();
  __privateSet(this, _connectionPromise, null);
  return Promise.allSettled(
    [...__privateGet(this, _subscriptions)].map((subscription) => subscription.subscribe(this))
  );
};
var RpcSubscription = class {
  constructor(input) {
    this.subscriptionId = null;
    this.subscribed = false;
    this.input = input;
  }
  onMessage(message) {
    if (this.subscribed) {
      this.input.onMessage(message);
    }
  }
  async unsubscribe(client) {
    const { subscriptionId } = this;
    this.subscribed = false;
    if (subscriptionId == null) return false;
    this.subscriptionId = null;
    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);
  }
  async subscribe(client) {
    this.subscriptionId = null;
    this.subscribed = true;
    const newSubscriptionId = await client.makeRequest(
      this.input.method,
      this.input.params,
      this.input.signal
    );
    if (this.subscribed) {
      this.subscriptionId = newSubscriptionId;
    }
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/client/http-transport.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _requestId2;
var _options;
var _websocketClient;
var _SuiHTTPTransport_instances;
var getWebsocketClient_fn;
var SuiHTTPTransport = class {
  constructor(options) {
    __privateAdd2(this, _SuiHTTPTransport_instances);
    __privateAdd2(this, _requestId2, 0);
    __privateAdd2(this, _options);
    __privateAdd2(this, _websocketClient);
    __privateSet2(this, _options, options);
  }
  fetch(input, init) {
    const fetchFn = __privateGet2(this, _options).fetch ?? fetch;
    if (!fetchFn) {
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    }
    return fetchFn(input, init);
  }
  async request(input) {
    var _a2, _b;
    __privateSet2(this, _requestId2, __privateGet2(this, _requestId2) + 1);
    const res = await this.fetch(((_a2 = __privateGet2(this, _options).rpc) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url, {
      method: "POST",
      signal: input.signal,
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": PACKAGE_VERSION,
        "Client-Target-Api-Version": TARGETED_RPC_VERSION,
        "Client-Request-Method": input.method,
        ...(_b = __privateGet2(this, _options).rpc) == null ? void 0 : _b.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: __privateGet2(this, _requestId2),
        method: input.method,
        params: input.params
      })
    });
    if (!res.ok) {
      throw new SuiHTTPStatusError(
        `Unexpected status code: ${res.status}`,
        res.status,
        res.statusText
      );
    }
    const data = await res.json();
    if ("error" in data && data.error != null) {
      throw new JsonRpcError(data.error.message, data.error.code);
    }
    return data.result;
  }
  async subscribe(input) {
    const unsubscribe = await __privateMethod2(this, _SuiHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);
    if (input.signal) {
      input.signal.throwIfAborted();
      input.signal.addEventListener("abort", () => {
        unsubscribe();
      });
    }
    return async () => !!await unsubscribe();
  }
};
_requestId2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
_websocketClient = /* @__PURE__ */ new WeakMap();
_SuiHTTPTransport_instances = /* @__PURE__ */ new WeakSet();
getWebsocketClient_fn = function() {
  var _a2;
  if (!__privateGet2(this, _websocketClient)) {
    const WebSocketConstructor = __privateGet2(this, _options).WebSocketConstructor ?? WebSocket;
    if (!WebSocketConstructor) {
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    }
    __privateSet2(this, _websocketClient, new WebsocketClient(
      ((_a2 = __privateGet2(this, _options).websocket) == null ? void 0 : _a2.url) ?? __privateGet2(this, _options).url,
      {
        WebSocketConstructor,
        ...__privateGet2(this, _options).websocket
      }
    ));
  }
  return __privateGet2(this, _websocketClient);
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/b64.js
function fromBase64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i, i + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}
var toB64 = toBase64;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/hex.js
function fromHex(hexStr) {
  var _a2;
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = ((_a2 = padded.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : _a2.map((byte) => parseInt(byte, 16))) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num2) {
  let arr = [];
  let len = 0;
  if (num2 === 0) {
    return [0];
  }
  while (num2 > 0) {
    arr[len] = num2 & 127;
    if (num2 >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num2) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num2);
    this.shift(num2);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i = 0; i < length; i++) {
      result.push(cb(this, i, length));
    }
    return result;
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian(BigInt(value), 8).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian(BigInt(value), 16).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian(BigInt(value), 32).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode(value).forEach((el2) => this.write8(el2));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el2, i) => cb(this, el2, i, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i = 0; i < this.bytePosition; i++) {
      yield this.dataView.getUint8(i);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  let result = new Uint8Array(size);
  let i = 0;
  while (bigint2 > 0) {
    result[i] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i += 1;
  }
  return result;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd3(this, _write);
    __privateAdd3(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet3(this, _write, options.write);
    __privateSet3(this, _serialize, options.serialize ?? ((value, options2) => {
      const writer = new BcsWriter({
        initialSize: this.serializedSize(value) ?? void 0,
        ...options2
      });
      __privateGet3(this, _write).call(this, value, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value, writer) {
    this.validate(value);
    __privateGet3(this, _write).call(this, value, writer);
  }
  serialize(value, options) {
    this.validate(value);
    return new SerializedBcs(this, __privateGet3(this, _serialize).call(this, value, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  fromHex(hex) {
    return this.parse(fromHex(hex));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name,
    input,
    output,
    validate: validate2
  }) {
    return new _BcsType2({
      name: name ?? this.name,
      read: (reader) => output ? output(this.read(reader)) : this.read(reader),
      write: (value, writer) => __privateGet3(this, _write).call(this, input ? input(value) : value, writer),
      serializedSize: (value) => this.serializedSize(input ? input(value) : value),
      serialize: (value, options) => __privateGet3(this, _serialize).call(this, input ? input(value) : value, options),
      validate: (value) => {
        validate2 == null ? void 0 : validate2(value);
        this.validate(input ? input(value) : value);
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(type, schema) {
    __privateAdd3(this, _schema);
    __privateAdd3(this, _bytes);
    __privateSet3(this, _schema, type);
    __privateSet3(this, _bytes, schema);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet3(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet3(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet3(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet3(this, _bytes));
  }
  parse() {
    return __privateGet3(this, _schema).parse(__privateGet3(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](value),
    validate: (value) => {
      var _a2;
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](BigInt(value)),
    validate: (val) => {
      var _a2;
      const value = BigInt(val);
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type = new BcsType({
    ...options,
    serialize,
    write: (value, writer) => {
      for (const byte of type.serialize(value).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type;
}
function stringLikeBcsType({
  toBytes,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex, writer) => {
      const bytes = toBytes(hex);
      writer.writeULEB(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        writer.write8(bytes[i]);
      }
    },
    serialize: (value) => {
      const bytes = toBytes(value);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value) => {
      var _a2;
      if (typeof value !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
      }
      (_a2 = options.validate) == null ? void 0 : _a2.call(options, value);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value) => getType().serializedSize(value),
    write: (value, writer) => getType().write(value, writer),
    serialize: (value, options) => getType().serialize(value, options).toBytes()
  });
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/dist/esm/bcs.js
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      name: "bool",
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value, writer) => writer.write8(value ? 1 : 0),
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (typeof value !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      name: "uleb128",
      read: (reader) => reader.readULEB(),
      serialize: (value) => {
        return Uint8Array.from(ulebEncode(value));
      },
      ...options
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      name: `bytes[${size}]`,
      size,
      read: (reader) => reader.readBytes(size),
      write: (value, writer) => {
        const array2 = new Uint8Array(value);
        for (let i = 0; i < size; i++) {
          writer.write8(array2[i] ?? 0);
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(options) {
    return new BcsType({
      name: `bytesVector`,
      read: (reader) => {
        const length = reader.readULEB();
        return reader.readBytes(length);
      },
      write: (value, writer) => {
        const array2 = new Uint8Array(value);
        writer.writeULEB(array2.length);
        for (let i = 0; i < array2.length; i++) {
          writer.write8(array2[i] ?? 0);
        }
      },
      ...options,
      serializedSize: (value) => {
        const length = "length" in value ? value.length : null;
        return length == null ? null : ulebEncode(length).length + length;
      },
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      name: "string",
      toBytes: (value) => new TextEncoder().encode(value),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(size, type, options) {
    return new BcsType({
      name: `${type.name}[${size}]`,
      read: (reader) => {
        const result = new Array(size);
        for (let i = 0; i < size; i++) {
          result[i] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const item of value) {
          type.write(item, writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(type) {
    return bcs.enum(`Option<${type.name}>`, {
      None: null,
      Some: type
    }).transform({
      input: (value) => {
        if (value == null) {
          return { None: true };
        }
        return { Some: value };
      },
      output: (value) => {
        if (value.$kind === "Some") {
          return value.Some;
        }
        return null;
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(type, options) {
    return new BcsType({
      name: `vector<${type.name}>`,
      read: (reader) => {
        const length = reader.readULEB();
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
          result[i] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        writer.writeULEB(value.length);
        for (const item of value) {
          type.write(item, writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(types, options) {
    return new BcsType({
      name: `(${types.map((t) => t.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i = 0; i < types.length; i++) {
          const size = types[i].serializedSize(values[i]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const type of types) {
          result.push(type.read(reader));
        }
        return result;
      },
      write: (value, writer) => {
        for (let i = 0; i < types.length; i++) {
          types[i].write(value[i], writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (!Array.isArray(value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== types.length) {
          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name, fields, options) {
    const canonicalOrder = Object.entries(fields);
    return new BcsType({
      name,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type] of canonicalOrder) {
          const size = type.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type] of canonicalOrder) {
          result[field] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const [field, type] of canonicalOrder) {
          type.write(value[field], writer);
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name, values, options) {
    const canonicalOrder = Object.entries(values);
    return new BcsType({
      name,
      read: (reader) => {
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${name}`);
        }
        const [kind, type] = enumEntry;
        return {
          [kind]: (type == null ? void 0 : type.read(reader)) ?? true,
          $kind: kind
        };
      },
      write: (value, writer) => {
        const [name2, val] = Object.entries(value).filter(
          ([name3]) => Object.hasOwn(values, name3)
        )[0];
        for (let i = 0; i < canonicalOrder.length; i++) {
          const [optionName, optionType] = canonicalOrder[i];
          if (optionName === name2) {
            writer.writeULEB(i);
            optionType == null ? void 0 : optionType.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.validate) == null ? void 0 : _a2.call(options, value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
        const keys = Object.keys(value).filter(
          (k) => value[k] !== void 0 && Object.hasOwn(values, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${name}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(values, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(keyType, valueType) {
    return bcs.vector(bcs.tuple([keyType, valueType])).transform({
      name: `Map<${keyType.name}, ${valueType.name}>`,
      input: (value) => {
        return [...value.entries()];
      },
      output: (value) => {
        const result = /* @__PURE__ */ new Map();
        for (const [key, val] of value) {
          result.set(key, val);
        }
        return result;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _prefix;
var _cache;
var _ClientCache = class _ClientCache2 {
  constructor({ prefix, cache } = {}) {
    __privateAdd4(this, _prefix);
    __privateAdd4(this, _cache);
    __privateSet4(this, _prefix, prefix ?? []);
    __privateSet4(this, _cache, cache ?? /* @__PURE__ */ new Map());
  }
  read(key, load) {
    const cacheKey = [__privateGet4(this, _prefix), ...key].join(":");
    if (__privateGet4(this, _cache).has(cacheKey)) {
      return __privateGet4(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet4(this, _cache).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v) => {
        __privateGet4(this, _cache).set(cacheKey, v);
        return v;
      }).catch((err) => {
        __privateGet4(this, _cache).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet4(this, _prefix), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet4(this, _cache).clear();
      return;
    }
    for (const key of __privateGet4(this, _cache).keys()) {
      if (key.startsWith(prefixKey)) {
        __privateGet4(this, _cache).delete(key);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache2({
      prefix: [...__privateGet4(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet4(this, _cache)
    });
  }
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
  constructor({ network }) {
    this.cache = new ClientCache();
    this.network = network;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          if ("experimental_asClientExtension" in registration) {
            const { name, register } = registration.experimental_asClientExtension();
            return [name, { value: register(this) }];
          }
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH = 235;
function isValidSuiNSName(name) {
  if (name.length > MAX_SUI_NS_NAME_LENGTH) {
    return false;
  }
  if (name.includes("@")) {
    return SUI_NS_NAME_REGEX.test(name);
  }
  return SUI_NS_DOMAIN_REGEX.test(name);
}
function normalizeSuiNSName(name, format = "at") {
  const lowerCase = name.toLowerCase();
  let parts;
  if (lowerCase.includes("@")) {
    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    const [labels, domain] = lowerCase.split("@");
    parts = [...labels ? labels.split(".") : [], domain];
  } else {
    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {
      throw new Error(`Invalid SuiNS name ${name}`);
    }
    parts = lowerCase.split(".").slice(0, -1);
  }
  if (format === "dot") {
    return `${parts.join(".")}.sui`;
  }
  return `${parts.slice(0, -1).join(".")}@${parts[parts.length - 1]}`;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX = /^\d+$/;
var MAX_APP_SIZE = 64;
var NAME_SEPARATOR = "/";
var isValidNamedPackage = (name) => {
  const parts = name.split(NAME_SEPARATOR);
  if (parts.length < 2 || parts.length > 3) return false;
  const [org, app, version] = parts;
  if (version !== void 0 && !VERSION_REGEX.test(version)) return false;
  if (!isValidSuiNSName(org)) return false;
  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromBase58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function parseTypeTag(type) {
  if (!type.includes("::")) return type;
  return parseStructTag(type);
}
function parseStructTag(type) {
  const [address, module] = type.split("::");
  const isMvrPackage = isValidNamedPackage(address);
  const rest = type.slice(address.length + module.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: isMvrPackage ? address : normalizeSuiAddress(address),
    module,
    name,
    typeParams
  };
}
function normalizeStructTag(type) {
  const { address, module, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
  const formattedTypeParams = (typeParams == null ? void 0 : typeParams.length) > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return bcs.enum("Option", {
    None: null,
    Some: type
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value) => fromBase58(value),
  output: (value) => toBase58(new Uint8Array(value)),
  validate: (value) => {
    if (fromBase58(value).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null,
  ConsensusV2: bcs.struct("ConsensusV2", {
    authenticator: bcs.enum("Authenticator", {
      SingleOwner: Address
    }),
    startVersion: bcs.u64()
  })
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.vector(bcs.u8()).transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.vector(bcs.u8()).transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T) {
  return bcs.struct(`IntentMessage<${T.name}>`, {
    intent: Intent,
    value: T
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8()),
  ZkLogin: bcs.vector(bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.vector(bcs.u8()).transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
  authenticatorData: bcs.vector(bcs.u8()),
  clientDataJson: bcs.string(),
  userSignature: bcs.vector(bcs.u8())
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.vector(bcs.u8()) }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs.vector(Address)
    }
  ),
  AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
    address: Address,
    coinType: bcs.string()
  }),
  CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/bcs/pure.js
function pureBcsSchemaFromTypeName(name) {
  switch (name) {
    case "u8":
      return bcs.u8();
    case "u16":
      return bcs.u16();
    case "u32":
      return bcs.u32();
    case "u64":
      return bcs.u64();
    case "u128":
      return bcs.u128();
    case "u256":
      return bcs.u256();
    case "bool":
      return bcs.bool();
    case "string":
      return bcs.string();
    case "id":
    case "address":
      return Address;
  }
  const generic = name.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return bcs.vector(pureBcsSchemaFromTypeName(inner));
    } else {
      return bcs.option(pureBcsSchemaFromTypeName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name}`);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  Command,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  Owner,
  PasskeyAuthenticator,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  TransactionData,
  TransactionDataV1,
  TransactionEffects,
  TransactionExpiration,
  TransactionKind,
  TypeTag
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/plugins/utils.js
function batch(arr, size) {
  const batches = [];
  for (let i = 0; i < arr.length; i += size) {
    batches.push(arr.slice(i, i + size));
  }
  return batches;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));
  return pipe(
    union(unionOptions),
    transform((value) => ({
      ...value,
      $kind: Object.keys(value)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value) => normalizeSuiAddress(value)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRef = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var Argument2 = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value) => ({
    ...value,
    $kind: Object.keys(value)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBody = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignature = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBody
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = safeEnum({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent
});
var ObjectArg2 = safeEnum({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArg2,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionData2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2)
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var Commands = {
  MoveCall(input) {
    const [pkg, mod2 = "", fn2 = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod2,
        function: fn2,
        typeArguments: input.typeArguments ?? [],
        arguments: input.arguments ?? []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o) => parse(Argument2, o)),
        address: parse(Argument2, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse(Argument2, coin),
        amounts: amounts.map((o) => parse(Argument2, o))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse(Argument2, destination),
        sources: sources.map((o) => parse(Argument2, o))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse(Argument2, ticket)
      }
    };
  },
  MakeMoveVec({
    type,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type ?? null,
        elements: elements.map((o) => parse(Argument2, o))
      }
    };
  },
  Intent({
    name,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.map((o) => parse(Argument2, o)) : parse(Argument2, value)
          ])
        ),
        data
      }
    };
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef2 = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg3 = safeEnum({
  ImmOrOwned: ObjectRef2,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef2
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg3,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val)) return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag3) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag3 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef2)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  var _a2;
  const inputs = transactionData.inputs.map(
    (input, index) => {
      if (input.Object) {
        return {
          kind: "Input",
          index,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: transactionData.sender ?? void 0,
    expiration: ((_a2 = transactionData.expiration) == null ? void 0 : _a2.$kind) === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: transactionData.gasData.owner ?? void 0,
      budget: transactionData.gasData.budget ?? void 0,
      price: transactionData.gasData.price ?? void 0,
      payment: transactionData.gasData.payment ?? void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod2) => Array.from(fromBase64(mod2))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  var _a2, _b, _c2;
  return parse(TransactionData2, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: ((_a2 = data.gasConfig.budget) == null ? void 0 : _a2.toString()) ?? null,
      price: ((_b = data.gasConfig.price) == null ? void 0 : _b.toString()) ?? null,
      payment: ((_c2 = data.gasConfig.payment) == null ? void 0 : _c2.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      }))) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value = parse(NormalizedCallArg2, input.value);
          if (value.Object) {
            if (value.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value.Object.ImmOrOwned.objectId,
                    version: String(value.Object.ImmOrOwned.version),
                    digest: value.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value.Object.Shared.mutable ?? null,
                    initialSharedVersion: value.Object.Shared.initialSharedVersion,
                    objectId: value.Object.Shared.objectId
                  }
                }
              };
            }
            if (value.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value.Object.Receiving.digest,
                    version: String(value.Object.Receiving.version),
                    objectId: value.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod2, fn2] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod2,
              function: fn2,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod2) => toBase64(Uint8Array.from(mod2))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key, value]) => object({ [key]: value }))
  );
}
var Argument3 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number(), integer()),
  Result: pipe(number(), integer()),
  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData3 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRef))
});
var ProgrammableMoveCall3 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument3)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument3, array(Argument3)])),
  data: record(string(), unknown())
});
var Command3 = enumUnion({
  MoveCall: ProgrammableMoveCall3,
  TransferObjects: object({
    objects: array(Argument3),
    address: Argument3
  }),
  SplitCoins: object({
    coin: Argument3,
    amounts: array(Argument3)
  }),
  MergeCoins: object({
    destination: Argument3,
    sources: array(Argument3)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument3)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument3
  }),
  $Intent: $Intent2
});
var ObjectArg4 = enumUnion({
  ImmOrOwnedObject: ObjectRef,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var CallArg3 = enumUnion({
  Object: ObjectArg4,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2 = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData3,
  inputs: array(CallArg3),
  commands: array(Command3)
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID(parentId, typeTag, key) {
  const address = suiBcs.Address.serialize(parentId).toBytes();
  const tag = suiBcs.TypeTag.serialize(typeTag).toBytes();
  const keyLength = suiBcs.u64().serialize(key.length).toBytes();
  const hash = blake2b.create({
    dkLen: 32
  });
  hash.update(new Uint8Array([240]));
  hash.update(address);
  hash.update(keyLength);
  hash.update(key);
  hash.update(tag);
  return `0x${toHex(hash.digest().slice(0, 32))}`;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.vector(suiBcs.U8).transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type = getPureBcsSchema(typeSignature.vector);
    return type ? suiBcs.vector(type) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type ? suiBcs.vector(type) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type) {
  if (typeof type === "object" && "Reference" in type) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)
    };
  }
  if (typeof type === "object" && "MutableReference" in type) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type) {
  if (typeof type === "string") {
    switch (type) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type}`);
    }
  }
  if ("Vector" in type) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };
  }
  if ("Struct" in type) {
    return {
      datatype: {
        package: type.Struct.address,
        module: type.Struct.module,
        type: type.Struct.name,
        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type) {
    return { typeParameter: type.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
async function resolveTransactionData(transactionData, options, next) {
  await normalizeInputs(transactionData, options);
  await resolveObjectReferences(transactionData, options);
  if (!options.onlyTransactionKind) {
    await setGasPrice(transactionData, options);
    await setGasBudget(transactionData, options);
    await setGasPayment(transactionData, options);
  }
  await validate(transactionData);
  return await next();
}
async function setGasPrice(transactionData, options) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, options) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await getClient(options).dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, options) {
  if (!transactionData.gasConfig.payment) {
    const coins = await getClient(options).getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        var _a2;
        if ((_a2 = input.Object) == null ? void 0 : _a2.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));
  }
}
async function resolveObjectReferences(transactionData, options) {
  const objectsToResolve = transactionData.inputs.filter((input) => {
    var _a2;
    return input.UnresolvedObject && !(input.UnresolvedObject.version || ((_a2 = input.UnresolvedObject) == null ? void 0 : _a2.initialSharedVersion));
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => getClient(options).multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id, index) => {
      return [id, resolved[index]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_2, obj]) => obj.error).map(([_2, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" && "Shared" in owner ? owner.Shared.initial_shared_version : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id, index) => {
      return [id, objects[index]];
    })
  );
  for (const [index, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id);
    if (input.UnresolvedObject.initialSharedVersion ?? (object2 == null ? void 0 : object2.initialSharedVersion)) {
      updated = Inputs.SharedObjectRef({
        objectId: id,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || (object2 == null ? void 0 : object2.initialSharedVersion),
        mutable: isUsedAsMutable(transactionData, index)
      });
    } else if (isUsedAsReceiving(transactionData, index)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id,
          digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
          version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
      objectId: id,
      digest: input.UnresolvedObject.digest ?? (object2 == null ? void 0 : object2.digest),
      version: input.UnresolvedObject.version ?? (object2 == null ? void 0 : object2.version)
    });
  }
}
async function normalizeInputs(transactionData, options) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => (input == null ? void 0 : input.UnresolvedPure) || (input == null ? void 0 : input.UnresolvedObject)
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    const client = getClient(options);
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i) => {
      var _a2, _b;
      const arg = moveCall.arguments[i];
      if (arg.$kind !== "Input") return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = ((_a2 = input.UnresolvedPure) == null ? void 0 : _a2.value) ?? ((_b = input.UnresolvedObject) == null ? void 0 : _b.objectId);
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}
function isUsedAsMutable(transactionData, index) {
  let usedAsMutable = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type) {
  if (typeof type.body !== "object" || !("datatype" in type.body)) {
    return false;
  }
  return type.body.datatype.package === "0x2" && type.body.datatype.module === "transfer" && type.body.datatype.type === "Receiving";
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value) {
    return makeObject(value);
  }
  object2.system = () => object2("0x5");
  object2.clock = () => object2("0x6");
  object2.random = () => object2("0x8");
  object2.denyList = () => object2("0x403");
  object2.option = ({ type, value }) => (tx) => tx.moveCall({
    typeArguments: [type],
    target: `0x1::option::${value === null ? "none" : "some"}`,
    arguments: value === null ? [] : [tx.object(value)]
  });
  return object2;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value) => makePure(suiBcs.U8.serialize(value));
  pure.u16 = (value) => makePure(suiBcs.U16.serialize(value));
  pure.u32 = (value) => makePure(suiBcs.U32.serialize(value));
  pure.u64 = (value) => makePure(suiBcs.U64.serialize(value));
  pure.u128 = (value) => makePure(suiBcs.U128.serialize(value));
  pure.u256 = (value) => makePure(suiBcs.U256.serialize(value));
  pure.bool = (value) => makePure(suiBcs.Bool.serialize(value));
  pure.string = (value) => makePure(suiBcs.String.serialize(value));
  pure.address = (value) => makePure(suiBcs.Address.serialize(value));
  pure.id = pure.address;
  pure.vector = (type, value) => {
    return makePure(
      suiBcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value)
    );
  };
  pure.option = (type, value) => {
    return makePure(suiBcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));
  };
  return pure;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class _TransactionDataBuilder {
  constructor(clone) {
    this.version = 2;
    this.sender = (clone == null ? void 0 : clone.sender) ?? null;
    this.expiration = (clone == null ? void 0 : clone.expiration) ?? null;
    this.inputs = (clone == null ? void 0 : clone.inputs) ?? [];
    this.commands = (clone == null ? void 0 : clone.commands) ?? [];
    this.gasData = (clone == null ? void 0 : clone.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new _TransactionDataBuilder(parse(TransactionData2, data));
    } else {
      return new _TransactionDataBuilder(parse(TransactionData2, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toBase58(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value) {
    this.gasData = value;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasData = { ...this.gasData, ...overrides == null ? void 0 : overrides.gasConfig, ...overrides == null ? void 0 : overrides.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type, $kind: "Input" };
  }
  getInputUses(index, fn2) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn2(arg, command);
      }
      return arg;
    });
  }
  mapArguments(fn2) {
    for (const command of this.commands) {
      switch (command.$kind) {
        case "MoveCall":
          command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn2(arg, command));
          break;
        case "TransferObjects":
          command.TransferObjects.objects = command.TransferObjects.objects.map(
            (arg) => fn2(arg, command)
          );
          command.TransferObjects.address = fn2(command.TransferObjects.address, command);
          break;
        case "SplitCoins":
          command.SplitCoins.coin = fn2(command.SplitCoins.coin, command);
          command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn2(arg, command));
          break;
        case "MergeCoins":
          command.MergeCoins.destination = fn2(command.MergeCoins.destination, command);
          command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn2(arg, command));
          break;
        case "MakeMoveVec":
          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
            (arg) => fn2(arg, command)
          );
          break;
        case "Upgrade":
          command.Upgrade.ticket = fn2(command.Upgrade.ticket, command);
          break;
        case "$Intent":
          const inputs = command.$Intent.inputs;
          command.$Intent.inputs = {};
          for (const [key, value] of Object.entries(inputs)) {
            command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn2(arg, command)) : fn2(value, command);
          }
          break;
        case "Publish":
          break;
        default:
          throw new Error(`Unexpected transaction kind: ${command.$kind}`);
      }
    }
  }
  replaceCommand(index, replacement) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg) => {
        switch (arg.$kind) {
          case "Result":
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse(TransactionData2, this);
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _data;
var _Transaction_instances;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
function createTransactionResult(index, length = Infinity) {
  const baseResult = { $kind: "Result", Result: index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    $kind: "NestedResult",
    NestedResult: [index, resultIndex]
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i = 0;
          while (i < length) {
            yield nestedResultFor(i);
            i++;
          }
        };
      }
      if (typeof property === "symbol") return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0) return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch (e) {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd5(this, _Transaction_instances);
    __privateAdd5(this, _serializationPlugins);
    __privateAdd5(this, _buildPlugins);
    __privateAdd5(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd5(this, _data);
    this.object = createObjectMethods(
      (value) => {
        var _a2, _b;
        if (typeof value === "function") {
          return this.object(value(this));
        }
        if (typeof value === "object" && is(Argument2, value)) {
          return value;
        }
        const id = getIdFromCallArg(value);
        const inserted = __privateGet5(this, _data).inputs.find((i) => id === getIdFromCallArg(i));
        if (((_a2 = inserted == null ? void 0 : inserted.Object) == null ? void 0 : _a2.SharedObject) && typeof value === "object" && ((_b = value.Object) == null ? void 0 : _b.SharedObject)) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet5(this, _data).inputs.indexOf(inserted), type: "object" } : __privateGet5(this, _data).addInput(
          "object",
          typeof value === "string" ? {
            $kind: "UnresolvedObject",
            UnresolvedObject: { objectId: normalizeSuiAddress(value) }
          } : value
        );
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet5(this, _data, new TransactionDataBuilder());
    __privateSet5(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet5(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _Transaction2();
    __privateSet5(tx, _data, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet5(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet5(newTransaction, _data, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet5(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name) {
    getGlobalPluginRegistry().serializationPlugins.delete(name);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name) {
    getGlobalPluginRegistry().buildPlugins.delete(name);
  }
  addSerializationPlugin(step) {
    __privateGet5(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet5(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet5(this, _intentResolvers).has(intent) && __privateGet5(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet5(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet5(this, _data).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet5(this, _data).sender) {
      __privateGet5(this, _data).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet5(this, _data).expiration = expiration ? parse(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet5(this, _data).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet5(this, _data).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet5(this, _data).gasData.budget == null) {
      __privateGet5(this, _data).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet5(this, _data).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet5(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet5(this, _data).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet5(this, _data).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value) => {
        if (isSerializedBcs(value)) {
          return __privateGet5(this, _data).addInput("pure", {
            $kind: "Pure",
            Pure: {
              bytes: value.toBase64()
            }
          });
        }
        return __privateGet5(this, _data).addInput(
          "pure",
          is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: "UnresolvedPure", UnresolvedPure: { value } }
        );
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /** Add a transaction to the transaction */
  add(command) {
    if (typeof command === "function") {
      return command(this);
    }
    const index = __privateGet5(this, _data).commands.push(command);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    const command = Commands.SplitCoins(
      typeof coin === "string" ? this.object(coin) : __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
      )
    );
    const index = __privateGet5(this, _data).commands.push(command);
    return createTransactionResult(index - 1, amounts.length);
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall({
    arguments: args,
    ...input
  }) {
    return this.add(
      Commands.MoveCall({
        ...input,
        arguments: args == null ? void 0 : args.map((arg) => __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod3(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet5(this, _data).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    return JSON.stringify(
      parse(SerializedTransactionDataV2, __privateGet5(this, _data).snapshot()),
      (_key, value) => typeof value === "bigint" ? value.toString() : value,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransaction(bytes);
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet5(this, _data).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await __privateMethod3(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet5(this, _data).getDigest();
  }
  async prepareForSerialization(options) {
    var _a2;
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet5(this, _data).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet5(this, _serializationPlugins)];
    for (const intent of intents) {
      if ((_a2 = options.supportedIntents) == null ? void 0 : _a2.includes(intent)) {
        continue;
      }
      if (!__privateGet5(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet5(this, _intentResolvers).get(intent));
    }
    await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod3(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    return parse(Argument2, arg(this));
  }
  return parse(Argument2, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet5(this, _data).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod3(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet5(this, _buildPlugins), resolveTransactionData], options);
};
runPlugins_fn = async function(plugins, options) {
  const createNext = (i) => {
    if (i >= plugins.length) {
      return () => {
      };
    }
    const plugin = plugins[i];
    return async () => {
      const next = createNext(i + 1);
      let calledNext = false;
      let nextResolved = false;
      await plugin(__privateGet5(this, _data), options, async () => {
        if (calledNext) {
          throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);
        }
        calledNext = true;
        await next();
        nextResolved = true;
      });
      if (!calledNext) {
        throw new Error(`next() was not called in TransactionPlugin ${i}`);
      }
      if (!nextResolved) {
        throw new Error(`next() was not awaited in TransactionPlugin ${i}`);
      }
    };
  };
  await createNext(0)();
};
var Transaction = _Transaction;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/experimental/core.js
var Experimental_CoreClient = class extends Experimental_BaseClient {
  constructor() {
    super(...arguments);
    this.core = this;
  }
  async getObject(options) {
    const { objectId } = options;
    const {
      objects: [result]
    } = await this.getObjects({ objectIds: [objectId] });
    if (result instanceof Error) {
      throw result;
    }
    return { object: result };
  }
  async getDynamicField(options) {
    const fieldId = deriveDynamicFieldID(
      options.parentId,
      TypeTagSerializer.parseFromStr(options.name.type),
      options.name.bcs
    );
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId]
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag(fieldObject.type);
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
          bcs: fieldObject.content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_2, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch (e) {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {
};
var ObjectError = class _ObjectError extends SuiClientError {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new _ObjectError(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _ObjectError(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new _ObjectError(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new _ObjectError(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new _ObjectError(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/experimental/transports/jsonRPC.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _jsonRpcClient;
var JSONRpcTransport = class extends Experimental_CoreClient {
  constructor(jsonRpcClient) {
    super({ network: jsonRpcClient.network });
    __privateAdd6(this, _jsonRpcClient);
    __privateSet6(this, _jsonRpcClient, jsonRpcClient);
  }
  async getObjects(options) {
    const batches = batch(options.objectIds, 50);
    const results = [];
    for (const batch2 of batches) {
      const objects = await __privateGet6(this, _jsonRpcClient).multiGetObjects({
        ids: batch2,
        options: {
          showOwner: true,
          showType: true,
          showBcs: true
        }
      });
      for (const [idx, object2] of objects.entries()) {
        if (object2.error) {
          results.push(ObjectError.fromResponse(object2.error, batch2[idx]));
        } else {
          results.push(parseObject(object2.data));
        }
      }
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateGet6(this, _jsonRpcClient).getOwnedObjects({
      owner: options.address,
      limit: options.limit,
      cursor: options.cursor,
      options: {
        showOwner: true,
        showType: true,
        showBcs: true
      }
    });
    return {
      objects: objects.data.map((result) => {
        if (result.error) {
          throw ObjectError.fromResponse(result.error);
        }
        return parseObject(result.data);
      }),
      hasNextPage: objects.hasNextPage,
      cursor: objects.nextCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateGet6(this, _jsonRpcClient).getCoins({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      objects: coins.data.map((coin) => {
        return {
          id: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest,
          balance: coin.balance,
          type: `0x2::coin::Coin<${coin.coinType}>`,
          content: Coin.serialize({
            id: coin.coinObjectId,
            balance: {
              value: coin.balance
            }
          }).toBytes(),
          owner: {
            $kind: "ObjectOwner",
            ObjectOwner: options.address
          }
        };
      }),
      hasNextPage: coins.hasNextPage,
      cursor: coins.nextCursor ?? null
    };
  }
  async getBalance(options) {
    const balance = await __privateGet6(this, _jsonRpcClient).getBalance({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      balance: {
        coinType: balance.coinType,
        balance: balance.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateGet6(this, _jsonRpcClient).getAllBalances({
      owner: options.address
    });
    return {
      balances: balances.map((balance) => ({
        coinType: balance.coinType,
        balance: balance.totalBalance
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(options) {
    const transaction = await __privateGet6(this, _jsonRpcClient).getTransactionBlock({
      digest: options.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async executeTransaction(options) {
    const transaction = await __privateGet6(this, _jsonRpcClient).executeTransactionBlock({
      transactionBlock: options.transaction,
      signature: options.signatures,
      options: {
        showRawEffects: true,
        showEvents: true,
        showObjectChanges: true,
        showRawInput: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async dryRunTransaction(options) {
    const tx = Transaction.from(options.transaction);
    const result = await __privateGet6(this, _jsonRpcClient).dryRunTransactionBlock({
      transactionBlock: options.transaction
    });
    return {
      transaction: {
        digest: await tx.getDigest(),
        effects: parseTransactionEffectsJson({
          effects: result.effects,
          objectChanges: result.objectChanges
        }),
        signatures: [],
        bcs: options.transaction
      }
    };
  }
  async getReferenceGasPrice() {
    const referenceGasPrice = await __privateGet6(this, _jsonRpcClient).getReferenceGasPrice();
    return {
      referenceGasPrice: String(referenceGasPrice)
    };
  }
  async getDynamicFields(options) {
    const dynamicFields = await __privateGet6(this, _jsonRpcClient).getDynamicFields({
      parentId: options.parentId,
      limit: options.limit,
      cursor: options.cursor
    });
    return {
      dynamicFields: dynamicFields.data.map((dynamicField) => ({
        id: dynamicField.objectId,
        version: dynamicField.version,
        digest: dynamicField.digest,
        type: dynamicField.objectType,
        name: {
          type: dynamicField.name.type,
          bcs: fromBase64(dynamicField.bcsName)
        }
      })),
      hasNextPage: dynamicFields.hasNextPage,
      cursor: dynamicFields.nextCursor
    };
  }
};
_jsonRpcClient = /* @__PURE__ */ new WeakMap();
function parseObject(object2) {
  var _a2;
  return {
    id: object2.objectId,
    version: object2.version,
    digest: object2.digest,
    type: object2.type,
    content: ((_a2 = object2.bcs) == null ? void 0 : _a2.dataType) === "moveObject" ? fromBase64(object2.bcs.bcsBytes) : new Uint8Array(),
    owner: parseOwner(object2.owner)
  };
}
function parseOwner(owner) {
  if (owner === "Immutable") {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if ("ConsensusV2" in owner) {
    return {
      $kind: "ConsensusV2",
      ConsensusV2: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: owner.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: owner.ConsensusV2.start_version
      }
    };
  }
  if ("AddressOwner" in owner) {
    return {
      $kind: "AddressOwner",
      AddressOwner: owner.AddressOwner
    };
  }
  if ("ObjectOwner" in owner) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.ObjectOwner
    };
  }
  if ("Shared" in owner) {
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.Shared.initial_shared_version
      }
    };
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction(transaction) {
  const parsedTx = suiBcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];
  return {
    digest: transaction.digest,
    effects: parseTransactionEffects({
      effects: new Uint8Array(transaction.rawEffects),
      objectChanges: transaction.objectChanges ?? null
    }),
    bcs: suiBcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes(),
    signatures: parsedTx.txSignatures
  };
}
function parseTransactionEffects({
  effects,
  epoch,
  objectChanges
}) {
  const parsed = suiBcs.TransactionEffects.parse(effects);
  const objectTypes = {};
  objectChanges == null ? void 0 : objectChanges.forEach((change) => {
    if (change.type !== "published") {
      objectTypes[change.objectId] = change.objectType;
    }
  });
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1, epoch, objectTypes });
    case "V2":
      return parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2, epoch, objectTypes });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV1(_2) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({
  bytes,
  effects,
  epoch,
  objectTypes
}) {
  const changedObjects = effects.changedObjects.map(
    ([id, change]) => {
      var _a2, _b, _c2, _d, _e2, _f;
      return {
        id,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: ((_a2 = change.inputState.Exist) == null ? void 0 : _a2[0][0]) ?? null,
        inputDigest: ((_b = change.inputState.Exist) == null ? void 0 : _b[0][1]) ?? null,
        inputOwner: ((_c2 = change.inputState.Exist) == null ? void 0 : _c2[1]) ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? (_d = change.outputState.PackageWrite) == null ? void 0 : _d[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? (_e2 = change.outputState.PackageWrite) == null ? void 0 : _e2[1] : ((_f = change.outputState.ObjectWrite) == null ? void 0 : _f[0]) ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind,
        objectType: objectTypes[id] ?? null
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    epoch: epoch ?? null,
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedSharedObjects: effects.unchangedSharedObjects.map(
      ([objectId, object2]) => {
        return {
          kind: object2.$kind,
          objectId,
          version: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[0] : object2[object2.$kind],
          digest: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[1] : null,
          objectType: objectTypes[objectId] ?? null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}
function parseTransactionEffectsJson({
  bytes,
  effects,
  epoch,
  objectChanges
}) {
  var _a2;
  const changedObjects = [];
  const unchangedSharedObjects = [];
  objectChanges == null ? void 0 : objectChanges.forEach((change) => {
    var _a3, _b, _c2, _d;
    switch (change.type) {
      case "published":
        changedObjects.push({
          id: change.packageId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "PackageWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: null,
          idOperation: "Created",
          objectType: null
        });
        break;
      case "transferred":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: change.digest,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.recipient),
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "mutated":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.previousVersion,
          inputDigest: null,
          inputOwner: parseOwner(change.owner),
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "deleted":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: ((_b = (_a3 = effects.deleted) == null ? void 0 : _a3.find((d) => d.objectId === change.objectId)) == null ? void 0 : _b.digest) ?? null,
          inputOwner: null,
          outputState: "DoesNotExist",
          outputVersion: null,
          outputDigest: null,
          outputOwner: null,
          idOperation: "Deleted",
          objectType: change.objectType
        });
        break;
      case "wrapped":
        changedObjects.push({
          id: change.objectId,
          inputState: "Exists",
          inputVersion: change.version,
          inputDigest: null,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: change.sender
          },
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: ((_d = (_c2 = effects.wrapped) == null ? void 0 : _c2.find((w) => w.objectId === change.objectId)) == null ? void 0 : _d.digest) ?? null,
          outputOwner: {
            $kind: "ObjectOwner",
            ObjectOwner: change.sender
          },
          idOperation: "None",
          objectType: change.objectType
        });
        break;
      case "created":
        changedObjects.push({
          id: change.objectId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "ObjectWrite",
          outputVersion: change.version,
          outputDigest: change.digest,
          outputOwner: parseOwner(change.owner),
          idOperation: "Created",
          objectType: change.objectType
        });
        break;
    }
  });
  return {
    bcs: bytes ?? null,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.status === "success" ? { success: true, error: null } : { success: false, error: effects.status.error },
    epoch: epoch ?? null,
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: {
      id: (_a2 = effects.gasObject) == null ? void 0 : _a2.reference.objectId,
      inputState: "Exists",
      inputVersion: null,
      inputDigest: null,
      inputOwner: null,
      outputState: "ObjectWrite",
      outputVersion: effects.gasObject.reference.version,
      outputDigest: effects.gasObject.reference.digest,
      outputOwner: parseOwner(effects.gasObject.owner),
      idOperation: "None",
      objectType: normalizeStructTag("0x2::coin::Coin<0x2::sui::SUI>")
    },
    eventsDigest: effects.eventsDigest ?? null,
    dependencies: effects.dependencies ?? [],
    lamportVersion: effects.gasObject.reference.version,
    changedObjects,
    unchangedSharedObjects,
    auxiliaryDataDigest: null
  };
}
var Balance = suiBcs.struct("Balance", {
  value: suiBcs.u64()
});
var Coin = suiBcs.struct("Coin", {
  id: suiBcs.Address,
  balance: Balance
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var _caches;
var _cache2;
var _onEffects;
_caches = /* @__PURE__ */ new WeakMap();
_cache2 = /* @__PURE__ */ new WeakMap();
_onEffects = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var _client;
var _lastDigest;
_client = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var _queue;
var _queue2;
_queue = /* @__PURE__ */ new WeakMap();
_queue2 = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var _queue3;
var _signer;
var _cache3;
var _defaultGasBudget;
var _cacheGasCoin;
var _buildTransaction;
_queue3 = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
  if (!effects.V2) {
    throw new Error("Unexpected effects version");
  }
  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
  if (!gasObjectChange) {
    throw new Error("Gas object not found in effects");
  }
  const [objectId, { outputState }] = gasObjectChange;
  if (!outputState.ObjectWrite) {
    throw new Error("Unexpected gas object state");
  }
  const [digest, owner] = outputState.ObjectWrite;
  return {
    ref: {
      objectId,
      digest,
      version: effects.V2.lamportVersion
    },
    owner: owner.AddressOwner || owner.ObjectOwner
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var __privateWrapper2 = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet7(obj, member, value, setter);
  },
  get _() {
    return __privateGet7(obj, member, getter);
  }
});
var _signer2;
var _client2;
var _coinBatchSize;
var _initialCoinBalance;
var _minimumCoinBalance;
var _epochBoundaryWindow;
var _defaultGasBudget2;
var _maxPoolSize;
var _sourceCoins;
var _coinPool;
var _cache4;
var _objectIdQueues;
var _buildQueue;
var _executeQueue;
var _lastDigest2;
var _cacheLock;
var _pendingTransactions;
var _gasPrice;
var _ParallelTransactionExecutor_instances;
var getUsedObjects_fn;
var execute_fn;
var updateCache_fn;
var waitForLastDigest_fn;
var getGasCoin_fn;
var getGasPrice_fn;
var refillCoinPool_fn;
_signer2 = /* @__PURE__ */ new WeakMap();
_client2 = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget2 = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache4 = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest2 = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options2, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      var _a2, _b, _c2, _d, _e2;
      if ((_b = (_a2 = input.Object) == null ? void 0 : _a2.ImmOrOwnedObject) == null ? void 0 : _b.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if ((_d = (_c2 = input.Object) == null ? void 0 : _c2.Receiving) == null ? void 0 : _d.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (((_e2 = input.UnresolvedObject) == null ? void 0 : _e2.objectId) && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet7(this, _client2) });
  return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {
  var _a2;
  let gasCoin;
  try {
    transaction.setSenderIfNotSet(__privateGet7(this, _signer2).toSuiAddress());
    await __privateGet7(this, _buildQueue).runTask(async () => {
      const data = transaction.getData();
      if (!data.gasData.price) {
        transaction.setGasPrice(await __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
      }
      transaction.setGasBudgetIfNotSet(__privateGet7(this, _defaultGasBudget2));
      await __privateMethod4(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
      gasCoin = await __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
      __privateWrapper2(this, _pendingTransactions)._++;
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      await __privateGet7(this, _cache4).buildTransaction({ transaction, onlyTransactionKind: true });
    });
    const bytes = await transaction.build({ client: __privateGet7(this, _client2) });
    const { signature } = await __privateGet7(this, _signer2).signTransaction(bytes);
    const results = await __privateGet7(this, _cache4).executeTransaction({
      transaction: bytes,
      signature: [signature, ...additionalSignatures],
      options: {
        ...options,
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = suiBcs.TransactionEffects.parse(effectsBytes);
    const gasResult = getGasCoinFromEffects(effects);
    const gasUsed = (_a2 = effects.V2) == null ? void 0 : _a2.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet7(this, _signer2).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      let usesGasCoin = false;
      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
        if (arg.$kind === "GasCoin") {
          usesGasCoin = true;
        }
        return arg;
      });
      if (!usesGasCoin && gasCoin.balance >= __privateGet7(this, _minimumCoinBalance)) {
        __privateGet7(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: gasCoin.balance - totalUsed
        });
      } else {
        if (!__privateGet7(this, _sourceCoins)) {
          __privateSet7(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet7(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    __privateSet7(this, _lastDigest2, results.digest);
    return {
      digest: results.digest,
      effects: toBase64(effectsBytes),
      data: results
    };
  } catch (error) {
    if (gasCoin) {
      if (!__privateGet7(this, _sourceCoins)) {
        __privateSet7(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet7(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateMethod4(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
      await Promise.all([
        __privateGet7(this, _cache4).cache.deleteObjects([...usedObjects]),
        __privateMethod4(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)
      ]);
    });
    throw error;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet7(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet7(this, _objectIdQueues).delete(objectId);
      }
    });
    __privateWrapper2(this, _pendingTransactions)._--;
  }
};
updateCache_fn = async function(fn2) {
  if (__privateGet7(this, _cacheLock)) {
    await __privateGet7(this, _cacheLock);
  }
  __privateSet7(this, _cacheLock, (fn2 == null ? void 0 : fn2().then(
    () => {
      __privateSet7(this, _cacheLock, null);
    },
    () => {
    }
  )) ?? null);
};
waitForLastDigest_fn = async function() {
  const digest = __privateGet7(this, _lastDigest2);
  if (digest) {
    __privateSet7(this, _lastDigest2, null);
    await __privateGet7(this, _client2).waitForTransaction({ digest });
  }
};
getGasCoin_fn = async function() {
  if (__privateGet7(this, _coinPool).length === 0 && __privateGet7(this, _pendingTransactions) <= __privateGet7(this, _maxPoolSize)) {
    await __privateMethod4(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
  }
  if (__privateGet7(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet7(this, _coinPool).shift();
  return coin;
};
getGasPrice_fn = async function() {
  const remaining = __privateGet7(this, _gasPrice) ? __privateGet7(this, _gasPrice).expiration - __privateGet7(this, _epochBoundaryWindow) - Date.now() : 0;
  if (remaining > 0) {
    return __privateGet7(this, _gasPrice).price;
  }
  if (__privateGet7(this, _gasPrice)) {
    const timeToNextEpoch = Math.max(
      __privateGet7(this, _gasPrice).expiration + __privateGet7(this, _epochBoundaryWindow) - Date.now(),
      1e3
    );
    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
  }
  const state = await __privateGet7(this, _client2).getLatestSuiSystemState();
  __privateSet7(this, _gasPrice, {
    price: BigInt(state.referenceGasPrice),
    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
  });
  return __privateMethod4(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
  var _a2;
  const batchSize = Math.min(
    __privateGet7(this, _coinBatchSize),
    __privateGet7(this, _maxPoolSize) - (__privateGet7(this, _coinPool).length + __privateGet7(this, _pendingTransactions)) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new Transaction();
  const address = __privateGet7(this, _signer2).toSuiAddress();
  txb.setSender(address);
  if (__privateGet7(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id, ref] of __privateGet7(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet7(this, _client2).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet7(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet7(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i = 0; i < amounts.length; i++) {
    coinResults.push(results[i]);
  }
  txb.transferObjects(coinResults, address);
  await this.waitForLastTransaction();
  const result = await __privateGet7(this, _client2).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet7(this, _signer2),
    options: {
      showRawEffects: true
    }
  });
  const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  (_a2 = effects.V2) == null ? void 0 : _a2.changedObjects.forEach(([id, { outputState }], i) => {
    var _a3;
    if (i === ((_a3 = effects.V2) == null ? void 0 : _a3.gasObjectIndex) || !outputState.ObjectWrite) {
      return;
    }
    __privateGet7(this, _coinPool).push({
      id,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet7(this, _initialCoinBalance))
    });
  });
  if (!__privateGet7(this, _sourceCoins)) {
    __privateSet7(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = getGasCoinFromEffects(effects).ref;
  __privateGet7(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet7(this, _client2).waitForTransaction({ digest: result.digest });
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
  pure: createPure((value) => (tx) => tx.pure(value)),
  object: createObjectMethods((value) => (tx) => tx.object(value)),
  sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),
  objectRef: (...args) => (tx) => tx.objectRef(...args),
  receivingRef: (...args) => (tx) => tx.receivingRef(...args)
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/client/client.js
var SUI_CLIENT_BRAND = Symbol.for("@mysten/SuiClient");
var SuiClient = class extends Experimental_BaseClient {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    super({ network: options.network ?? "unknown" });
    this.core = new JSONRpcTransport(this);
    this.jsonRpc = this;
    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });
  }
  get [SUI_CLIENT_BRAND]() {
    return true;
  }
  async getRpcApiVersion({ signal } = {}) {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: [],
      signal
    });
    return resp.info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getCoins",
      params: [input.owner, input.coinType, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [input.owner, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getBalance",
      params: [input.owner, input.coinType],
      signal: input.signal
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getAllBalances",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [input.coinType],
      signal: input.signal
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.transport.request({
      method: "suix_getTotalSupply",
      params: [input.coinType],
      signal: input.signal
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, params, { signal } = {}) {
    return await this.transport.request({ method, params, signal });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [input.package, input.module, input.function],
      signal: input.signal
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [input.package],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [input.package, input.module],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [input.package, input.module, input.function],
      signal: input.signal
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [input.package, input.module, input.struct],
      signal: input.signal
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ],
      signal: input.signal
    });
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "sui_getObject",
      params: [input.id, input.options],
      signal: input.signal
    });
  }
  async tryGetPastObject(input) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [input.id, input.version, input.options],
      signal: input.signal
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [input.ids, input.options],
      signal: input.signal
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      signal: input.signal
    });
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [input.digest, input.options],
      signal: input.signal
    });
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d) => {
      if (!isValidTransactionDigest(d)) {
        throw new Error(`Invalid Transaction digest ${d}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [input.digests, input.options],
      signal: input.signal
    });
  }
  async executeTransactionBlock({
    transactionBlock,
    signature,
    options,
    requestType,
    signal
  }) {
    const result = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof transactionBlock === "string" ? transactionBlock : toBase64(transactionBlock),
        Array.isArray(signature) ? signature : [signature],
        options
      ],
      signal
    });
    if (requestType === "WaitForLocalExecution") {
      try {
        await this.waitForTransaction({
          digest: result.digest
        });
      } catch (_2) {
      }
    }
    return result;
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    ...input
  }) {
    let transactionBytes;
    if (transaction instanceof Uint8Array) {
      transactionBytes = transaction;
    } else {
      transaction.setSenderIfNotSet(signer.toSuiAddress());
      transactionBytes = await transaction.build({ client: this });
    }
    const { signature, bytes } = await signer.signTransaction(transactionBytes);
    return this.executeTransactionBlock({
      transactionBlock: bytes,
      signature,
      ...input
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks({ signal } = {}) {
    const resp = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice({ signal } = {}) {
    const resp = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: [],
      signal
    });
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.transport.request({
      method: "suix_getStakes",
      params: [input.owner],
      signal: input.signal
    });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.transport.request({
      method: "suix_getStakesByIds",
      params: [input.stakedSuiIds],
      signal: input.signal
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState({
    signal
  } = {}) {
    return await this.transport.request({
      method: "suix_getLatestSuiSystemState",
      params: [],
      signal
    });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.transport.request({
      method: "suix_queryEvents",
      params: [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      signal: input.signal
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(input) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(input) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [input.filter],
      onMessage: input.onMessage,
      signal: input.signal
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    var _a2, _b;
    let devInspectTxBytes;
    if (isTransaction(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toBase64(
        await input.transactionBlock.build({
          client: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toBase64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    (_a2 = input.signal) == null ? void 0 : _a2.throwIfAborted();
    return await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [input.sender, devInspectTxBytes, (_b = input.gasPrice) == null ? void 0 : _b.toString(), input.epoch],
      signal: input.signal
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toBase64(input.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [input.parentId, input.cursor, input.limit],
      signal: input.signal
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [input.parentId, input.name],
      signal: input.signal
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber({
    signal
  } = {}) {
    const resp = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: [],
      signal
    });
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.transport.request({
      method: "sui_getCheckpoint",
      params: [input.id],
      signal: input.signal
    });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [input.cursor, input == null ? void 0 : input.limit, input.descendingOrder],
      signal: input.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [input == null ? void 0 : input.epoch],
      signal: input == null ? void 0 : input.signal
    });
  }
  async getNetworkMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getNetworkMetrics",
      params: [],
      signal
    });
  }
  async getAddressMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getLatestAddressMetrics",
      params: [],
      signal
    });
  }
  async getEpochMetrics(input) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  async getAllEpochAddressMetrics(input) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [input == null ? void 0 : input.cursor, input == null ? void 0 : input.limit, input == null ? void 0 : input.descendingOrder],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getMoveCallMetrics",
      params: [],
      signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getCurrentEpoch",
      params: [],
      signal
    });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy({ signal } = {}) {
    return await this.transport.request({
      method: "suix_getValidatorsApy",
      params: [],
      signal
    });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier({ signal } = {}) {
    const checkpoint = await this.getCheckpoint({ id: "0", signal });
    const bytes = fromBase58(checkpoint.digest);
    return toHex(bytes.slice(0, 4));
  }
  async resolveNameServiceAddress(input) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [input.name],
      signal: input.signal
    });
  }
  async resolveNameServiceNames({
    format = "dot",
    ...input
  }) {
    const { nextCursor, hasNextPage, data } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [input.address, input.cursor, input.limit],
      signal: input.signal
    });
    return {
      hasNextPage,
      nextCursor,
      data: data.map((name) => normalizeSuiNSName(name, format))
    };
  }
  async getProtocolConfig(input) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [input == null ? void 0 : input.version],
      signal: input == null ? void 0 : input.signal
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    pollInterval = 2 * 1e3,
    ...input
  }) {
    const timeoutSignal = AbortSignal.timeout(timeout);
    const timeoutPromise = new Promise((_2, reject) => {
      timeoutSignal.addEventListener("abort", () => reject(timeoutSignal.reason));
    });
    timeoutPromise.catch(() => {
    });
    while (!timeoutSignal.aborted) {
      signal == null ? void 0 : signal.throwIfAborted();
      try {
        return await this.getTransactionBlock(input);
      } catch (e) {
        await Promise.race([
          new Promise((resolve) => setTimeout(resolve, pollInterval)),
          timeoutPromise
        ]);
      }
    }
    timeoutSignal.throwIfAborted();
    throw new Error("Unexpected error while waiting for transaction block.");
  }
  experimental_asClientExtension() {
    return {
      name: "jsonRPC",
      register: () => {
        return this;
      }
    };
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.fixedArray(message.length, suiBcs.u8())).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.vector(suiBcs.u8()).serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};
function parseSerializedKeypairSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/keypairs/passkey/publickey.js
var PASSKEY_PUBLIC_KEY_SIZE = 33;
var PASSKEY_SIGNATURE_SIZE = 64;
var SECP256R1_SPKI_HEADER = new Uint8Array([
  48,
  89,
  // SEQUENCE, length 89
  48,
  19,
  // SEQUENCE, length 19
  6,
  7,
  // OID, length 7
  42,
  134,
  72,
  206,
  61,
  2,
  1,
  // OID: 1.2.840.10045.2.1 (ecPublicKey)
  6,
  8,
  // OID, length 8
  42,
  134,
  72,
  206,
  61,
  3,
  1,
  7,
  // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)
  3,
  66,
  // BIT STRING, length 66
  0
  // no unused bits
]);
var PasskeyPublicKey = class extends PublicKey2 {
  /**
   * Create a new PasskeyPublicKey object
   * @param value passkey public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two passkey public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Passkey"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    const parsed = parseSerializedPasskeySignature(signature);
    const clientDataJSON = JSON.parse(parsed.clientDataJson);
    if (clientDataJSON.type !== "webauthn.get") {
      return false;
    }
    const parsedChallenge = fromBase64(
      clientDataJSON.challenge.replace(/-/g, "+").replace(/_/g, "/")
    );
    if (!bytesEqual(message, parsedChallenge)) {
      return false;
    }
    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);
    if (!bytesEqual(this.toRawBytes(), pk)) {
      return false;
    }
    const payload = new Uint8Array([...parsed.authenticatorData, ...sha2562(parsed.clientDataJson)]);
    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);
    return secp256r1.verify(sig, sha2562(payload), pk);
  }
};
PasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;
function parseSerializedPasskeySignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {
    throw new Error("Invalid signature scheme");
  }
  const dec = PasskeyAuthenticator.parse(bytes.slice(1));
  return {
    signatureScheme: "Passkey",
    serializedSignature: toBase64(bytes),
    signature: bytes,
    authenticatorData: dec.authenticatorData,
    clientDataJson: dec.clientDataJson,
    userSignature: new Uint8Array(dec.userSignature),
    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError8("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet8 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _url;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {}
  }) {
    __privateAdd7(this, _url);
    __privateAdd7(this, _queries);
    __privateAdd7(this, _headers);
    __privateAdd7(this, _fetch);
    __privateSet8(this, _url, url);
    __privateSet8(this, _queries, queries);
    __privateSet8(this, _headers, headers);
    __privateSet8(this, _fetch, (...args) => fetchFn(...args));
  }
  async query(options) {
    const res = await __privateGet8(this, _fetch).call(this, __privateGet8(this, _url), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet8(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      })
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet8(this, _queries)[query]
    });
  }
};
_url = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/graphql/schemas/latest/index.js
var graphql = initGraphQLTada();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/jwt-decode.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/poseidon.js
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i] !== 0) {
      return i;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num2, width) {
  const hex = num2.toString(16);
  return hexToBytes(hex.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num2, width) {
  const bytes = toPaddedBigEndianBytes(num2, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}
function normalizeZkLoginIssuer(iss) {
  if (iss === "accounts.google.com") {
    return "https://accounts.google.com";
  }
  return iss;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i = 0; i < base64UrlString.length; i++) {
    const base64UrlChar = base64UrlString.charAt(i);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i}))`);
  }
  const lastCharOffset = (i + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i2 = 0; i2 < bits.length; i2 += 8) {
    const bitChunk = bits.slice(i2, i2 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name, value] = verifyExtendedClaim(extendedClaim);
  if (name !== claimName) {
    throw new Error(`Invalid field name: found ${name} expected ${claimName}`);
  }
  return value;
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.vector(bcs.u8())
});

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/signature.js
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromBase64(signature) : signature);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError9 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck9 = (obj, member, msg) => member.has(obj) || __typeError9("Cannot " + msg);
var __privateGet9 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd8 = (obj, member, value) => member.has(obj) ? __typeError9("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet9 = (obj, member, value, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck9(obj, member, "access private method"), method);
var _data2;
var _client3;
var _legacyAddress;
var _ZkLoginPublicIdentifier_instances;
var toLegacyAddress_fn;
var _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier2 extends PublicKey2 {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value, { client } = {}) {
    super();
    __privateAdd8(this, _ZkLoginPublicIdentifier_instances);
    __privateAdd8(this, _data2);
    __privateAdd8(this, _client3);
    __privateAdd8(this, _legacyAddress);
    __privateSet9(this, _client3, client);
    if (typeof value === "string") {
      __privateSet9(this, _data2, fromBase64(value));
    } else if (value instanceof Uint8Array) {
      __privateSet9(this, _data2, value);
    } else {
      __privateSet9(this, _data2, Uint8Array.from(value));
    }
    __privateSet9(this, _legacyAddress, __privateGet9(this, _data2).length !== __privateGet9(this, _data2)[0] + 1 + 32);
    if (__privateGet9(this, _legacyAddress)) {
      __privateSet9(this, _data2, normalizeZkLoginPublicKeyBytes(__privateGet9(this, _data2)));
    }
  }
  static fromProof(address, proof) {
    const { issBase64Details, addressSeed } = proof;
    const iss = extractClaimValue(issBase64Details, "iss");
    const legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: true
    });
    if (legacyPublicKey.toSuiAddress() === address) {
      return legacyPublicKey;
    }
    const publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: false
    });
    if (publicKey.toSuiAddress() !== address) {
      throw new Error("Proof does not match address");
    }
    return publicKey;
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  toSuiAddress() {
    if (__privateGet9(this, _legacyAddress)) {
      return __privateMethod5(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
    }
    return super.toSuiAddress();
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet9(this, _data2);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PERSONAL_MESSAGE",
      client: __privateGet9(this, _client3)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(transaction),
      signature: parsedSignature.serializedSignature,
      intentScope: "TRANSACTION_DATA",
      client: __privateGet9(this, _client3)
    });
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return address === super.toSuiAddress() || address === __privateMethod5(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
  }
};
_data2 = /* @__PURE__ */ new WeakMap();
_client3 = /* @__PURE__ */ new WeakMap();
_legacyAddress = /* @__PURE__ */ new WeakMap();
_ZkLoginPublicIdentifier_instances = /* @__PURE__ */ new WeakSet();
toLegacyAddress_fn = function() {
  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet9(this, _data2), true);
  const addressBytes = new Uint8Array(legacyBytes.length + 1);
  addressBytes[0] = this.flag();
  addressBytes.set(legacyBytes, 1);
  return normalizeSuiAddress(
    bytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
  );
};
var ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = (options == null ? void 0 : options.legacyAddress) ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
var VerifyZkLoginSignatureQuery = graphql(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`);
function normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {
  const issByteLength = bytes[0] + 1;
  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);
  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const data = new Uint8Array(issByteLength + seedBytes.length);
  data.set(bytes.slice(0, issByteLength), 0);
  data.set(seedBytes, issByteLength);
  return data;
}
async function graphqlVerifyZkLoginSignature({
  address,
  bytes,
  signature,
  intentScope,
  client = new SuiGraphQLClient({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  var _a2, _b;
  const resp = await client.query({
    query: VerifyZkLoginSignatureQuery,
    variables: {
      bytes,
      signature,
      intentScope,
      author: address
    }
  });
  return ((_a2 = resp.data) == null ? void 0 : _a2.verifyZkloginSignature.success) === true && ((_b = resp.data) == null ? void 0 : _b.verifyZkloginSignature.errors.length) === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  return {
    serializedSignature: toBase64(bytes),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "Passkey":
      return parseSerializedPasskeySignature(serializedSignature);
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes,
        signature: void 0
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      return parseSerializedKeypairSignature(serializedSignature);
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs.vector(bcs.u8()).serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes),
      signature
    };
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed25519.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var divNearest = (a, b) => (a + b / _2n) / b;
function sqrtMod(y) {
  const P2 = secp256k1P;
  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow2(b3, _3n, P2) * b3 % P2;
  const b9 = pow2(b6, _3n, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: _0n,
  b: BigInt(7),
  Fp: Fpk1,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = (() => secp256k1.ProjectivePoint)();
var GmulAdd = (Q2, a, b) => Point.BASE.multiplyAndAddUnsafe(Q2, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n, secp256k1P);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n !== _0n)
    y = modP(-y);
  const p = new Point(x, y, _1n);
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P2 = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n, secp256k1P))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n, secp256k1N))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P2), m);
    const R2 = GmulAdd(P2, s, modN(-e));
    if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j2) => BigInt(j2)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/keypairs/secp256k1/publickey.js
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256k1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "Secp256k1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256k1.verify(
      secp256k1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/multisig/signer.js
var __typeError10 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck10 = (obj, member, msg) => member.has(obj) || __typeError10("Cannot " + msg);
var __privateGet10 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd9 = (obj, member, value) => member.has(obj) ? __typeError10("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet10 = (obj, member, value, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _pubkey;
var _signers;
var MultiSigSigner = class extends Signer {
  constructor(pubkey, signers = []) {
    var _a2;
    super();
    __privateAdd9(this, _pubkey);
    __privateAdd9(this, _signers);
    __privateSet10(this, _pubkey, pubkey);
    __privateSet10(this, _signers, signers);
    const uniqueKeys = /* @__PURE__ */ new Set();
    let combinedWeight = 0;
    const weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({
      weight,
      address: publicKey.toSuiAddress()
    }));
    for (const signer of signers) {
      const address = signer.toSuiAddress();
      if (uniqueKeys.has(address)) {
        throw new Error(`Can't create MultiSigSigner with duplicate signers`);
      }
      uniqueKeys.add(address);
      const weight = (_a2 = weights.find((w) => w.address === address)) == null ? void 0 : _a2.weight;
      if (!weight) {
        throw new Error(`Signer ${address} is not part of the MultiSig public key`);
      }
      combinedWeight += weight;
    }
    if (combinedWeight < pubkey.getThreshold()) {
      throw new Error(`Combined weight of signers is less than threshold`);
    }
  }
  getKeyScheme() {
    return "MultiSig";
  }
  getPublicKey() {
    return __privateGet10(this, _pubkey);
  }
  sign(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  signData(_data3) {
    throw new Error(
      "MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead"
    );
  }
  async signTransaction(bytes) {
    const signature = __privateGet10(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet10(this, _signers).map(async (signer) => (await signer.signTransaction(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  async signPersonalMessage(bytes) {
    const signature = __privateGet10(this, _pubkey).combinePartialSignatures(
      await Promise.all(
        __privateGet10(this, _signers).map(async (signer) => (await signer.signPersonalMessage(bytes)).signature)
      )
    );
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
};
_pubkey = /* @__PURE__ */ new WeakMap();
_signers = /* @__PURE__ */ new WeakMap();

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/multisig/publickey.js
var MAX_SIGNER_IN_MULTISIG = 10;
var MIN_SIGNER_IN_MULTISIG = 1;
var MultiSigPublicKey2 = class _MultiSigPublicKey extends PublicKey2 {
  /**
   * Create a new MultiSigPublicKey object
   */
  constructor(value, options = {}) {
    super();
    if (typeof value === "string") {
      this.rawBytes = fromBase64(value);
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else if (value instanceof Uint8Array) {
      this.rawBytes = value;
      this.multisigPublicKey = suiBcs.MultiSigPublicKey.parse(this.rawBytes);
    } else {
      this.multisigPublicKey = value;
      this.rawBytes = suiBcs.MultiSigPublicKey.serialize(value).toBytes();
    }
    if (this.multisigPublicKey.threshold < 1) {
      throw new Error("Invalid threshold");
    }
    const seenPublicKeys = /* @__PURE__ */ new Set();
    this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {
      const [scheme, bytes] = Object.entries(pubKey).filter(([name]) => name !== "$kind")[0];
      const publicKeyStr = Uint8Array.from(bytes).toString();
      if (seenPublicKeys.has(publicKeyStr)) {
        throw new Error(`Multisig does not support duplicate public keys`);
      }
      seenPublicKeys.add(publicKeyStr);
      if (weight < 1) {
        throw new Error(`Invalid weight`);
      }
      return {
        publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),
        weight
      };
    });
    const totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);
    if (this.multisigPublicKey.threshold > totalWeight) {
      throw new Error(`Unreachable threshold`);
    }
    if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {
      throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);
    }
  }
  /**
   * 	A static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.
   */
  static fromPublicKeys({
    threshold,
    publicKeys
  }) {
    return new _MultiSigPublicKey({
      pk_map: publicKeys.map(({ publicKey, weight }) => {
        const scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()];
        return {
          pubKey: { [scheme]: Array.from(publicKey.toRawBytes()) },
          weight
        };
      }),
      threshold
    });
  }
  /**
   * Checks if two MultiSig public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the MultiSig public key
   */
  toRawBytes() {
    return this.rawBytes;
  }
  getPublicKeys() {
    return this.publicKeys;
  }
  getThreshold() {
    return this.multisigPublicKey.threshold;
  }
  getSigner(...signers) {
    return new MultiSigSigner(this, signers);
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  toSuiAddress() {
    const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;
    const tmp = new Uint8Array(maxLength);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(suiBcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);
    let i = 3;
    for (const { publicKey, weight } of this.publicKeys) {
      const bytes = publicKey.toSuiBytes();
      tmp.set(bytes, i);
      i += bytes.length;
      tmp.set([weight], i++);
    }
    return normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));
  }
  /**
   * Return the Sui address associated with this MultiSig public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["MultiSig"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, multisigSignature) {
    const parsed = parseSerializedSignature(multisigSignature);
    if (parsed.signatureScheme !== "MultiSig") {
      throw new Error("Invalid signature scheme");
    }
    const { multisig } = parsed;
    let signatureWeight = 0;
    if (!bytesEqual(
      suiBcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),
      suiBcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes()
    )) {
      return false;
    }
    for (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {
      if (!await publicKey.verify(message, signature)) {
        return false;
      }
      signatureWeight += weight;
    }
    return signatureWeight >= this.multisigPublicKey.threshold;
  }
  /**
   * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once
   * and that all the public keys involved are known and valid, and then serializes multisig into the standard format
   */
  combinePartialSignatures(signatures) {
    var _a2, _b;
    if (signatures.length > MAX_SIGNER_IN_MULTISIG) {
      throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);
    }
    let bitmap = 0;
    const compressedSignatures = new Array(signatures.length);
    for (let i = 0; i < signatures.length; i++) {
      const parsed = parseSerializedSignature(signatures[i]);
      if (parsed.signatureScheme === "MultiSig") {
        throw new Error("MultiSig is not supported inside MultiSig");
      }
      let publicKey;
      if (parsed.signatureScheme === "ZkLogin") {
        publicKey = toZkLoginPublicIdentifier(
          (_a2 = parsed.zkLogin) == null ? void 0 : _a2.addressSeed,
          (_b = parsed.zkLogin) == null ? void 0 : _b.iss
        ).toRawBytes();
      } else {
        publicKey = parsed.publicKey;
      }
      compressedSignatures[i] = {
        [parsed.signatureScheme]: Array.from(parsed.signature.map((x) => Number(x)))
      };
      let publicKeyIndex;
      for (let j2 = 0; j2 < this.publicKeys.length; j2++) {
        if (bytesEqual(publicKey, this.publicKeys[j2].publicKey.toRawBytes())) {
          if (bitmap & 1 << j2) {
            throw new Error("Received multiple signatures from the same public key");
          }
          publicKeyIndex = j2;
          break;
        }
      }
      if (publicKeyIndex === void 0) {
        throw new Error("Received signature from unknown public key");
      }
      bitmap |= 1 << publicKeyIndex;
    }
    const multisig = {
      sigs: compressedSignatures,
      bitmap,
      multisig_pk: this.multisigPublicKey
    };
    const bytes = suiBcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();
    const tmp = new Uint8Array(bytes.length + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["MultiSig"]]);
    tmp.set(bytes, 1);
    return toBase64(tmp);
  }
};
function parsePartialSignatures(multisig, options = {}) {
  const res = new Array(multisig.sigs.length);
  for (let i = 0; i < multisig.sigs.length; i++) {
    const [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(
      ([name]) => name !== "$kind"
    )[0];
    const pkIndex = asIndices(multisig.bitmap).at(i);
    const pair = multisig.multisig_pk.pk_map[pkIndex];
    const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);
    if (signatureScheme === "MultiSig") {
      throw new Error("MultiSig is not supported inside MultiSig");
    }
    const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);
    res[i] = {
      signatureScheme,
      signature: Uint8Array.from(signature),
      publicKey,
      weight: pair.weight
    };
  }
  return res;
}
function asIndices(bitmap) {
  if (bitmap < 0 || bitmap > 1024) {
    throw new Error("Invalid bitmap");
  }
  const res = [];
  for (let i = 0; i < 10; i++) {
    if ((bitmap & 1 << i) !== 0) {
      res.push(i);
    }
  }
  return Uint8Array.from(res);
}

// node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/dist/esm/verify/verify.js
async function verifyPersonalMessageSignature(message, signature, options = {}) {
  const parsedSignature = parseSignature(signature, options);
  if (!await parsedSignature.publicKey.verifyPersonalMessage(
    message,
    parsedSignature.serializedSignature
  )) {
    throw new Error(`Signature is not valid for the provided message`);
  }
  if ((options == null ? void 0 : options.address) && !parsedSignature.publicKey.verifyAddress(options.address)) {
    throw new Error(`Signature is not valid for the provided address`);
  }
  return parsedSignature.publicKey;
}
async function verifyTransactionSignature(transaction, signature, options = {}) {
  const parsedSignature = parseSignature(signature, options);
  if (!await parsedSignature.publicKey.verifyTransaction(
    transaction,
    parsedSignature.serializedSignature
  )) {
    throw new Error(`Signature is not valid for the provided Transaction`);
  }
  if ((options == null ? void 0 : options.address) && !parsedSignature.publicKey.verifyAddress(options.address)) {
    throw new Error(`Signature is not valid for the provided address`);
  }
  return parsedSignature.publicKey;
}
function parseSignature(signature, options = {}) {
  const parsedSignature = parseSerializedSignature(signature);
  if (parsedSignature.signatureScheme === "MultiSig") {
    return {
      ...parsedSignature,
      publicKey: new MultiSigPublicKey2(parsedSignature.multisig.multisig_pk)
    };
  }
  const publicKey = publicKeyFromRawBytes(
    parsedSignature.signatureScheme,
    parsedSignature.publicKey,
    options
  );
  return {
    ...parsedSignature,
    publicKey
  };
}
function publicKeyFromRawBytes(signatureScheme, bytes, options = {}) {
  switch (signatureScheme) {
    case "ED25519":
      return new Ed25519PublicKey(bytes);
    case "Secp256k1":
      return new Secp256k1PublicKey(bytes);
    case "Secp256r1":
      return new Secp256r1PublicKey(bytes);
    case "MultiSig":
      return new MultiSigPublicKey2(bytes);
    case "ZkLogin":
      return new ZkLoginPublicIdentifier(bytes, options);
    case "Passkey":
      return new PasskeyPublicKey(bytes);
    default:
      throw new Error(`Unsupported signature scheme ${signatureScheme}`);
  }
}

// node_modules/@suiet/wallet-kit/dist/index.js
var import_react_dom = __toESM(require_react_dom());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Zo = Object.defineProperty;
var Vo = (e, t, n) => t in e ? Zo(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var J = (e, t, n) => (Vo(e, typeof t != "symbol" ? t + "" : t, n), n);
var qo = class extends TypeError {
  constructor(t, n) {
    let r;
    const { message: o, explanation: s, ...l } = t, { path: c } = t, f = c.length === 0 ? o : `At path: ${c.join(".")} -- ${o}`;
    super(s ?? f), s != null && (this.cause = f), Object.assign(this, l), this.name = this.constructor.name, this.failures = () => r ?? (r = [t, ...n()]);
  }
};
function Xo(e) {
  return xe(e) && typeof e[Symbol.iterator] == "function";
}
function xe(e) {
  return typeof e == "object" && e != null;
}
function We(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Ho(e) {
  const { done: t, value: n } = e.next();
  return t ? void 0 : n;
}
function Ko(e, t, n, r) {
  if (e === true)
    return;
  e === false ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: o, branch: s } = t, { type: l } = n, { refinement: c, message: f = `Expected a value of type \`${l}\`${c ? ` with refinement \`${c}\`` : ""}, but received: \`${We(r)}\`` } = e;
  return {
    value: r,
    type: l,
    refinement: c,
    key: o[o.length - 1],
    path: o,
    branch: s,
    ...e,
    message: f
  };
}
function* Hr(e, t, n, r) {
  Xo(e) || (e = [e]);
  for (const o of e) {
    const s = Ko(o, t, n, r);
    s && (yield s);
  }
}
function* zr(e, t, n = {}) {
  const { path: r = [], branch: o = [e], coerce: s = false, mask: l = false } = n, c = { path: r, branch: o };
  if (s && (e = t.coercer(e, c), l && t.type !== "type" && xe(t.schema) && xe(e) && !Array.isArray(e)))
    for (const h in e)
      t.schema[h] === void 0 && delete e[h];
  let f = "valid";
  for (const h of t.validator(e, c))
    h.explanation = n.message, f = "not_valid", yield [h, void 0];
  for (let [h, M, y] of t.entries(e, c)) {
    const A = zr(M, y, {
      path: h === void 0 ? r : [...r, h],
      branch: h === void 0 ? o : [...o, M],
      coerce: s,
      mask: l,
      message: n.message
    });
    for (const N of A)
      N[0] ? (f = N[0].refinement != null ? "not_refined" : "not_valid", yield [N[0], void 0]) : s && (M = N[1], h === void 0 ? e = M : e instanceof Map ? e.set(h, M) : e instanceof Set ? e.add(M) : xe(e) && (M !== void 0 || h in e) && (e[h] = M));
  }
  if (f !== "not_valid")
    for (const h of t.refiner(e, c))
      h.explanation = n.message, f = "not_refined", yield [h, void 0];
  f === "valid" && (yield [void 0, e]);
}
var Ze = class {
  constructor(t) {
    const { type: n, schema: r, validator: o, refiner: s, coercer: l = (f) => f, entries: c = function* () {
    } } = t;
    this.type = n, this.schema = r, this.entries = c, this.coercer = l, o ? this.validator = (f, h) => {
      const M = o(f, h);
      return Hr(M, h, this, f);
    } : this.validator = () => [], s ? this.refiner = (f, h) => {
      const M = s(f, h);
      return Hr(M, h, this, f);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t, n) {
    return Jo(t, this, n);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t, n) {
    return $o(t, this, n);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return ts(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t, n) {
    return es(t, this, n);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, n = {}) {
    return qt(t, this, n);
  }
};
function Jo(e, t, n) {
  const r = qt(e, t, { message: n });
  if (r[0])
    throw r[0];
}
function $o(e, t, n) {
  const r = qt(e, t, { coerce: true, message: n });
  if (r[0])
    throw r[0];
  return r[1];
}
function es(e, t, n) {
  const r = qt(e, t, { coerce: true, mask: true, message: n });
  if (r[0])
    throw r[0];
  return r[1];
}
function ts(e, t) {
  return !qt(e, t)[0];
}
function qt(e, t, n = {}) {
  const r = zr(e, t, n), o = Ho(r);
  return o[0] ? [new qo(o[0], function* () {
    for (const s of r)
      s[0] && (yield s[0]);
  }), void 0] : [void 0, o[1]];
}
function _t(...e) {
  const t = e[0].type === "type", n = e.map((o) => o.schema), r = Object.assign({}, ...n);
  return t ? os(r) : R(r);
}
function st(e, t) {
  return new Ze({ type: e, schema: null, validator: t });
}
function ns() {
  return st("any", () => true);
}
function Rr(e) {
  return new Ze({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, r] of t.entries())
          yield [n, r, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array value, but received: ${We(t)}`;
    }
  });
}
function rs() {
  return st("bigint", (e) => typeof e == "bigint");
}
function ke() {
  return st("boolean", (e) => typeof e == "boolean");
}
function me(e) {
  const t = We(e), n = typeof e;
  return new Ze({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(r) {
      return r === e || `Expected the literal \`${t}\`, but received: ${We(r)}`;
    }
  });
}
function ji() {
  return st("never", () => false);
}
function H(e) {
  return new Ze({
    ...e,
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n)
  });
}
function Pt() {
  return st("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${We(e)}`);
}
function R(e) {
  const t = e ? Object.keys(e) : [], n = ji();
  return new Ze({
    type: "object",
    schema: e || null,
    *entries(r) {
      if (e && xe(r)) {
        const o = new Set(Object.keys(r));
        for (const s of t)
          o.delete(s), yield [s, r[s], e[s]];
        for (const s of o)
          yield [s, r[s], n];
      }
    },
    validator(r) {
      return xe(r) || `Expected an object, but received: ${We(r)}`;
    },
    coercer(r) {
      return xe(r) ? { ...r } : r;
    }
  });
}
function B(e) {
  return new Ze({
    ...e,
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n)
  });
}
function gt(e, t) {
  return new Ze({
    type: "record",
    schema: null,
    *entries(n) {
      if (xe(n))
        for (const r in n) {
          const o = n[r];
          yield [r, r, e], yield [r, o, t];
        }
    },
    validator(n) {
      return xe(n) || `Expected an object, but received: ${We(n)}`;
    }
  });
}
function j() {
  return st("string", (e) => typeof e == "string" || `Expected a string, but received: ${We(e)}`);
}
function is2(e) {
  const t = ji();
  return new Ze({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r = Math.max(e.length, n.length);
        for (let o = 0; o < r; o++)
          yield [o, n[o], e[o] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${We(n)}`;
    }
  });
}
function os(e) {
  const t = Object.keys(e);
  return new Ze({
    type: "type",
    schema: e,
    *entries(n) {
      if (xe(n))
        for (const r of t)
          yield [r, n[r], e[r]];
    },
    validator(n) {
      return xe(n) || `Expected an object, but received: ${We(n)}`;
    },
    coercer(n) {
      return xe(n) ? { ...n } : n;
    }
  });
}
function He(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new Ze({
    type: "union",
    schema: null,
    coercer(n) {
      for (const r of e) {
        const [o, s] = r.validate(n, { coerce: true });
        if (!o)
          return s;
      }
      return n;
    },
    validator(n, r) {
      const o = [];
      for (const s of e) {
        const [...l] = zr(n, s, r), [c] = l;
        if (c[0])
          for (const [f] of l)
            f && o.push(f);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${We(n)}`,
        ...o
      ];
    }
  });
}
function ss() {
  return st("unknown", () => true);
}
var Ur = He([
  R({
    AddressOwner: j()
  }),
  R({
    ObjectOwner: j()
  }),
  R({
    Shared: R({
      initial_shared_version: H(j())
    })
  }),
  me("Immutable")
]);
st("SuiJsonValue", () => true);
var as = He([
  R({ u32: j() }),
  R({ u64: j() }),
  R({ f64: j() })
]);
R({
  attributes: gt(j(), H(as)),
  featureFlags: gt(j(), ke()),
  maxSupportedProtocolVersion: j(),
  minSupportedProtocolVersion: j(),
  protocolVersion: j()
});
He([j(), me("package")]);
var _n = R({
  /** Base64 string representing the object digest */
  digest: j(),
  /** Hex code as string representing the object id */
  objectId: j(),
  /** Object version */
  version: He([Pt(), j(), rs()])
});
R({
  owner: Ur,
  reference: _n
});
R({
  objectId: j(),
  sequenceNumber: j()
});
R({
  payment: Rr(_n),
  /** Gas Object's owner */
  owner: j(),
  price: j(),
  budget: j()
});
var cs = _t(
  _n,
  R({
    type: j(),
    owner: Ur,
    previousTransaction: j()
  })
);
var us = gt(j(), ns());
var ls = gt(j(), ss());
var fs = R({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: j(),
  /** Fields and values stored inside the Move object */
  fields: us,
  hasPublicTransfer: ke()
});
var ds = R({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: ls
});
var hs = He([
  _t(fs, R({ dataType: me("moveObject") })),
  _t(ds, R({ dataType: me("package") }))
]);
var gs = R({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: j(),
  hasPublicTransfer: ke(),
  version: j(),
  bcsBytes: j()
});
var Ms = R({
  id: j(),
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: gt(j(), j())
});
var ys = He([
  _t(gs, R({ dataType: me("moveObject") })),
  _t(Ms, R({ dataType: me("package") }))
]);
BigInt(1e9);
var Li = R({
  code: j(),
  error: B(j()),
  object_id: B(j()),
  parent_object_id: B(j()),
  version: B(j()),
  digest: B(j())
});
var ps = R({
  data: H(B(gt(j(), j()))),
  error: H(B(Li))
});
var Ns = He([
  ps,
  B(gt(j(), j()))
]);
var Si = R({
  objectId: j(),
  version: j(),
  digest: j(),
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: H(B(j())),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: H(B(hs)),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: H(B(ys)),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: H(B(Ur)),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: H(B(j())),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: H(B(j())),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: H(B(Ns))
});
R({
  /* Whether to fetch the object type, default to be true */
  showType: H(B(ke())),
  /* Whether to fetch the object content, default to be false */
  showContent: H(B(ke())),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: H(B(ke())),
  /* Whether to fetch the object owner, default to be false */
  showOwner: H(B(ke())),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: H(B(ke())),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: H(B(ke())),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: H(B(ke()))
});
He([
  me("Exists"),
  me("notExists"),
  me("Deleted")
]);
Rr(cs);
var As = R({
  data: H(B(Si)),
  error: H(B(Li))
});
function Ci(e) {
  return e.data;
}
function Is(e) {
  if (e.error && "object_id" in e.error && "version" in e.error && "digest" in e.error) {
    const t = e.error;
    return {
      objectId: t.object_id,
      version: t.version,
      digest: t.digest
    };
  }
}
function vs(e) {
  if (e.error && "object_id" in e.error && !("version" in e.error) && !("digest" in e.error))
    return e.error.object_id;
}
function ms(e) {
  if ("reference" in e)
    return e.reference;
  const t = Ci(e);
  return t ? {
    objectId: t.objectId,
    version: t.version,
    digest: t.digest
  } : Is(e);
}
function Ds(e) {
  var _a2;
  return "objectId" in e ? e.objectId : ((_a2 = ms(e)) == null ? void 0 : _a2.objectId) ?? vs(e);
}
function ws(e) {
  return e.data !== void 0;
}
function Es(e) {
  var _a2;
  const t = ws(e) ? e.data : e;
  return !(t == null ? void 0 : t.type) && "data" in e ? ((_a2 = t == null ? void 0 : t.content) == null ? void 0 : _a2.dataType) === "package" ? "package" : bs(e) : t == null ? void 0 : t.type;
}
function bs(e) {
  var _a2;
  return (_a2 = Oi(e)) == null ? void 0 : _a2.type;
}
function Ts(e) {
  var _a2;
  return "fields" in e ? e.fields : (_a2 = Oi(e)) == null ? void 0 : _a2.fields;
}
function js(e) {
  return e.content !== void 0;
}
function Oi(e) {
  const t = "data" in e ? Ci(e) : e;
  if (!(!t || !js(t) || t.content.dataType !== "moveObject"))
    return t.content;
}
R({
  objectId: j(),
  atCheckpoint: B(Pt())
});
R({
  data: Rr(As),
  nextCursor: B(H(j())),
  hasNextPage: ke()
});
He([
  R({
    details: Si,
    status: me("VersionFound")
  }),
  R({
    details: j(),
    status: me("ObjectNotExists")
  }),
  R({
    details: _n,
    status: me("ObjectDeleted")
  }),
  R({
    details: is2([j(), Pt()]),
    status: me("VersionNotFound")
  }),
  R({
    details: R({
      asked_version: Pt(),
      latest_version: Pt(),
      object_id: j()
    }),
    status: me("VersionTooHigh")
  })
]);
var Ls = 32;
function Ss(e, t = false) {
  let n = e.toLowerCase();
  return !t && n.startsWith("0x") && (n = n.slice(2)), `0x${n.padStart(Ls * 2, "0")}`;
}
function Cs(e, t = false) {
  return Ss(e, t);
}
var Kr = /^0x2::coin::Coin<(.+)>$/;
function Os(e) {
  return !!e.data || !!e.type;
}
var we = class _we {
  static isCoin(t) {
    var _a2;
    return ((_a2 = _we.getType(t)) == null ? void 0 : _a2.match(Kr)) != null;
  }
  static getCoinType(t) {
    const [, n] = t.match(Kr) ?? [];
    return n || null;
  }
  static getCoinTypeArg(t) {
    const n = _we.getType(t);
    return n ? _we.getCoinType(n) : null;
  }
  static isSUI(t) {
    const n = _we.getCoinTypeArg(t);
    return n ? _we.getCoinSymbol(n) === "SUI" : false;
  }
  static getCoinSymbol(t) {
    return t.substring(t.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(t) {
    return {
      address: Cs(t.split("::")[0]),
      module: t.split("::")[1],
      name: t.split("::")[2],
      typeParams: []
    };
  }
  static getID(t) {
    return "fields" in t ? t.fields.id.id : Ds(t);
  }
  static totalBalance(t) {
    return t.reduce(
      (n, r) => n + _we.getBalanceFromCoinStruct(r),
      BigInt(0)
    );
  }
  /**
   * Sort coin by balance in an ascending order
   */
  static sortByBalance(t) {
    return [...t].sort(
      (n, r) => _we.getBalanceFromCoinStruct(n) < _we.getBalanceFromCoinStruct(r) ? -1 : _we.getBalanceFromCoinStruct(n) > _we.getBalanceFromCoinStruct(r) ? 1 : 0
    );
  }
  static getBalanceFromCoinStruct(t) {
    return BigInt(t.balance);
  }
  static getBalance(t) {
    var _a2;
    if (!_we.isCoin(t))
      return;
    const n = (_a2 = Ts(t)) == null ? void 0 : _a2.balance;
    return BigInt(n);
  }
  static getType(t) {
    return Os(t) ? Es(t) : t.type;
  }
};
var kr = class _kr {
  constructor(t, n, r) {
    J(this, "_objectId"), J(this, "_typeArg"), J(this, "_balance"), J(this, "_symbol"), this._objectId = t, this._balance = r, this._typeArg = n, this._symbol = we.getCoinSymbol(n);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(t) {
    return new _kr(t.objectId, t.typeArg, t.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
};
var Ue = ((e) => (e.DISCONNECTED = "disconnected", e.CONNECTED = "connected", e.CONNECTING = "connecting", e))(Ue || {});
var xs = class {
  constructor(t) {
    J(this, "client"), this.client = t;
  }
  async getOwnedObjects(t) {
    var _a2;
    let n = true, r = null, o = [];
    for (; n; ) {
      const s = await this.client.getOwnedObjects({
        owner: t,
        cursor: r,
        options: {
          showType: true,
          showDisplay: true,
          showContent: true,
          showOwner: true
        }
      });
      (_a2 = s.data) == null ? void 0 : _a2.forEach((l) => {
        const c = l.data;
        c && o.push(c);
      }), n = s.hasNextPage, r = s.nextCursor;
    }
    return o;
  }
  getSuiClient() {
    return this.client;
  }
  setSuiClient(t) {
    this.client = t;
  }
};
var zs = class extends xs {
  constructor(t, n) {
    super(t), J(this, "coinType"), this.coinType = n;
  }
  /**
   * Get the coin object of one specific token type
   */
  async getOwnedCoins(t) {
    let n = true, r = null, o = [];
    for (; n; ) {
      const s = await this.client.getCoins({
        owner: t,
        coinType: this.coinType,
        cursor: r
      });
      s.data.forEach((l) => {
        o.push(
          new kr(l.coinObjectId, l.coinType, BigInt(l.balance))
        );
      }), n = s.hasNextPage, r = s.nextCursor;
    }
    return o;
  }
  async getBalance(t) {
    const n = await this.client.getBalance({
      owner: t,
      coinType: this.coinType
    });
    return BigInt(n.totalBalance);
  }
};
var Rs = class {
  constructor(t, n) {
    J(this, "address"), J(this, "chainRpcUrl"), J(this, "suiClient"), this.address = t, this.chainRpcUrl = n.chainRpcUrl, this.suiClient = new SuiClient({
      url: n.chainRpcUrl
    });
  }
  getAddress() {
    return this.address;
  }
  getCoinBalance(t) {
    return new zs(this.suiClient, t).getBalance(this.address);
  }
  getSuiBalance() {
    return this.getCoinBalance(SUI_TYPE_ARG);
  }
  getChainRpcUrl() {
    return this.chainRpcUrl;
  }
  setChainRpcUrl(t) {
    this.chainRpcUrl = t, this.suiClient = new SuiClient({
      url: t
    });
  }
};
var Jr = 1e6;
var Jn = 1e9;
var $n = 1e12;
function Us(e, t) {
  return xi(
    e,
    Object.assign(
      {
        decimals: 9
      },
      t
    )
  );
}
function xi(e, t) {
  const { decimals: n = 0, withAbbr: r = true } = t ?? {};
  if (typeof e == "bigint" && !Qs(e))
    return Ri(BigInt(e), {
      decimals: n,
      withAbbr: r
    });
  if (Number(e) === 0)
    return "0";
  if (Number(e) < 0)
    return "-" + xi(-Number(e), t);
  const o = Number(e) / 10 ** n;
  return o > 0 && o < 1 ? ks(o) : zi(o, r);
}
function zi(e, t) {
  if (t) {
    if (e >= Jr && e < Jn)
      return er(e, Jr, "M");
    if (e >= Jn && e < $n)
      return er(e, Jn, "B");
    if (e >= $n)
      return er(e, $n, "T");
  }
  return Intl.NumberFormat("en-US").format(e);
}
function er(e, t, n) {
  let r;
  typeof e == "bigint" ? r = String(e / (BigInt(t) / 1000n)) : r = String(Math.floor(e / (t / 1e3)));
  const o = r.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(o)).replace(",", ".") + n;
}
function ks(e) {
  if (e <= 0)
    return "0";
  const t = Math.ceil(-Math.log10(e));
  return Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) === 0 ? tr(e, t) : Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) !== 0 ? tr(e, t + 1) : tr(e, t + 2);
}
function tr(e, t) {
  function n(r) {
    if (isNaN(r))
      return r.toString();
    const o = "" + r;
    return /e/i.test(o) ? r.toFixed(18).replace(/\.?0+$/, "") : r.toString();
  }
  return t = t || 0, t = Math.pow(10, t), n(Math.floor(e * t) / t);
}
function Ri(e, t) {
  if (e === 0n)
    return "0";
  if (e < 0n)
    return "-" + Ri(-e, t);
  const { decimals: n = 9, withAbbr: r = true } = t ?? {}, o = e / 10n ** BigInt(n);
  return zi(o, r);
}
function Qs(e) {
  const t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER;
  return e >= BigInt(t) && e <= BigInt(n);
}
function Ps(e) {
  return typeof e != "string" ? "" : !e || !e.startsWith("0x") ? e : e.slice(0, 7) + "...." + e.slice(-4, e.length);
}
function xn(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var sn = {};
var Gn = {};
Gn.byteLength = Ys;
Gn.toByteArray = _s;
Gn.fromByteArray = Vs;
var _e = [];
var Ce = [];
var Ws = typeof Uint8Array < "u" ? Uint8Array : Array;
var nr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (At = 0, Bs = nr.length; At < Bs; ++At)
  _e[At] = nr[At], Ce[nr.charCodeAt(At)] = At;
var At;
var Bs;
Ce[45] = 62;
Ce[95] = 63;
function Ui(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function Ys(e) {
  var t = Ui(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function Fs(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function _s(e) {
  var t, n = Ui(e), r = n[0], o = n[1], s = new Ws(Fs(e, r, o)), l = 0, c = o > 0 ? r - 4 : r, f;
  for (f = 0; f < c; f += 4)
    t = Ce[e.charCodeAt(f)] << 18 | Ce[e.charCodeAt(f + 1)] << 12 | Ce[e.charCodeAt(f + 2)] << 6 | Ce[e.charCodeAt(f + 3)], s[l++] = t >> 16 & 255, s[l++] = t >> 8 & 255, s[l++] = t & 255;
  return o === 2 && (t = Ce[e.charCodeAt(f)] << 2 | Ce[e.charCodeAt(f + 1)] >> 4, s[l++] = t & 255), o === 1 && (t = Ce[e.charCodeAt(f)] << 10 | Ce[e.charCodeAt(f + 1)] << 4 | Ce[e.charCodeAt(f + 2)] >> 2, s[l++] = t >> 8 & 255, s[l++] = t & 255), s;
}
function Gs(e) {
  return _e[e >> 18 & 63] + _e[e >> 12 & 63] + _e[e >> 6 & 63] + _e[e & 63];
}
function Zs(e, t, n) {
  for (var r, o = [], s = t; s < n; s += 3)
    r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), o.push(Gs(r));
  return o.join("");
}
function Vs(e) {
  for (var t, n = e.length, r = n % 3, o = [], s = 16383, l = 0, c = n - r; l < c; l += s)
    o.push(Zs(e, l, l + s > c ? c : l + s));
  return r === 1 ? (t = e[n - 1], o.push(
    _e[t >> 2] + _e[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], o.push(
    _e[t >> 10] + _e[t >> 4 & 63] + _e[t << 2 & 63] + "="
  )), o.join("");
}
var Qr = {};
Qr.read = function(e, t, n, r, o) {
  var s, l, c = o * 8 - r - 1, f = (1 << c) - 1, h = f >> 1, M = -7, y = n ? o - 1 : 0, A = n ? -1 : 1, N = e[t + y];
  for (y += A, s = N & (1 << -M) - 1, N >>= -M, M += c; M > 0; s = s * 256 + e[t + y], y += A, M -= 8)
    ;
  for (l = s & (1 << -M) - 1, s >>= -M, M += r; M > 0; l = l * 256 + e[t + y], y += A, M -= 8)
    ;
  if (s === 0)
    s = 1 - h;
  else {
    if (s === f)
      return l ? NaN : (N ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, r), s = s - h;
  }
  return (N ? -1 : 1) * l * Math.pow(2, s - r);
};
Qr.write = function(e, t, n, r, o, s) {
  var l, c, f, h = s * 8 - o - 1, M = (1 << h) - 1, y = M >> 1, A = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = r ? 0 : s - 1, m = r ? 1 : -1, I = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, l = M) : (l = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -l)) < 1 && (l--, f *= 2), l + y >= 1 ? t += A / f : t += A * Math.pow(2, 1 - y), t * f >= 2 && (l++, f /= 2), l + y >= M ? (c = 0, l = M) : l + y >= 1 ? (c = (t * f - 1) * Math.pow(2, o), l = l + y) : (c = t * Math.pow(2, y - 1) * Math.pow(2, o), l = 0)); o >= 8; e[n + N] = c & 255, N += m, c /= 256, o -= 8)
    ;
  for (l = l << o | c, h += o; h > 0; e[n + N] = l & 255, N += m, l /= 256, h -= 8)
    ;
  e[n + N - m] |= I * 128;
};
(function(e) {
  const t = Gn, n = Qr, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = c, e.SlowBuffer = C, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, c.TYPED_ARRAY_SUPPORT = s(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const i = new Uint8Array(1), a = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(a, Uint8Array.prototype), Object.setPrototypeOf(i, a), i.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(c.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (c.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(c.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (c.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(i) {
    if (i > o)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    const a = new Uint8Array(i);
    return Object.setPrototypeOf(a, c.prototype), a;
  }
  function c(i, a, u) {
    if (typeof i == "number") {
      if (typeof a == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(i);
    }
    return f(i, a, u);
  }
  c.poolSize = 8192;
  function f(i, a, u) {
    if (typeof i == "string")
      return A(i, a);
    if (ArrayBuffer.isView(i))
      return m(i);
    if (i == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
      );
    if (Ye(i, ArrayBuffer) || i && Ye(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ye(i, SharedArrayBuffer) || i && Ye(i.buffer, SharedArrayBuffer)))
      return I(i, a, u);
    if (typeof i == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const d = i.valueOf && i.valueOf();
    if (d != null && d !== i)
      return c.from(d, a, u);
    const g = b(i);
    if (g)
      return g;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return c.from(i[Symbol.toPrimitive]("string"), a, u);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i
    );
  }
  c.from = function(i, a, u) {
    return f(i, a, u);
  }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array);
  function h(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function M(i, a, u) {
    return h(i), i <= 0 ? l(i) : a !== void 0 ? typeof u == "string" ? l(i).fill(a, u) : l(i).fill(a) : l(i);
  }
  c.alloc = function(i, a, u) {
    return M(i, a, u);
  };
  function y(i) {
    return h(i), l(i < 0 ? 0 : E(i) | 0);
  }
  c.allocUnsafe = function(i) {
    return y(i);
  }, c.allocUnsafeSlow = function(i) {
    return y(i);
  };
  function A(i, a) {
    if ((typeof a != "string" || a === "") && (a = "utf8"), !c.isEncoding(a))
      throw new TypeError("Unknown encoding: " + a);
    const u = T(i, a) | 0;
    let d = l(u);
    const g = d.write(i, a);
    return g !== u && (d = d.slice(0, g)), d;
  }
  function N(i) {
    const a = i.length < 0 ? 0 : E(i.length) | 0, u = l(a);
    for (let d = 0; d < a; d += 1)
      u[d] = i[d] & 255;
    return u;
  }
  function m(i) {
    if (Ye(i, Uint8Array)) {
      const a = new Uint8Array(i);
      return I(a.buffer, a.byteOffset, a.byteLength);
    }
    return N(i);
  }
  function I(i, a, u) {
    if (a < 0 || i.byteLength < a)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < a + (u || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let d;
    return a === void 0 && u === void 0 ? d = new Uint8Array(i) : u === void 0 ? d = new Uint8Array(i, a) : d = new Uint8Array(i, a, u), Object.setPrototypeOf(d, c.prototype), d;
  }
  function b(i) {
    if (c.isBuffer(i)) {
      const a = E(i.length) | 0, u = l(a);
      return u.length === 0 || i.copy(u, 0, 0, a), u;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || Kn(i.length) ? l(0) : N(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return N(i.data);
  }
  function E(i) {
    if (i >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return i | 0;
  }
  function C(i) {
    return +i != i && (i = 0), c.alloc(+i);
  }
  c.isBuffer = function(i) {
    return i != null && i._isBuffer === true && i !== c.prototype;
  }, c.compare = function(i, a) {
    if (Ye(i, Uint8Array) && (i = c.from(i, i.offset, i.byteLength)), Ye(a, Uint8Array) && (a = c.from(a, a.offset, a.byteLength)), !c.isBuffer(i) || !c.isBuffer(a))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i === a)
      return 0;
    let u = i.length, d = a.length;
    for (let g = 0, p = Math.min(u, d); g < p; ++g)
      if (i[g] !== a[g]) {
        u = i[g], d = a[g];
        break;
      }
    return u < d ? -1 : d < u ? 1 : 0;
  }, c.isEncoding = function(i) {
    switch (String(i).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, c.concat = function(i, a) {
    if (!Array.isArray(i))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i.length === 0)
      return c.alloc(0);
    let u;
    if (a === void 0)
      for (a = 0, u = 0; u < i.length; ++u)
        a += i[u].length;
    const d = c.allocUnsafe(a);
    let g = 0;
    for (u = 0; u < i.length; ++u) {
      let p = i[u];
      if (Ye(p, Uint8Array))
        g + p.length > d.length ? (c.isBuffer(p) || (p = c.from(p)), p.copy(d, g)) : Uint8Array.prototype.set.call(
          d,
          p,
          g
        );
      else if (c.isBuffer(p))
        p.copy(d, g);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      g += p.length;
    }
    return d;
  };
  function T(i, a) {
    if (c.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || Ye(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i
      );
    const u = i.length, d = arguments.length > 2 && arguments[2] === true;
    if (!d && u === 0)
      return 0;
    let g = false;
    for (; ; )
      switch (a) {
        case "ascii":
        case "latin1":
        case "binary":
          return u;
        case "utf8":
        case "utf-8":
          return Hn(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return u * 2;
        case "hex":
          return u >>> 1;
        case "base64":
          return Xr(i).length;
        default:
          if (g)
            return d ? -1 : Hn(i).length;
          a = ("" + a).toLowerCase(), g = true;
      }
  }
  c.byteLength = T;
  function z(i, a, u) {
    let d = false;
    if ((a === void 0 || a < 0) && (a = 0), a > this.length || ((u === void 0 || u > this.length) && (u = this.length), u <= 0) || (u >>>= 0, a >>>= 0, u <= a))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return ue(this, a, u);
        case "utf8":
        case "utf-8":
          return De(this, a, u);
        case "ascii":
          return qe(this, a, u);
        case "latin1":
        case "binary":
          return Le(this, a, u);
        case "base64":
          return je(this, a, u);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ke(this, a, u);
        default:
          if (d)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), d = true;
      }
  }
  c.prototype._isBuffer = true;
  function L(i, a, u) {
    const d = i[a];
    i[a] = i[u], i[u] = d;
  }
  c.prototype.swap16 = function() {
    const i = this.length;
    if (i % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let a = 0; a < i; a += 2)
      L(this, a, a + 1);
    return this;
  }, c.prototype.swap32 = function() {
    const i = this.length;
    if (i % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let a = 0; a < i; a += 4)
      L(this, a, a + 3), L(this, a + 1, a + 2);
    return this;
  }, c.prototype.swap64 = function() {
    const i = this.length;
    if (i % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let a = 0; a < i; a += 8)
      L(this, a, a + 7), L(this, a + 1, a + 6), L(this, a + 2, a + 5), L(this, a + 3, a + 4);
    return this;
  }, c.prototype.toString = function() {
    const i = this.length;
    return i === 0 ? "" : arguments.length === 0 ? De(this, 0, i) : z.apply(this, arguments);
  }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(i) {
    if (!c.isBuffer(i))
      throw new TypeError("Argument must be a Buffer");
    return this === i ? true : c.compare(this, i) === 0;
  }, c.prototype.inspect = function() {
    let i = "";
    const a = e.INSPECT_MAX_BYTES;
    return i = this.toString("hex", 0, a).replace(/(.{2})/g, "$1 ").trim(), this.length > a && (i += " ... "), "<Buffer " + i + ">";
  }, r && (c.prototype[r] = c.prototype.inspect), c.prototype.compare = function(i, a, u, d, g) {
    if (Ye(i, Uint8Array) && (i = c.from(i, i.offset, i.byteLength)), !c.isBuffer(i))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i
      );
    if (a === void 0 && (a = 0), u === void 0 && (u = i ? i.length : 0), d === void 0 && (d = 0), g === void 0 && (g = this.length), a < 0 || u > i.length || d < 0 || g > this.length)
      throw new RangeError("out of range index");
    if (d >= g && a >= u)
      return 0;
    if (d >= g)
      return -1;
    if (a >= u)
      return 1;
    if (a >>>= 0, u >>>= 0, d >>>= 0, g >>>= 0, this === i)
      return 0;
    let p = g - d, v = u - a;
    const Y = Math.min(p, v), ce = this.slice(d, g), Z = i.slice(a, u);
    for (let W = 0; W < Y; ++W)
      if (ce[W] !== Z[W]) {
        p = ce[W], v = Z[W];
        break;
      }
    return p < v ? -1 : v < p ? 1 : 0;
  };
  function U(i, a, u, d, g) {
    if (i.length === 0)
      return -1;
    if (typeof u == "string" ? (d = u, u = 0) : u > 2147483647 ? u = 2147483647 : u < -2147483648 && (u = -2147483648), u = +u, Kn(u) && (u = g ? 0 : i.length - 1), u < 0 && (u = i.length + u), u >= i.length) {
      if (g)
        return -1;
      u = i.length - 1;
    } else if (u < 0)
      if (g)
        u = 0;
      else
        return -1;
    if (typeof a == "string" && (a = c.from(a, d)), c.isBuffer(a))
      return a.length === 0 ? -1 : $(i, a, u, d, g);
    if (typeof a == "number")
      return a = a & 255, typeof Uint8Array.prototype.indexOf == "function" ? g ? Uint8Array.prototype.indexOf.call(i, a, u) : Uint8Array.prototype.lastIndexOf.call(i, a, u) : $(i, [a], u, d, g);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(i, a, u, d, g) {
    let p = 1, v = i.length, Y = a.length;
    if (d !== void 0 && (d = String(d).toLowerCase(), d === "ucs2" || d === "ucs-2" || d === "utf16le" || d === "utf-16le")) {
      if (i.length < 2 || a.length < 2)
        return -1;
      p = 2, v /= 2, Y /= 2, u /= 2;
    }
    function ce(W, te) {
      return p === 1 ? W[te] : W.readUInt16BE(te * p);
    }
    let Z;
    if (g) {
      let W = -1;
      for (Z = u; Z < v; Z++)
        if (ce(i, Z) === ce(a, W === -1 ? 0 : Z - W)) {
          if (W === -1 && (W = Z), Z - W + 1 === Y)
            return W * p;
        } else
          W !== -1 && (Z -= Z - W), W = -1;
    } else
      for (u + Y > v && (u = v - Y), Z = u; Z >= 0; Z--) {
        let W = true;
        for (let te = 0; te < Y; te++)
          if (ce(i, Z + te) !== ce(a, te)) {
            W = false;
            break;
          }
        if (W)
          return Z;
      }
    return -1;
  }
  c.prototype.includes = function(i, a, u) {
    return this.indexOf(i, a, u) !== -1;
  }, c.prototype.indexOf = function(i, a, u) {
    return U(this, i, a, u, true);
  }, c.prototype.lastIndexOf = function(i, a, u) {
    return U(this, i, a, u, false);
  };
  function k(i, a, u, d) {
    u = Number(u) || 0;
    const g = i.length - u;
    d ? (d = Number(d), d > g && (d = g)) : d = g;
    const p = a.length;
    d > p / 2 && (d = p / 2);
    let v;
    for (v = 0; v < d; ++v) {
      const Y = parseInt(a.substr(v * 2, 2), 16);
      if (Kn(Y))
        return v;
      i[u + v] = Y;
    }
    return v;
  }
  function ie(i, a, u, d) {
    return Jt(Hn(a, i.length - u), i, u, d);
  }
  function oe(i, a, u, d) {
    return Jt(Ro(a), i, u, d);
  }
  function Te(i, a, u, d) {
    return Jt(Xr(a), i, u, d);
  }
  function ze(i, a, u, d) {
    return Jt(Uo(a, i.length - u), i, u, d);
  }
  c.prototype.write = function(i, a, u, d) {
    if (a === void 0)
      d = "utf8", u = this.length, a = 0;
    else if (u === void 0 && typeof a == "string")
      d = a, u = this.length, a = 0;
    else if (isFinite(a))
      a = a >>> 0, isFinite(u) ? (u = u >>> 0, d === void 0 && (d = "utf8")) : (d = u, u = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const g = this.length - a;
    if ((u === void 0 || u > g) && (u = g), i.length > 0 && (u < 0 || a < 0) || a > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let p = false;
    for (; ; )
      switch (d) {
        case "hex":
          return k(this, i, a, u);
        case "utf8":
        case "utf-8":
          return ie(this, i, a, u);
        case "ascii":
        case "latin1":
        case "binary":
          return oe(this, i, a, u);
        case "base64":
          return Te(this, i, a, u);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ze(this, i, a, u);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), p = true;
      }
  }, c.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function je(i, a, u) {
    return a === 0 && u === i.length ? t.fromByteArray(i) : t.fromByteArray(i.slice(a, u));
  }
  function De(i, a, u) {
    u = Math.min(i.length, u);
    const d = [];
    let g = a;
    for (; g < u; ) {
      const p = i[g];
      let v = null, Y = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
      if (g + Y <= u) {
        let ce, Z, W, te;
        switch (Y) {
          case 1:
            p < 128 && (v = p);
            break;
          case 2:
            ce = i[g + 1], (ce & 192) === 128 && (te = (p & 31) << 6 | ce & 63, te > 127 && (v = te));
            break;
          case 3:
            ce = i[g + 1], Z = i[g + 2], (ce & 192) === 128 && (Z & 192) === 128 && (te = (p & 15) << 12 | (ce & 63) << 6 | Z & 63, te > 2047 && (te < 55296 || te > 57343) && (v = te));
            break;
          case 4:
            ce = i[g + 1], Z = i[g + 2], W = i[g + 3], (ce & 192) === 128 && (Z & 192) === 128 && (W & 192) === 128 && (te = (p & 15) << 18 | (ce & 63) << 12 | (Z & 63) << 6 | W & 63, te > 65535 && te < 1114112 && (v = te));
        }
      }
      v === null ? (v = 65533, Y = 1) : v > 65535 && (v -= 65536, d.push(v >>> 10 & 1023 | 55296), v = 56320 | v & 1023), d.push(v), g += Y;
    }
    return Ie(d);
  }
  const Re = 4096;
  function Ie(i) {
    const a = i.length;
    if (a <= Re)
      return String.fromCharCode.apply(String, i);
    let u = "", d = 0;
    for (; d < a; )
      u += String.fromCharCode.apply(
        String,
        i.slice(d, d += Re)
      );
    return u;
  }
  function qe(i, a, u) {
    let d = "";
    u = Math.min(i.length, u);
    for (let g = a; g < u; ++g)
      d += String.fromCharCode(i[g] & 127);
    return d;
  }
  function Le(i, a, u) {
    let d = "";
    u = Math.min(i.length, u);
    for (let g = a; g < u; ++g)
      d += String.fromCharCode(i[g]);
    return d;
  }
  function ue(i, a, u) {
    const d = i.length;
    (!a || a < 0) && (a = 0), (!u || u < 0 || u > d) && (u = d);
    let g = "";
    for (let p = a; p < u; ++p)
      g += ko[i[p]];
    return g;
  }
  function Ke(i, a, u) {
    const d = i.slice(a, u);
    let g = "";
    for (let p = 0; p < d.length - 1; p += 2)
      g += String.fromCharCode(d[p] + d[p + 1] * 256);
    return g;
  }
  c.prototype.slice = function(i, a) {
    const u = this.length;
    i = ~~i, a = a === void 0 ? u : ~~a, i < 0 ? (i += u, i < 0 && (i = 0)) : i > u && (i = u), a < 0 ? (a += u, a < 0 && (a = 0)) : a > u && (a = u), a < i && (a = i);
    const d = this.subarray(i, a);
    return Object.setPrototypeOf(d, c.prototype), d;
  };
  function G(i, a, u) {
    if (i % 1 !== 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + a > u)
      throw new RangeError("Trying to access beyond buffer length");
  }
  c.prototype.readUintLE = c.prototype.readUIntLE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || G(i, a, this.length);
    let d = this[i], g = 1, p = 0;
    for (; ++p < a && (g *= 256); )
      d += this[i + p] * g;
    return d;
  }, c.prototype.readUintBE = c.prototype.readUIntBE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || G(i, a, this.length);
    let d = this[i + --a], g = 1;
    for (; a > 0 && (g *= 256); )
      d += this[i + --a] * g;
    return d;
  }, c.prototype.readUint8 = c.prototype.readUInt8 = function(i, a) {
    return i = i >>> 0, a || G(i, 1, this.length), this[i];
  }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(i, a) {
    return i = i >>> 0, a || G(i, 2, this.length), this[i] | this[i + 1] << 8;
  }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(i, a) {
    return i = i >>> 0, a || G(i, 2, this.length), this[i] << 8 | this[i + 1];
  }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), (this[i] | this[i + 1] << 8 | this[i + 2] << 16) + this[i + 3] * 16777216;
  }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), this[i] * 16777216 + (this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3]);
  }, c.prototype.readBigUInt64LE = $e(function(i) {
    i = i >>> 0, Nt(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && zt(i, this.length - 8);
    const d = a + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + this[++i] * 2 ** 24, g = this[++i] + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + u * 2 ** 24;
    return BigInt(d) + (BigInt(g) << BigInt(32));
  }), c.prototype.readBigUInt64BE = $e(function(i) {
    i = i >>> 0, Nt(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && zt(i, this.length - 8);
    const d = a * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + this[++i], g = this[++i] * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + u;
    return (BigInt(d) << BigInt(32)) + BigInt(g);
  }), c.prototype.readIntLE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || G(i, a, this.length);
    let d = this[i], g = 1, p = 0;
    for (; ++p < a && (g *= 256); )
      d += this[i + p] * g;
    return g *= 128, d >= g && (d -= Math.pow(2, 8 * a)), d;
  }, c.prototype.readIntBE = function(i, a, u) {
    i = i >>> 0, a = a >>> 0, u || G(i, a, this.length);
    let d = a, g = 1, p = this[i + --d];
    for (; d > 0 && (g *= 256); )
      p += this[i + --d] * g;
    return g *= 128, p >= g && (p -= Math.pow(2, 8 * a)), p;
  }, c.prototype.readInt8 = function(i, a) {
    return i = i >>> 0, a || G(i, 1, this.length), this[i] & 128 ? (255 - this[i] + 1) * -1 : this[i];
  }, c.prototype.readInt16LE = function(i, a) {
    i = i >>> 0, a || G(i, 2, this.length);
    const u = this[i] | this[i + 1] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, c.prototype.readInt16BE = function(i, a) {
    i = i >>> 0, a || G(i, 2, this.length);
    const u = this[i + 1] | this[i] << 8;
    return u & 32768 ? u | 4294901760 : u;
  }, c.prototype.readInt32LE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), this[i] | this[i + 1] << 8 | this[i + 2] << 16 | this[i + 3] << 24;
  }, c.prototype.readInt32BE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), this[i] << 24 | this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3];
  }, c.prototype.readBigInt64LE = $e(function(i) {
    i = i >>> 0, Nt(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && zt(i, this.length - 8);
    const d = this[i + 4] + this[i + 5] * 2 ** 8 + this[i + 6] * 2 ** 16 + (u << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(a + this[++i] * 2 ** 8 + this[++i] * 2 ** 16 + this[++i] * 2 ** 24);
  }), c.prototype.readBigInt64BE = $e(function(i) {
    i = i >>> 0, Nt(i, "offset");
    const a = this[i], u = this[i + 7];
    (a === void 0 || u === void 0) && zt(i, this.length - 8);
    const d = (a << 24) + // Overflow
    this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + this[++i];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++i] * 2 ** 24 + this[++i] * 2 ** 16 + this[++i] * 2 ** 8 + u);
  }), c.prototype.readFloatLE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), n.read(this, i, true, 23, 4);
  }, c.prototype.readFloatBE = function(i, a) {
    return i = i >>> 0, a || G(i, 4, this.length), n.read(this, i, false, 23, 4);
  }, c.prototype.readDoubleLE = function(i, a) {
    return i = i >>> 0, a || G(i, 8, this.length), n.read(this, i, true, 52, 8);
  }, c.prototype.readDoubleBE = function(i, a) {
    return i = i >>> 0, a || G(i, 8, this.length), n.read(this, i, false, 52, 8);
  };
  function w(i, a, u, d, g, p) {
    if (!c.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (a > g || a < p)
      throw new RangeError('"value" argument is out of bounds');
    if (u + d > i.length)
      throw new RangeError("Index out of range");
  }
  c.prototype.writeUintLE = c.prototype.writeUIntLE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, u = u >>> 0, !d) {
      const v = Math.pow(2, 8 * u) - 1;
      w(this, i, a, u, v, 0);
    }
    let g = 1, p = 0;
    for (this[a] = i & 255; ++p < u && (g *= 256); )
      this[a + p] = i / g & 255;
    return a + u;
  }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, u = u >>> 0, !d) {
      const v = Math.pow(2, 8 * u) - 1;
      w(this, i, a, u, v, 0);
    }
    let g = u - 1, p = 1;
    for (this[a + g] = i & 255; --g >= 0 && (p *= 256); )
      this[a + g] = i / p & 255;
    return a + u;
  }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 1, 255, 0), this[a] = i & 255, a + 1;
  }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 2, 65535, 0), this[a] = i & 255, this[a + 1] = i >>> 8, a + 2;
  }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 2, 65535, 0), this[a] = i >>> 8, this[a + 1] = i & 255, a + 2;
  }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 4, 4294967295, 0), this[a + 3] = i >>> 24, this[a + 2] = i >>> 16, this[a + 1] = i >>> 8, this[a] = i & 255, a + 4;
  }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 4, 4294967295, 0), this[a] = i >>> 24, this[a + 1] = i >>> 16, this[a + 2] = i >>> 8, this[a + 3] = i & 255, a + 4;
  };
  function x(i, a, u, d, g) {
    Je(a, d, g, i, u, 7);
    let p = Number(a & BigInt(4294967295));
    i[u++] = p, p = p >> 8, i[u++] = p, p = p >> 8, i[u++] = p, p = p >> 8, i[u++] = p;
    let v = Number(a >> BigInt(32) & BigInt(4294967295));
    return i[u++] = v, v = v >> 8, i[u++] = v, v = v >> 8, i[u++] = v, v = v >> 8, i[u++] = v, u;
  }
  function O(i, a, u, d, g) {
    Je(a, d, g, i, u, 7);
    let p = Number(a & BigInt(4294967295));
    i[u + 7] = p, p = p >> 8, i[u + 6] = p, p = p >> 8, i[u + 5] = p, p = p >> 8, i[u + 4] = p;
    let v = Number(a >> BigInt(32) & BigInt(4294967295));
    return i[u + 3] = v, v = v >> 8, i[u + 2] = v, v = v >> 8, i[u + 1] = v, v = v >> 8, i[u] = v, u + 8;
  }
  c.prototype.writeBigUInt64LE = $e(function(i, a = 0) {
    return x(this, i, a, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeBigUInt64BE = $e(function(i, a = 0) {
    return O(this, i, a, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeIntLE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, !d) {
      const Y = Math.pow(2, 8 * u - 1);
      w(this, i, a, u, Y - 1, -Y);
    }
    let g = 0, p = 1, v = 0;
    for (this[a] = i & 255; ++g < u && (p *= 256); )
      i < 0 && v === 0 && this[a + g - 1] !== 0 && (v = 1), this[a + g] = (i / p >> 0) - v & 255;
    return a + u;
  }, c.prototype.writeIntBE = function(i, a, u, d) {
    if (i = +i, a = a >>> 0, !d) {
      const Y = Math.pow(2, 8 * u - 1);
      w(this, i, a, u, Y - 1, -Y);
    }
    let g = u - 1, p = 1, v = 0;
    for (this[a + g] = i & 255; --g >= 0 && (p *= 256); )
      i < 0 && v === 0 && this[a + g + 1] !== 0 && (v = 1), this[a + g] = (i / p >> 0) - v & 255;
    return a + u;
  }, c.prototype.writeInt8 = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 1, 127, -128), i < 0 && (i = 255 + i + 1), this[a] = i & 255, a + 1;
  }, c.prototype.writeInt16LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 2, 32767, -32768), this[a] = i & 255, this[a + 1] = i >>> 8, a + 2;
  }, c.prototype.writeInt16BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 2, 32767, -32768), this[a] = i >>> 8, this[a + 1] = i & 255, a + 2;
  }, c.prototype.writeInt32LE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 4, 2147483647, -2147483648), this[a] = i & 255, this[a + 1] = i >>> 8, this[a + 2] = i >>> 16, this[a + 3] = i >>> 24, a + 4;
  }, c.prototype.writeInt32BE = function(i, a, u) {
    return i = +i, a = a >>> 0, u || w(this, i, a, 4, 2147483647, -2147483648), i < 0 && (i = 4294967295 + i + 1), this[a] = i >>> 24, this[a + 1] = i >>> 16, this[a + 2] = i >>> 8, this[a + 3] = i & 255, a + 4;
  }, c.prototype.writeBigInt64LE = $e(function(i, a = 0) {
    return x(this, i, a, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), c.prototype.writeBigInt64BE = $e(function(i, a = 0) {
    return O(this, i, a, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ee(i, a, u, d, g, p) {
    if (u + d > i.length)
      throw new RangeError("Index out of range");
    if (u < 0)
      throw new RangeError("Index out of range");
  }
  function ae(i, a, u, d, g) {
    return a = +a, u = u >>> 0, g || ee(i, a, u, 4), n.write(i, a, u, d, 23, 4), u + 4;
  }
  c.prototype.writeFloatLE = function(i, a, u) {
    return ae(this, i, a, true, u);
  }, c.prototype.writeFloatBE = function(i, a, u) {
    return ae(this, i, a, false, u);
  };
  function ge(i, a, u, d, g) {
    return a = +a, u = u >>> 0, g || ee(i, a, u, 8), n.write(i, a, u, d, 52, 8), u + 8;
  }
  c.prototype.writeDoubleLE = function(i, a, u) {
    return ge(this, i, a, true, u);
  }, c.prototype.writeDoubleBE = function(i, a, u) {
    return ge(this, i, a, false, u);
  }, c.prototype.copy = function(i, a, u, d) {
    if (!c.isBuffer(i))
      throw new TypeError("argument should be a Buffer");
    if (u || (u = 0), !d && d !== 0 && (d = this.length), a >= i.length && (a = i.length), a || (a = 0), d > 0 && d < u && (d = u), d === u || i.length === 0 || this.length === 0)
      return 0;
    if (a < 0)
      throw new RangeError("targetStart out of bounds");
    if (u < 0 || u >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), i.length - a < d - u && (d = i.length - a + u);
    const g = d - u;
    return this === i && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(a, u, d) : Uint8Array.prototype.set.call(
      i,
      this.subarray(u, d),
      a
    ), g;
  }, c.prototype.fill = function(i, a, u, d) {
    if (typeof i == "string") {
      if (typeof a == "string" ? (d = a, a = 0, u = this.length) : typeof u == "string" && (d = u, u = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !c.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (i.length === 1) {
        const p = i.charCodeAt(0);
        (d === "utf8" && p < 128 || d === "latin1") && (i = p);
      }
    } else
      typeof i == "number" ? i = i & 255 : typeof i == "boolean" && (i = Number(i));
    if (a < 0 || this.length < a || this.length < u)
      throw new RangeError("Out of range index");
    if (u <= a)
      return this;
    a = a >>> 0, u = u === void 0 ? this.length : u >>> 0, i || (i = 0);
    let g;
    if (typeof i == "number")
      for (g = a; g < u; ++g)
        this[g] = i;
    else {
      const p = c.isBuffer(i) ? i : c.from(i, d), v = p.length;
      if (v === 0)
        throw new TypeError('The value "' + i + '" is invalid for argument "value"');
      for (g = 0; g < u - a; ++g)
        this[g + a] = p[g % v];
    }
    return this;
  };
  const Be = {};
  function at(i, a, u) {
    Be[i] = class extends u {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: a.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: d,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  at(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), at(
    "ERR_INVALID_ARG_TYPE",
    function(i, a) {
      return `The "${i}" argument must be of type number. Received type ${typeof a}`;
    },
    TypeError
  ), at(
    "ERR_OUT_OF_RANGE",
    function(i, a, u) {
      let d = `The value of "${i}" is out of range.`, g = u;
      return Number.isInteger(u) && Math.abs(u) > 2 ** 32 ? g = ct(String(u)) : typeof u == "bigint" && (g = String(u), (u > BigInt(2) ** BigInt(32) || u < -(BigInt(2) ** BigInt(32))) && (g = ct(g)), g += "n"), d += ` It must be ${a}. Received ${g}`, d;
    },
    RangeError
  );
  function ct(i) {
    let a = "", u = i.length;
    const d = i[0] === "-" ? 1 : 0;
    for (; u >= d + 4; u -= 3)
      a = `_${i.slice(u - 3, u)}${a}`;
    return `${i.slice(0, u)}${a}`;
  }
  function pt(i, a, u) {
    Nt(a, "offset"), (i[a] === void 0 || i[a + u] === void 0) && zt(a, i.length - (u + 1));
  }
  function Je(i, a, u, d, g, p) {
    if (i > u || i < a) {
      const v = typeof a == "bigint" ? "n" : "";
      let Y;
      throw a === 0 || a === BigInt(0) ? Y = `>= 0${v} and < 2${v} ** ${(p + 1) * 8}${v}` : Y = `>= -(2${v} ** ${(p + 1) * 8 - 1}${v}) and < 2 ** ${(p + 1) * 8 - 1}${v}`, new Be.ERR_OUT_OF_RANGE("value", Y, i);
    }
    pt(d, g, p);
  }
  function Nt(i, a) {
    if (typeof i != "number")
      throw new Be.ERR_INVALID_ARG_TYPE(a, "number", i);
  }
  function zt(i, a, u) {
    throw Math.floor(i) !== i ? (Nt(i, u), new Be.ERR_OUT_OF_RANGE("offset", "an integer", i)) : a < 0 ? new Be.ERR_BUFFER_OUT_OF_BOUNDS() : new Be.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${a}`,
      i
    );
  }
  const xo = /[^+/0-9A-Za-z-_]/g;
  function zo(i) {
    if (i = i.split("=")[0], i = i.trim().replace(xo, ""), i.length < 2)
      return "";
    for (; i.length % 4 !== 0; )
      i = i + "=";
    return i;
  }
  function Hn(i, a) {
    a = a || 1 / 0;
    let u;
    const d = i.length;
    let g = null;
    const p = [];
    for (let v = 0; v < d; ++v) {
      if (u = i.charCodeAt(v), u > 55295 && u < 57344) {
        if (!g) {
          if (u > 56319) {
            (a -= 3) > -1 && p.push(239, 191, 189);
            continue;
          } else if (v + 1 === d) {
            (a -= 3) > -1 && p.push(239, 191, 189);
            continue;
          }
          g = u;
          continue;
        }
        if (u < 56320) {
          (a -= 3) > -1 && p.push(239, 191, 189), g = u;
          continue;
        }
        u = (g - 55296 << 10 | u - 56320) + 65536;
      } else
        g && (a -= 3) > -1 && p.push(239, 191, 189);
      if (g = null, u < 128) {
        if ((a -= 1) < 0)
          break;
        p.push(u);
      } else if (u < 2048) {
        if ((a -= 2) < 0)
          break;
        p.push(
          u >> 6 | 192,
          u & 63 | 128
        );
      } else if (u < 65536) {
        if ((a -= 3) < 0)
          break;
        p.push(
          u >> 12 | 224,
          u >> 6 & 63 | 128,
          u & 63 | 128
        );
      } else if (u < 1114112) {
        if ((a -= 4) < 0)
          break;
        p.push(
          u >> 18 | 240,
          u >> 12 & 63 | 128,
          u >> 6 & 63 | 128,
          u & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return p;
  }
  function Ro(i) {
    const a = [];
    for (let u = 0; u < i.length; ++u)
      a.push(i.charCodeAt(u) & 255);
    return a;
  }
  function Uo(i, a) {
    let u, d, g;
    const p = [];
    for (let v = 0; v < i.length && !((a -= 2) < 0); ++v)
      u = i.charCodeAt(v), d = u >> 8, g = u % 256, p.push(g), p.push(d);
    return p;
  }
  function Xr(i) {
    return t.toByteArray(zo(i));
  }
  function Jt(i, a, u, d) {
    let g;
    for (g = 0; g < d && !(g + u >= a.length || g >= i.length); ++g)
      a[g + u] = i[g];
    return g;
  }
  function Ye(i, a) {
    return i instanceof a || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === a.name;
  }
  function Kn(i) {
    return i !== i;
  }
  const ko = function() {
    const i = "0123456789abcdef", a = new Array(256);
    for (let u = 0; u < 16; ++u) {
      const d = u * 16;
      for (let g = 0; g < 16; ++g)
        a[d + g] = i[u] + i[g];
    }
    return a;
  }();
  function $e(i) {
    return typeof BigInt > "u" ? Qo : i;
  }
  function Qo() {
    throw new Error("BigInt not supported");
  }
})(sn);
var ft = class _ft {
  static toString(t, n = "utf8") {
    return sn.Buffer.from(t).toString(n);
  }
  static toHex(t) {
    return _ft.toString(t, "hex");
  }
  static toBase64(t) {
    return _ft.toString(t, "base64");
  }
  static fromHex(t) {
    return _ft.from(t, "hex");
  }
  static fromBase64(t) {
    return _ft.from(t, "base64");
  }
  static from(t, n = "utf8") {
    return Uint8Array.from(sn.Buffer.from(t, n));
  }
  static fromArrayLike(t) {
    const n = Object.keys(t).length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = t[o] || 0;
    return r;
  }
  static ensureUint8Array(t) {
    return typeof t == "string" ? Uint8Array.from(sn.Buffer.from(t, "base64")) : t instanceof Uint8Array ? t : typeof t == "object" && t !== null && !Array.isArray(t) ? this.fromArrayLike(t) : Uint8Array.from(t);
  }
  static bytesEqual(t, n) {
    if (t === n)
      return true;
    if (t.length !== n.length)
      return false;
    for (let r = 0; r < t.length; r++)
      if (t[r] !== n[r])
        return false;
    return true;
  }
};
var X = ((e) => (e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", e.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", e.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", e.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", e.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", e.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", e.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", e.WALLET__SIGN_PERSONAL_MSG_ERROR = "WALLET.SIGN_PERSONAL_MSG_ERROR", e.WALLET__VERIFY_PERSONAL_MSG_ERROR = "WALLET.VERIFY_PERSONAL_MSG_ERROR", e.WALLET__VERIFY_TRANSACTION_ERROR = "WALLET.VERIFY_TRANSACTION_ERROR", e.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", e.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", e.WALLET__REPORT_EFFECTS_ERROR = "WALLET.REPORT_EFFECTS_ERROR", e))(X || {});
var ki = class extends Error {
  constructor(t, n = X.UNKNOWN_ERROR, r) {
    super(t), J(this, "code"), J(this, "details"), this.details = r, this.code = n, this.message = this.formatErrorStr(n, t, r);
  }
  formatErrorStr(t, n, r) {
    let o = `[${this.code}] ${n}`;
    return r && (o += " | details: " + JSON.stringify(r)), o;
  }
};
var _ = class extends ki {
  constructor(t = "kit unknown error", n = X.KIT__UNKNOWN_ERROR, r) {
    super(t, n, r);
  }
};
var Ee = class extends ki {
  constructor(t = "wallet unknown error", n = X.WALLET__UNKNOWN_ERROR, r) {
    super(t, n, r);
  }
};
var Qi = class extends Ee {
  constructor(t) {
    super(`wallet does not implement function: ${t}`, X.WALLET__METHOD_NOT_IMPLEMENTED_ERROR);
  }
};
var Pr = ((e) => (e.EXTENSION = "EXTENSION", e.WEB = "WEB", e))(Pr || {});
var q = ((e) => (e.STANDARD__CONNECT = "standard:connect", e.STANDARD__DISCONNECT = "standard:disconnect", e.STANDARD__EVENTS = "standard:events", e.SUI__SIGN_AND_EXECUTE_TRANSACTION = "sui:signAndExecuteTransaction", e.SUI__SIGN_TRANSACTION = "sui:signTransaction", e.SUI__SIGN_PERSONAL_MESSAGE = "sui:signPersonalMessage", e.SUI__REPORT_TRANSACTION_EFFECTS = "sui:reportTransactionEffects", e.SUI__SIGN_MESSAGE = "sui:signMessage", e.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", e.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", e))(q || {});
var qs = class {
  constructor(t) {
    J(this, "standardWalletAdapter"), this.standardWalletAdapter = t;
  }
  get id() {
    var _a2;
    return (_a2 = this.standardWalletAdapter) == null ? void 0 : _a2.id;
  }
  get name() {
    return this.standardWalletAdapter.name;
  }
  get icon() {
    return this.standardWalletAdapter.icon;
  }
  get version() {
    return this.standardWalletAdapter.version;
  }
  get accounts() {
    return this.standardWalletAdapter.accounts;
  }
  get chains() {
    return this.standardWalletAdapter.chains;
  }
  get features() {
    return this.standardWalletAdapter.features;
  }
  async connect(t) {
    const n = this.getFeature(
      q.STANDARD__CONNECT
    );
    try {
      return await n.connect(t);
    } catch (r) {
      const { code: o, message: s, details: l } = Ha(
        r,
        this.name
      );
      throw new Ee(s, o, l);
    }
  }
  async disconnect() {
    const t = this.getFeature(
      q.STANDARD__DISCONNECT
    );
    try {
      return await t.disconnect();
    } catch (n) {
      throw new Ee(
        n.message,
        X.WALLET__DISCONNECT_ERROR
      );
    }
  }
  on(t, n) {
    const r = this.getFeature(
      q.STANDARD__EVENTS
    );
    try {
      return r.on(t, n);
    } catch (o) {
      throw new Ee(
        o.message,
        X.WALLET__LISTEN_TO_EVENT_ERROR
      );
    }
  }
  async signAndExecuteTransactionBlock(t) {
    const n = this.getFeature(q.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK);
    try {
      return await n.signAndExecuteTransactionBlock(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_TX_ERROR
      );
    }
  }
  signTransaction(t) {
    const n = this.getFeature(q.SUI__SIGN_TRANSACTION);
    try {
      return n.signTransaction(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_TX_ERROR
      );
    }
  }
  /**
   * @deprecated use signTransaction instead
   */
  signTransactionBlock(t) {
    const n = this.getFeature(q.SUI__SIGN_TRANSACTION_BLOCK);
    try {
      return n.signTransactionBlock(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_TX_ERROR
      );
    }
  }
  async signAndExecuteTransaction(t) {
    const n = this.getFeature(q.SUI__SIGN_AND_EXECUTE_TRANSACTION);
    try {
      return await n.signAndExecuteTransaction(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_TX_ERROR
      );
    }
  }
  reportTransactionEffects(t) {
    const n = this.getFeature(q.SUI__REPORT_TRANSACTION_EFFECTS);
    try {
      return n.reportTransactionEffects(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__REPORT_EFFECTS_ERROR
      );
    }
  }
  async signMessage(t) {
    const n = this.getFeature(
      q.SUI__SIGN_MESSAGE
    );
    try {
      return await n.signMessage(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_MSG_ERROR
      );
    }
  }
  signPersonalMessage(t) {
    const n = this.getFeature(q.SUI__SIGN_PERSONAL_MESSAGE);
    try {
      return n.signPersonalMessage(t);
    } catch (r) {
      throw new Ee(
        r.message,
        X.WALLET__SIGN_PERSONAL_MSG_ERROR
      );
    }
  }
  hasFeature(t) {
    const { features: n } = this.standardWalletAdapter;
    return xn(n, t);
  }
  getFeature(t) {
    const { features: n } = this.standardWalletAdapter;
    if (!xn(n, t))
      throw new Qi(t);
    return n[t];
  }
};
var Xs = function(e, t, n, r) {
  if (typeof t == "function" ? e !== t || true : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
};
var Hs = function(e, t, n, r, o) {
  if (typeof t == "function" ? e !== t || true : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
};
var an;
var $t;
var Zn = /* @__PURE__ */ new Set();
function Ks(e) {
  Wt = void 0, Zn.add(e);
}
function Js(e) {
  Wt = void 0, Zn.delete(e);
}
var bt = {};
function Pi() {
  if ($t || ($t = Object.freeze({ register: $r, get: $s, on: ea }), typeof window > "u"))
    return $t;
  const e = Object.freeze({ register: $r });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: t }) => t(e));
  } catch (t) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, t);
  }
  try {
    window.dispatchEvent(new ta(e));
  } catch (t) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, t);
  }
  return $t;
}
function $r(...e) {
  var _a2;
  return e = e.filter((t) => !Zn.has(t)), e.length ? (e.forEach((t) => Ks(t)), (_a2 = bt.register) == null ? void 0 : _a2.forEach((t) => ei(() => t(...e))), function() {
    var _a3;
    e.forEach((t) => Js(t)), (_a3 = bt.unregister) == null ? void 0 : _a3.forEach((t) => ei(() => t(...e)));
  }) : () => {
  };
}
var Wt;
function $s() {
  return Wt || (Wt = [...Zn]), Wt;
}
function ea(e, t) {
  var _a2;
  return ((_a2 = bt[e]) == null ? void 0 : _a2.push(t)) || (bt[e] = [t]), function() {
    var _a3;
    bt[e] = (_a3 = bt[e]) == null ? void 0 : _a3.filter((n) => t !== n);
  };
}
function ei(e) {
  try {
    e();
  } catch (t) {
    console.error(t);
  }
}
var ta = class extends Event {
  get detail() {
    return Xs(this, an, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(t) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    }), an.set(this, void 0), Hs(this, an, t);
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
an = /* @__PURE__ */ new WeakMap();
var It = function(e, t, n, r) {
  if (typeof t == "function" ? e !== t || true : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
};
var vt = function(e, t, n, r, o) {
  if (typeof t == "function" ? e !== t || true : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
};
var cn;
var un;
var ln;
var fn;
var dn;
var hn;
var Wr = class _Wr {
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
  get address() {
    return It(this, cn, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
  get publicKey() {
    return It(this, un, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
  get chains() {
    return It(this, ln, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
  get features() {
    return It(this, fn, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
  get label() {
    return It(this, dn, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
  get icon() {
    return It(this, hn, "f");
  }
  /**
   * Create and freeze a read-only account.
   *
   * @param account Account to copy properties from.
   */
  constructor(t) {
    cn.set(this, void 0), un.set(this, void 0), ln.set(this, void 0), fn.set(this, void 0), dn.set(this, void 0), hn.set(this, void 0), new.target === _Wr && Object.freeze(this), vt(this, cn, t.address), vt(this, un, t.publicKey.slice()), vt(this, ln, t.chains.slice()), vt(this, fn, t.features.slice()), vt(this, dn, t.label), vt(this, hn, t.icon);
  }
};
cn = /* @__PURE__ */ new WeakMap(), un = /* @__PURE__ */ new WeakMap(), ln = /* @__PURE__ */ new WeakMap(), fn = /* @__PURE__ */ new WeakMap(), dn = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakMap();
var na = "sui:devnet";
var ra = "sui:testnet";
var ia = "sui:localnet";
var oa = "sui:mainnet";
var Wi = [
  na,
  ra,
  ia,
  oa
];
function sa(e) {
  return q.STANDARD__CONNECT in e.features && q.STANDARD__EVENTS in e.features && (q.SUI__SIGN_TRANSACTION in e.features || q.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK in e.features);
}
var aa = class {
  constructor() {
    J(this, "walletStandardSdk"), J(this, "walletAdapterMap"), J(this, "clearOnRegisterListener"), J(this, "subscriptions", /* @__PURE__ */ new Set()), this.walletStandardSdk = null, this.clearOnRegisterListener = null, this.walletAdapterMap = /* @__PURE__ */ new Map();
  }
  activate() {
    this.walletStandardSdk = Pi(), this.walletStandardSdk.get().forEach((t) => {
      this.setDetectedWalletAdapters(t);
    }), this.clearOnRegisterListener = this.walletStandardSdk.on(
      "register",
      (...t) => {
        t.forEach((n) => {
          this.setDetectedWalletAdapters(n);
        }), this.notifySubscribers();
      }
    );
  }
  deactivate() {
    this.clearOnRegisterListener && this.clearOnRegisterListener(), this.walletAdapterMap.clear();
  }
  getDetectedWalletAdapters() {
    return Array.from(this.walletAdapterMap.values());
  }
  subscribe(t) {
    return this.subscriptions.add(t), () => {
      this.subscriptions.delete(t);
    };
  }
  notifySubscribers() {
    this.subscriptions.forEach((t) => {
      t(this.getDetectedWalletAdapters());
    });
  }
  setDetectedWalletAdapters(t) {
    sa(t) && (this.walletAdapterMap.has(t.name) || this.walletAdapterMap.set(t.name, new qs(t)));
  }
};
function ca(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var r = e.get(t);
    r ? r.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var r = e.get(t);
    r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var r = e.get(t);
    r && r.slice().map(function(o) {
      o(n);
    }), (r = e.get("*")) && r.slice().map(function(o) {
      o(t, n);
    });
  } };
}
var ua = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
var rr;
function Bi(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (rr == null ? void 0 : rr.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (rr == null ? void 0 : rr.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (rr == null ? void 0 : rr.abortPipeEarly)
  };
}
var la;
function fa(e) {
  return la == null ? void 0 : la.get(e);
}
var da;
function ha(e) {
  return da == null ? void 0 : da.get(e);
}
var ga;
function Ma(e, t) {
  var _a2;
  return (_a2 = ga == null ? void 0 : ga.get(e)) == null ? void 0 : _a2.get(t);
}
function Yi(e) {
  var _a2, _b;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((_b = (_a2 = Object.getPrototypeOf(e)) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name)) ?? "null" : t;
}
function ot(e, t, n, r, o) {
  const s = o && "input" in o ? o.input : n.value, l = (o == null ? void 0 : o.expected) ?? e.expects ?? null, c = (o == null ? void 0 : o.received) ?? Yi(s), f = {
    kind: e.kind,
    type: e.type,
    input: s,
    expected: l,
    received: c,
    message: `Invalid ${t}: ${l ? `Expected ${l} but r` : "R"}eceived ${c}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: r.lang,
    abortEarly: r.abortEarly,
    abortPipeEarly: r.abortPipeEarly
  }, h = e.kind === "schema", M = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? Ma(e.reference, f.lang) ?? (h ? ha(f.lang) : null) ?? r.message ?? fa(f.lang);
  M && (f.message = typeof M == "function" ? M(f) : M), h && (n.typed = false), n.issues ? n.issues.push(f) : n.issues = [f];
}
var ya = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), J(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function Fi(e) {
  return {
    kind: "validation",
    type: "uuid",
    reference: Fi,
    async: false,
    expects: null,
    requirement: ua,
    message: e,
    _run(t, n) {
      return t.typed && !this.requirement.test(t.value) && ot(this, "UUID", t, n), t;
    }
  };
}
function pa(e, t, n) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, n)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function _i(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: _i,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(n, r) {
      var _a2;
      const o = n.value;
      if (Array.isArray(o)) {
        n.typed = true, n.value = [];
        for (let s = 0; s < o.length; s++) {
          const l = o[s], c = this.item._run({ typed: false, value: l }, r);
          if (c.issues) {
            const f = {
              type: "array",
              origin: "value",
              input: o,
              key: s,
              value: l
            };
            for (const h of c.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (_a2 = n.issues) == null ? void 0 : _a2.push(h);
            if (n.issues || (n.issues = c.issues), r.abortEarly) {
              n.typed = false;
              break;
            }
          }
          c.typed || (n.typed = false), n.value.push(c.value);
        }
      } else
        ot(this, "type", n, r);
      return n;
    }
  };
}
function Xe(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: Xe,
    expects: Yi(e),
    async: false,
    literal: e,
    message: t,
    _run(n, r) {
      return n.value === this.literal ? n.typed = true : ot(this, "type", n, r), n;
    }
  };
}
function hr(e) {
  return {
    kind: "schema",
    type: "number",
    reference: hr,
    expects: "number",
    async: false,
    message: e,
    _run(t, n) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : ot(this, "type", t, n), t;
    }
  };
}
function Qe(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Qe,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(n, r) {
      var _a2;
      const o = n.value;
      if (o && typeof o == "object") {
        n.typed = true, n.value = {};
        for (const s in this.entries) {
          const l = o[s], c = this.entries[s]._run(
            { typed: false, value: l },
            r
          );
          if (c.issues) {
            const f = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: l
            };
            for (const h of c.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (_a2 = n.issues) == null ? void 0 : _a2.push(h);
            if (n.issues || (n.issues = c.issues), r.abortEarly) {
              n.typed = false;
              break;
            }
          }
          c.typed || (n.typed = false), (c.value !== void 0 || s in o) && (n.value[s] = c.value);
        }
      } else
        ot(this, "type", n, r);
      return n;
    }
  };
}
function Gi(e, ...t) {
  const n = {
    kind: "schema",
    type: "optional",
    reference: Gi,
    expects: `${e.expects} | undefined`,
    async: false,
    wrapped: e,
    _run(r, o) {
      return r.value === void 0 && ("default" in this && (r.value = pa(
        this,
        r,
        o
      )), r.value === void 0) ? (r.typed = true, r) : this.wrapped._run(r, o);
    }
  };
  return 0 in t && (n.default = t[0]), n;
}
function de(e) {
  return {
    kind: "schema",
    type: "string",
    reference: de,
    expects: "string",
    async: false,
    message: e,
    _run(t, n) {
      return typeof t.value == "string" ? t.typed = true : ot(this, "type", t, n), t;
    }
  };
}
function Zi(e, t, n = /* @__PURE__ */ new Set()) {
  for (const r of t)
    r.type === "variant" ? Zi(e, r.options, n) : n.add(r.entries[e].expects);
  return n;
}
function Br(e, t, n) {
  let r;
  return {
    kind: "schema",
    type: "variant",
    reference: Br,
    expects: "Object",
    async: false,
    key: e,
    options: t,
    message: n,
    _run(o, s) {
      const l = o.value;
      if (l && typeof l == "object") {
        const c = l[this.key];
        if (this.key in l) {
          let f;
          for (const h of this.options)
            if (h.type === "variant" || !h.entries[this.key]._run(
              { typed: false, value: c },
              s
            ).issues) {
              const M = h._run(
                { typed: false, value: l },
                s
              );
              if (!M.issues)
                return M;
              (!f || !f.typed && M.typed) && (f = M);
            }
          if (f)
            return f;
        }
        r || (r = [...Zi(this.key, this.options)].join(" | ") || "never"), ot(this, "type", o, s, {
          input: c,
          expected: r,
          path: [
            {
              type: "object",
              origin: "value",
              input: l,
              key: this.key,
              value: c
            }
          ]
        });
      } else
        ot(this, "type", o, s);
      return o;
    }
  };
}
function Na(e, t, n) {
  const r = e._run(
    { typed: false, value: t },
    Bi(n)
  );
  if (r.issues)
    throw new ya(r.issues);
  return r.value;
}
function Aa(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, n) {
      for (let r = 0; r < e.length; r++) {
        if (t.issues && (e[r].kind === "schema" || e[r].kind === "transformation")) {
          t.typed = false;
          break;
        }
        (!t.issues || !n.abortEarly && !n.abortPipeEarly) && (t = e[r]._run(t, n));
      }
      return t;
    }
  };
}
function Ia(e, t, n) {
  const r = e._run(
    { typed: false, value: t },
    Bi(n)
  );
  return {
    typed: r.typed,
    success: !r.issues,
    output: r.value,
    issues: r.issues
  };
}
new TextEncoder();
var gr = new TextDecoder();
function va(e) {
  if (Uint8Array.fromBase64)
    return Uint8Array.fromBase64(e);
  const t = atob(e), n = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    n[r] = t.charCodeAt(r);
  return n;
}
function ma(e) {
  if (Uint8Array.fromBase64)
    return Uint8Array.fromBase64(typeof e == "string" ? e : gr.decode(e), {
      alphabet: "base64url"
    });
  let t = e;
  t instanceof Uint8Array && (t = gr.decode(t)), t = t.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return va(t);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
var Vi = class extends Error {
  constructor(t, n) {
    var _a2;
    super(t, n), J(this, "code", "ERR_JOSE_GENERIC"), this.name = this.constructor.name, (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
J(Vi, "code", "ERR_JOSE_GENERIC");
var tt = class extends Vi {
  constructor() {
    super(...arguments), J(this, "code", "ERR_JWT_INVALID");
  }
};
J(tt, "code", "ERR_JWT_INVALID");
function Da(e) {
  return typeof e == "object" && e !== null;
}
var wa = (e) => {
  if (!Da(e) || Object.prototype.toString.call(e) !== "[object Object]")
    return false;
  if (Object.getPrototypeOf(e) === null)
    return true;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
};
function Ea(e) {
  if (typeof e != "string")
    throw new tt("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: t, length: n } = e.split(".");
  if (n === 5)
    throw new tt("Only JWTs using Compact JWS serialization can be decoded");
  if (n !== 3)
    throw new tt("Invalid JWT");
  if (!t)
    throw new tt("JWTs must contain a payload");
  let r;
  try {
    r = ma(t);
  } catch {
    throw new tt("Failed to base64url decode the payload");
  }
  let o;
  try {
    o = JSON.parse(gr.decode(r));
  } catch {
    throw new tt("Failed to parse the decoded payload as JSON");
  }
  if (!wa(o))
    throw new tt("Invalid JWT Claims Set");
  return o;
}
var ba = Qe({
  address: de(),
  publicKey: de()
});
var Ta = Qe({
  exp: hr(),
  // Expiration Time
  iat: hr(),
  // Issued At
  iss: de(),
  // Issuer
  aud: de(),
  // Audience (the dapp origin)
  payload: Qe({
    accounts: _i(ba)
  })
});
function ja(e) {
  const t = Ea(e);
  return Na(Ta, t);
}
var La = Br("type", [
  Qe({
    type: Xe("connect"),
    session: de("`session` is required")
  }),
  Qe({
    type: Xe("sign-transaction"),
    bytes: de(),
    signature: de()
  }),
  Qe({
    type: Xe("sign-and-execute-transaction"),
    bytes: de(),
    signature: de(),
    digest: de(),
    effects: de()
  }),
  Qe({
    type: Xe("sign-personal-message"),
    bytes: de(),
    signature: de()
  })
]);
var Sa = Br("type", [
  Qe({
    type: Xe("reject"),
    reason: Gi(de("`reason` must be a string"))
  }),
  Qe({
    type: Xe("resolve"),
    data: La
  })
]);
var Ca = Qe({
  id: Aa(de(), Fi()),
  source: Xe("web-wallet-channel"),
  payload: Sa,
  version: Xe("1")
});
function Oa() {
  let e, t;
  return {
    promise: new Promise((n, r) => {
      e = n, t = r;
    }),
    resolve: e,
    reject: t
  };
}
function xa() {
  return {
    version: "1",
    originUrl: window.location.href,
    userAgent: navigator.userAgent,
    screenResolution: `${window.screen.width}x${window.screen.height}`,
    language: navigator.language,
    platform: navigator.platform,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    timestamp: Date.now()
  };
}
var qi = (e) => {
  throw TypeError(e);
};
var Yr = (e, t, n) => t.has(e) || qi("Cannot " + n);
var ne = (e, t, n) => (Yr(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var ve = (e, t, n) => t.has(e) ? qi("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
var Se = (e, t, n, r) => (Yr(e, t, "write to private field"), t.set(e, n), n);
var ir = (e, t, n) => (Yr(e, t, "access private method"), n);
var ut;
var Mr;
var Ut;
var kt;
var gn;
var Mn;
var yn;
var pn;
var Nn;
var An;
var Lt;
var In;
var zn;
var Qt;
var vn;
var za = class {
  constructor({
    appName: t,
    hostOrigin: n,
    hostPathname: r = "dapp-request",
    extraRequestOptions: o
  }) {
    ve(this, Qt), ve(this, ut), ve(this, Mr, "1"), ve(this, Ut), ve(this, kt), ve(this, gn), ve(this, Mn), ve(this, yn), ve(this, pn), ve(this, Nn), ve(this, An), ve(this, Lt, null), ve(this, In, false), ve(this, zn, (h) => {
      if (h.origin !== ne(this, kt))
        return;
      const { success: M, output: y } = Ia(Ca, h.data);
      !M || y.id !== ne(this, Ut) || (ir(this, Qt, vn).call(this), y.payload.type === "reject" ? ne(this, An).call(this, new Error("User rejected the request")) : y.payload.type === "resolve" && ne(this, Nn).call(this, y.payload.data));
    });
    const s = window.open("about:blank", "_blank");
    if (!s)
      throw new Error("Failed to open new window");
    Se(this, Ut, crypto.randomUUID()), Se(this, ut, s), Se(this, kt, n), Se(this, gn, r), Se(this, Mn, t);
    const { promise: l, resolve: c, reject: f } = Oa();
    Se(this, pn, l), Se(this, Nn, c), Se(this, An, f), Se(this, yn, o), Se(this, Lt, setInterval(() => {
      try {
        ne(this, ut).closed && (ir(this, Qt, vn).call(this), f(new Error("User closed the wallet window")));
      } catch {
      }
    }, 1e3));
  }
  send({
    type: t,
    ...n
  }) {
    if (ne(this, ut).closed)
      throw new Error("User closed the wallet window");
    if (ne(this, In))
      throw new Error("send() can only be called once");
    Se(this, In, true), window.addEventListener("message", ne(this, zn));
    const r = {
      version: ne(this, Mr),
      requestId: ne(this, Ut),
      appUrl: window.location.href.split("#")[0],
      appName: ne(this, Mn),
      payload: {
        type: t,
        ...n
      },
      metadata: xa(),
      extraRequestOptions: ne(this, yn)
    }, o = encodeURIComponent(btoa(JSON.stringify(r)));
    return ne(this, ut).location.assign(`${ne(this, kt)}/${ne(this, gn)}#${o}`), ne(this, pn);
  }
  close() {
    ir(this, Qt, vn).call(this), ne(this, ut).close();
  }
};
ut = /* @__PURE__ */ new WeakMap();
Mr = /* @__PURE__ */ new WeakMap();
Ut = /* @__PURE__ */ new WeakMap();
kt = /* @__PURE__ */ new WeakMap();
gn = /* @__PURE__ */ new WeakMap();
Mn = /* @__PURE__ */ new WeakMap();
yn = /* @__PURE__ */ new WeakMap();
pn = /* @__PURE__ */ new WeakMap();
Nn = /* @__PURE__ */ new WeakMap();
An = /* @__PURE__ */ new WeakMap();
Lt = /* @__PURE__ */ new WeakMap();
In = /* @__PURE__ */ new WeakMap();
zn = /* @__PURE__ */ new WeakMap();
Qt = /* @__PURE__ */ new WeakSet();
vn = function() {
  ne(this, Lt) && (clearInterval(ne(this, Lt)), Se(this, Lt, null)), window.removeEventListener("message", ne(this, zn));
};
var Xi = (e) => {
  throw TypeError(e);
};
var Fr = (e, t, n) => t.has(e) || Xi("Cannot " + n);
var le = (e, t, n) => (Fr(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var Me = (e, t, n) => t.has(e) ? Xi("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
var nt = (e, t, n, r) => (Fr(e, t, "write to private field"), t.set(e, n), n);
var et = (e, t, n) => (Fr(e, t, "access private method"), n);
var mn;
var Tt;
var Bt;
var Rn;
var Dn;
var wn;
var Un;
var yr;
var pr;
var Nr;
var Ar;
var Ir;
var Fe;
var En;
var vr;
var mr;
var Et;
var Ra = "https://my.slush.app";
var _r = "slush:session";
function Ua(e) {
  localStorage.setItem(_r, e);
}
function Rt() {
  const e = localStorage.getItem(_r);
  if (!e)
    throw new Error("No session found");
  return e;
}
var ka = [
  "sui:signTransaction",
  "sui:signAndExecuteTransaction",
  "sui:signPersonalMessage",
  "sui:signTransactionBlock",
  "sui:signAndExecuteTransactionBlock"
];
async function ti(e) {
  const { payload: t } = await ja(e);
  return t.accounts.map((n) => new Wr({
    address: n.address,
    chains: Wi,
    features: ka,
    publicKey: fromBase64(n.publicKey)
  }));
}
var Qa = class {
  constructor({
    name: e,
    origin: t,
    metadata: n
  }) {
    Me(this, Fe), Me(this, mn), Me(this, Tt), Me(this, Bt), Me(this, Rn), Me(this, Dn), Me(this, wn), Me(this, Un), Me(this, yr, async ({
      transactionBlock: r,
      account: o,
      chain: s
    }) => {
      const l = await r.toJSON(), c = await et(this, Fe, Et).call(this).send({
        type: "sign-transaction",
        transaction: l,
        address: o.address,
        chain: s,
        session: Rt()
      });
      return {
        transactionBlockBytes: c.bytes,
        signature: c.signature
      };
    }), Me(this, pr, async ({ transaction: r, account: o, chain: s }) => {
      const l = et(this, Fe, Et).call(this), c = await r.toJSON(), f = await l.send({
        type: "sign-transaction",
        transaction: c,
        address: o.address,
        chain: s,
        session: Rt()
      });
      return {
        bytes: f.bytes,
        signature: f.signature
      };
    }), Me(this, Nr, async ({
      transaction: r,
      account: o,
      chain: s
    }) => {
      const l = et(this, Fe, Et).call(this), c = await r.toJSON(), f = await l.send({
        type: "sign-and-execute-transaction",
        transaction: c,
        address: o.address,
        chain: s,
        session: Rt()
      });
      return {
        bytes: f.bytes,
        signature: f.signature,
        digest: f.digest,
        effects: f.effects
      };
    }), Me(this, Ar, async ({ message: r, account: o }) => {
      const s = await et(this, Fe, Et).call(this).send({
        type: "sign-personal-message",
        message: toBase64(r),
        address: o.address,
        session: Rt(),
        chain: o.chains[0]
      });
      return {
        bytes: s.bytes,
        signature: s.signature
      };
    }), Me(this, Ir, (r, o) => (le(this, Tt).on(r, o), () => le(this, Tt).off(r, o))), Me(this, vr, async (r) => {
      if (r == null ? void 0 : r.silent) {
        try {
          const s = await ti(Rt());
          s.length && et(this, Fe, En).call(this, s);
        } catch {
        }
        return { accounts: this.accounts };
      }
      const o = await et(this, Fe, Et).call(this).send({
        type: "connect"
      });
      return Ua(o.session), et(this, Fe, En).call(this, await ti(o.session)), { accounts: this.accounts };
    }), Me(this, mr, async () => {
      localStorage.removeItem(_r), et(this, Fe, En).call(this, []);
    }), nt(this, mn, n.id), nt(this, Bt, []), nt(this, Tt, ca()), nt(this, Rn, t || Ra), nt(this, Un, e), nt(this, Dn, n.walletName), nt(this, wn, n.icon);
  }
  get name() {
    return le(this, Dn);
  }
  get id() {
    return le(this, mn);
  }
  get icon() {
    return le(this, wn);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return Wi;
  }
  get accounts() {
    return le(this, Bt);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: le(this, vr)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: le(this, mr)
      },
      "standard:events": {
        version: "1.0.0",
        on: le(this, Ir)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: le(this, yr)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: le(this, pr)
      },
      "sui:signPersonalMessage": {
        version: "1.1.0",
        signPersonalMessage: le(this, Ar)
      },
      "sui:signAndExecuteTransaction": {
        version: "2.0.0",
        signAndExecuteTransaction: le(this, Nr)
      }
    };
  }
};
mn = /* @__PURE__ */ new WeakMap();
Tt = /* @__PURE__ */ new WeakMap();
Bt = /* @__PURE__ */ new WeakMap();
Rn = /* @__PURE__ */ new WeakMap();
Dn = /* @__PURE__ */ new WeakMap();
wn = /* @__PURE__ */ new WeakMap();
Un = /* @__PURE__ */ new WeakMap();
yr = /* @__PURE__ */ new WeakMap();
pr = /* @__PURE__ */ new WeakMap();
Nr = /* @__PURE__ */ new WeakMap();
Ar = /* @__PURE__ */ new WeakMap();
Ir = /* @__PURE__ */ new WeakMap();
Fe = /* @__PURE__ */ new WeakSet();
En = function(e) {
  nt(this, Bt, e), le(this, Tt).emit("change", { accounts: this.accounts });
};
vr = /* @__PURE__ */ new WeakMap();
mr = /* @__PURE__ */ new WeakMap();
Et = function() {
  return new za({
    appName: le(this, Un),
    hostOrigin: le(this, Rn)
  });
};
var Pa = (e) => {
  const t = Pi(), { appName: n, origin: r, network: o = "mainnet" } = e, s = new Qa({
    name: n,
    origin: r,
    chain: `sui:${o}`,
    metadata: {
      id: Hi.SLUSH_WEB_WALLET,
      walletName: pe.SLUSH_WEB_WALLET,
      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNENBMkZGIi8+CjxwYXRoIGQ9Ik0xMi4zNDczIDM0LjcyNTRDMTMuNTU1MyAzOS4yMzM2IDE4LjA2NzMgNDMuMzE0OCAyNy40MDI1IDQwLjgxMzRDMzYuMzA5NyAzOC40MjY3IDQxLjg5MjEgMzEuMDk5MyA0MC40NDQ2IDI1LjY5NzJDMzkuOTQ0NyAyMy44MzE3IDM4LjQzOTEgMjIuNTY4OSAzNi4xMTc4IDIyLjc3NDRMMTUuMzYxNSAyNC41MDM4QzE0LjA1NDQgMjQuNjA0MSAxMy40NTUgMjQuMzg5OCAxMy4xMDkyIDIzLjU2NjFDMTIuNzczOCAyMi43ODEyIDEyLjk2NDkgMjEuOTM4NSAxNC41NDM3IDIxLjE0MDZMMzAuMzM5NiAxMy4wMzQyQzMxLjU1MDMgMTIuNDE4MiAzMi4zNTY3IDEyLjE2MDUgMzMuMDkzNiAxMi40MjEzQzMzLjU1NTUgMTIuNTg5MSAzMy44NTk2IDEzLjI1NzQgMzMuNTgwMyAxNC4wODJMMzIuNTU2MSAxNy4xMDU2QzMxLjI5OTIgMjAuODE2NCAzMy45ODk5IDIxLjY3ODQgMzUuNTA2OCAyMS4yNzE5QzM3LjgwMTcgMjAuNjU3IDM4LjM0MTYgMTguNDcxMiAzNy42MDIzIDE1LjcxMTlDMzUuNzI3OCA4LjcxNjI5IDI4LjMwNTkgNy42MjI1NCAyMS41NzY4IDkuNDI1NTlDMTQuNzMxMSAxMS4yNTk5IDguNzk2ODEgMTYuODA3MiAxMC42MDg4IDIzLjU2OTZDMTEuMDM1OCAyNS4xNjMgMTIuNTAyNSAyNi40MzYyIDE0LjIwMTQgMjYuMzk3NUwxNi43OTUgMjYuMzkxMkMxNy4zMjg0IDI2LjM3ODggMTcuMTM2MyAyNi40MjI3IDE4LjE2NTMgMjYuMzM3NEMxOS4xOTQ0IDI2LjI1MjIgMjEuOTQyNSAyNS45MTQgMjEuOTQyNSAyNS45MTRMMzUuNDI3NSAyNC4zODhMMzUuNzc1IDI0LjMzNzVDMzYuNTYzNyAyNC4yMDMgMzcuMTU5NyAyNC40MDc5IDM3LjY2MzYgMjUuMjc2QzM4LjQxNzcgMjYuNTc1IDM3LjI2NzIgMjcuNTU0NiAzNS44ODk5IDI4LjcyNzJDMzUuODUzIDI4Ljc1ODYgMzUuODE2IDI4Ljc5MDEgMzUuNzc4OSAyOC44MjE4TDIzLjkyNSAzOS4wMzc3QzIxLjg5MzMgNDAuNzkwMSAyMC40NjYgNDAuMTMxMSAxOS45NjYyIDM4LjI2NTZMMTguMTk1OCAzMS42NTg3QzE3Ljc1ODUgMzAuMDI2NCAxNi4xNjQ2IDI4Ljc0NTYgMTQuMjk3NiAyOS4yNDU5QzExLjk2MzggMjkuODcxMiAxMS43NzQ2IDMyLjU4NzggMTIuMzQ3MyAzNC43MjU0WiIgZmlsbD0iIzA2MEQxNCIvPgo8L3N2Zz4K",
      enabled: true
    }
  });
  return t.register(s);
};
function he(e) {
  return Object.freeze(e);
}
var Hi = ((e) => (e.SLUSH_WALLET = "com.mystenlabs.suiwallet", e.SLUSH_WEB_WALLET = "com.mystenlabs.suiwallet.web", e))(Hi || {});
var pe = ((e) => (e.SUIET_WALLET = "Suiet", e.SLUSH_WALLET = "Slush  A Sui wallet", e.SLUSH_WEB_WALLET = "Slush", e.PHANTOM_WALLET = "Phantom", e.OKX_WALLET = "OKX Wallet", e.ONEKEY_WALLET = "OneKey Wallet", e.SURF_WALLET = "Surf Wallet", e.GLASS_WALLET = "GlassWallet", e.NIGHTLY_WALLET = "Nightly", e.TOKENPOCKET_WALLET = "TokenPocket Wallet", e.MARTIAN_WALLET = "Martian Sui Wallet", e.SUI_WALLET = "Slush  A Sui wallet", e.ETHOS_WALLET = "Ethos Wallet", e.MORPHIS_WALLET = "Morphis Wallet", e.SPACECY_WALLET = "Spacecy Sui Wallet", e.SENSUI_WALLET = "Sensui Wallet", e.ELLI_WALLET = "Elli", e.FRONTIER_WALLET = "Frontier Wallet", e))(pe || {});
var Wa = he({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
});
var Ki = he({
  id: "com.mystenlabs.suiwallet",
  name: "Slush  A Sui wallet",
  label: "Slush Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMjRDMCAxMC43NDUyIDEwLjc0NTIgMCAyNCAwQzM3LjI1NDggMCA0OCAxMC43NDUyIDQ4IDI0QzQ4IDM3LjI1NDggMzcuMjU0OCA0OCAyNCA0OEMxMC43NDUyIDQ4IDAgMzcuMjU0OCAwIDI0WiIgZmlsbD0iIzBDMEExRiIvPgo8cGF0aCBkPSJNMTMuMTM1OCAzMi4xMDg1QzE0LjE3MDEgMzUuOTY4MyAxOC4wMzMxIDM5LjQ2MjQgMjYuMDI1NSAzNy4zMjA4QzMzLjY1MTUgMzUuMjc3NCAzOC40MzA5IDI5LjAwNCAzNy4xOTE2IDI0LjM3ODlDMzYuNzYzNiAyMi43ODE3IDM1LjQ3NDYgMjEuNzAwNiAzMy40ODcyIDIxLjg3NjVMMTUuNzE2NSAyMy4zNTcyQzE0LjU5NzMgMjMuNDQzIDE0LjA4NDIgMjMuMjU5NiAxMy43ODgxIDIyLjU1NDNDMTMuNTAxIDIxLjg4MjMgMTMuNjY0NiAyMS4xNjA5IDE1LjAxNjMgMjAuNDc3N0wyOC41NDAxIDEzLjUzNzRDMjkuNTc2NyAxMy4wMSAzMC4yNjcxIDEyLjc4OTMgMzAuODk4IDEzLjAxMjZDMzEuMjkzNCAxMy4xNTYzIDMxLjU1MzggMTMuNzI4NCAzMS4zMTQ3IDE0LjQzNDRMMzAuNDM3OCAxNy4wMjMyQzI5LjM2MTcgMjAuMjAwMiAzMS42NjUzIDIwLjkzODIgMzIuOTY0MSAyMC41OTAyQzM0LjkyODkgMjAuMDYzNyAzNS4zOTExIDE4LjE5MjMgMzQuNzU4MSAxNS44Mjk5QzMzLjE1MzMgOS44NDA1NCAyNi43OTkgOC45MDQxMSAyMS4wMzc4IDEwLjQ0NzhDMTUuMTc2NyAxMi4wMTgzIDEwLjA5NiAxNi43Njc2IDExLjY0NzQgMjIuNTU3M0MxMi4wMTI5IDIzLjkyMTYgMTMuMjY4NyAyNS4wMTE2IDE0LjcyMzIgMjQuOTc4NUwxNi45NDM4IDI0Ljk3MzFDMTcuNDAwNCAyNC45NjI1IDE3LjIzNiAyNSAxOC4xMTcgMjQuOTI3MUMxOC45OTggMjQuODU0MSAyMS4zNTA5IDI0LjU2NDYgMjEuMzUwOSAyNC41NjQ2TDMyLjg5NjIgMjMuMjU4TDMzLjE5MzcgMjMuMjE0OEMzMy44Njg5IDIzLjA5OTcgMzQuMzc5MiAyMy4yNzUgMzQuODEwNiAyNC4wMTgzQzM1LjQ1NjMgMjUuMTMwNCAzNC40NzEyIDI1Ljk2OTEgMzMuMjkyIDI2Ljk3MzFDMzMuMjYwNSAyNyAzMy4yMjg4IDI3LjAyNyAzMy4xOTcgMjcuMDU0MUwyMy4wNDgyIDM1LjgwMDVDMjEuMzA4NyAzNy4zMDA4IDIwLjA4NjcgMzYuNzM2NyAxOS42NTg4IDM1LjEzOTVMMTguMTQzMSAyOS40ODI5QzE3Ljc2ODcgMjguMDg1NCAxNi40MDQxIDI2Ljk4ODkgMTQuODA1NiAyNy40MTcyQzEyLjgwNzUgMjcuOTUyNiAxMi42NDU1IDMwLjI3ODQgMTMuMTM1OCAzMi4xMDg1WiIgZmlsbD0iI0ZCRkFGRiIvPgo8L3N2Zz4K",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/slush-%E2%80%94-a-sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
});
function Ji(e) {
  const t = {
    id: "com.mystenlabs.suiwallet.web",
    name: "Slush",
    type: Pr.WEB,
    label: "Slush Web Wallet",
    iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNENBMkZGIi8+CjxwYXRoIGQ9Ik0xMi4zNDczIDM0LjcyNTRDMTMuNTU1MyAzOS4yMzM2IDE4LjA2NzMgNDMuMzE0OCAyNy40MDI1IDQwLjgxMzRDMzYuMzA5NyAzOC40MjY3IDQxLjg5MjEgMzEuMDk5MyA0MC40NDQ2IDI1LjY5NzJDMzkuOTQ0NyAyMy44MzE3IDM4LjQzOTEgMjIuNTY4OSAzNi4xMTc4IDIyLjc3NDRMMTUuMzYxNSAyNC41MDM4QzE0LjA1NDQgMjQuNjA0MSAxMy40NTUgMjQuMzg5OCAxMy4xMDkyIDIzLjU2NjFDMTIuNzczOCAyMi43ODEyIDEyLjk2NDkgMjEuOTM4NSAxNC41NDM3IDIxLjE0MDZMMzAuMzM5NiAxMy4wMzQyQzMxLjU1MDMgMTIuNDE4MiAzMi4zNTY3IDEyLjE2MDUgMzMuMDkzNiAxMi40MjEzQzMzLjU1NTUgMTIuNTg5MSAzMy44NTk2IDEzLjI1NzQgMzMuNTgwMyAxNC4wODJMMzIuNTU2MSAxNy4xMDU2QzMxLjI5OTIgMjAuODE2NCAzMy45ODk5IDIxLjY3ODQgMzUuNTA2OCAyMS4yNzE5QzM3LjgwMTcgMjAuNjU3IDM4LjM0MTYgMTguNDcxMiAzNy42MDIzIDE1LjcxMTlDMzUuNzI3OCA4LjcxNjI5IDI4LjMwNTkgNy42MjI1NCAyMS41NzY4IDkuNDI1NTlDMTQuNzMxMSAxMS4yNTk5IDguNzk2ODEgMTYuODA3MiAxMC42MDg4IDIzLjU2OTZDMTEuMDM1OCAyNS4xNjMgMTIuNTAyNSAyNi40MzYyIDE0LjIwMTQgMjYuMzk3NUwxNi43OTUgMjYuMzkxMkMxNy4zMjg0IDI2LjM3ODggMTcuMTM2MyAyNi40MjI3IDE4LjE2NTMgMjYuMzM3NEMxOS4xOTQ0IDI2LjI1MjIgMjEuOTQyNSAyNS45MTQgMjEuOTQyNSAyNS45MTRMMzUuNDI3NSAyNC4zODhMMzUuNzc1IDI0LjMzNzVDMzYuNTYzNyAyNC4yMDMgMzcuMTU5NyAyNC40MDc5IDM3LjY2MzYgMjUuMjc2QzM4LjQxNzcgMjYuNTc1IDM3LjI2NzIgMjcuNTU0NiAzNS44ODk5IDI4LjcyNzJDMzUuODUzIDI4Ljc1ODYgMzUuODE2IDI4Ljc5MDEgMzUuNzc4OSAyOC44MjE4TDIzLjkyNSAzOS4wMzc3QzIxLjg5MzMgNDAuNzkwMSAyMC40NjYgNDAuMTMxMSAxOS45NjYyIDM4LjI2NTZMMTguMTk1OCAzMS42NTg3QzE3Ljc1ODUgMzAuMDI2NCAxNi4xNjQ2IDI4Ljc0NTYgMTQuMjk3NiAyOS4yNDU5QzExLjk2MzggMjkuODcxMiAxMS43NzQ2IDMyLjU4NzggMTIuMzQ3MyAzNC43MjU0WiIgZmlsbD0iIzA2MEQxNCIvPgo8L3N2Zz4K",
    downloadUrl: {
      registerWebWallet: () => Pa(e)
    }
  };
  return Object.freeze(t);
}
var Hl = Ji;
var Kl = Ji;
var Jl = Ki;
var Ba = he({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
});
var Ya = he({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
});
var Fa = he({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
});
var _a = he({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
});
var Ga = he({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
});
var Za = he({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/tokenpocket-web3-crypto-w/mfgccjchihfkkindfppnaooecgfneiii?hl=en"
  }
});
var Va = he({
  name: "Phantom",
  label: "Phantom",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
var qa = he({
  name: "OKX Wallet",
  label: "OKX Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
  downloadUrl: {
    browserExtension: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
  }
});
var Xa = [
  Wa,
  Ki,
  Va,
  // sorted by name alphabetically
  ...[
    Ba,
    Ya,
    Fa,
    _a,
    Ga,
    Za,
    qa
  ].sort((e, t) => e.name < t.name ? -1 : 1)
];
var $l = he({
  name: pe.ETHOS_WALLET,
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
});
var ef = he({
  name: pe.MORPHIS_WALLET,
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
});
var tf = he({
  name: pe.SPACECY_WALLET,
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
});
var nf = he({
  name: pe.SENSUI_WALLET,
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
});
var rf = he({
  name: pe.ELLI_WALLET,
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
});
var of = he({
  name: pe.FRONTIER_WALLET,
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
});
function Ha(e, t) {
  let n = X.WALLET__CONNECT_ERROR, r = e.message;
  switch (t) {
    case pe.SUI_WALLET:
    case pe.ETHOS_WALLET:
    case pe.GLASS_WALLET:
    case pe.MORPHIS_WALLET:
      r.includes("Permission rejected") && (n = X.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case pe.SUIET_WALLET:
      r.includes("User rejects approval") && (n = X.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case pe.SPACECY_WALLET:
      n = X.WALLET__CONNECT_ERROR__USER_REJECTED;
      break;
    case pe.SURF_WALLET:
      r.includes("The user rejected the request") && (n = X.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
  }
  return {
    code: n,
    message: r,
    details: {
      wallet: t
    }
  };
}
var $i = class {
  constructor(t) {
    this.address = t, this.address = t;
  }
  async verifySignedPersonalMessage(t) {
    try {
      const n = await verifyPersonalMessageSignature(
        ft.from(t.bytes, "base64"),
        t.signature,
        {
          address: this.address
        }
      );
      return true;
    } catch (n) {
      throw new Ee(n == null ? void 0 : n.message, X.WALLET__VERIFY_PERSONAL_MSG_ERROR);
    }
  }
  async verifySignedTransaction(t) {
    try {
      const n = await verifyTransactionSignature(
        ft.from(t.bytes, "base64"),
        t.signature,
        {
          address: this.address
        }
      );
      return true;
    } catch (n) {
      throw new Ee(n == null ? void 0 : n.message, X.WALLET__VERIFY_TRANSACTION_ERROR);
    }
  }
};
async function Ka(e, t) {
  let n;
  if (xn(e, "bytes"))
    n = e.bytes;
  else if (xn(e, "messageBytes"))
    n = e.messageBytes;
  else
    throw new Error(
      "input should be either SuiSignPersonalMessageOutput or SuiSignMessageOutput"
    );
  try {
    return await new $i().verifySignedPersonalMessage({
      bytes: n,
      signature: e.signature
    });
  } catch (r) {
    return console.error("e: ", r), false;
  }
}
function Ja(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
function sf(e) {
  return new TextDecoder().decode(Ja(e));
}
async function $a(e) {
  if (!e)
    throw new _("Cannot serialize empty transaction");
  if (typeof e == "string")
    return e;
  if ("toJSON" in e)
    return await e.toJSON();
  if ("serialize" in e)
    return e.serialize();
  throw new _(
    'Cannot serialize transaction, missing "toJSON" or "serialize" method'
  );
}
async function ec(e) {
  return Transaction.from(await $a(e));
}
var af = class {
  /** Aggregate helper  call once and cache if needed. */
  static detectEnvironment() {
    return {
      isBrowser: this.isBrowser(),
      isMobileBrowser: this.isMobileBrowser(),
      isExtApiSupported: this.isExtApiSupported()
      // isAndroidBrowserThatSupportExt: this.isAndroidBrowserThatSupportExt(),
    };
  }
  /**
   * Check if code is running in a browser environment
   */
  static isBrowser() {
    return typeof globalThis < "u" && "window" in globalThis && "document" in globalThis;
  }
  /**
   * Get navigator object safely
   */
  static getNavigator() {
    return this.isBrowser() && "navigator" in globalThis ? globalThis.navigator : null;
  }
  /**
   * Get window object safely
   */
  static getWindow() {
    return this.isBrowser() && "window" in globalThis ? globalThis.window : null;
  }
  /** Detect whether we're on a mobile browser (handset / small tablet). */
  static isMobileBrowser() {
    if (!this.isBrowser())
      return false;
    try {
      const t = this.getNavigator(), n = this.getWindow();
      if (!t || !n)
        return false;
      if (t.userAgentData && typeof t.userAgentData.mobile < "u")
        return !!t.userAgentData.mobile;
      if (typeof n.matchMedia == "function" && typeof n.screen < "u" && n.matchMedia("(pointer: coarse)").matches && n.screen.width <= 820)
        return true;
      if (typeof t.userAgent == "string")
        return /Mobi|Android|iPhone|iPad|iPod|Windows Phone|BlackBerry/i.test(t.userAgent);
    } catch (t) {
      console.warn("Error detecting mobile browser:", t);
    }
    return false;
  }
  /** Detect whether the Chrome-extension API is exposed to web pages. */
  static isExtApiSupported() {
    if (!this.isBrowser())
      return false;
    try {
      const t = this.getWindow();
      return t ? !!(t.chrome && t.chrome.runtime && typeof t.chrome.runtime.sendMessage == "function") : false;
    } catch (t) {
      return console.warn("Error detecting extension API:", t), false;
    }
  }
  /**
   * Check if a brand info contains a specific keyword
   */
  // private static brandContains(brand: any, keyword: string): boolean {
  //   return typeof brand === 'object' && 
  //          brand !== null && 
  //          typeof brand.brand === 'string' && 
  //          brand.brand.toLowerCase().includes(keyword);
  // }
  /**
   * Detect fork-specific tokens in user agent or brand info
   * @param ua User agent string
   * @param brands Array of brand info objects
   * @returns True if a fork-specific token is found
   */
  // private static hasForkSpecificTokens(ua: string, brands: any[]): boolean {
  //   // Define fork identifiers to check
  //   const forkIdentifiers = ['kiwi', 'yandex', 'cromite'];
  //   // Check if any identifier exists in either UA string or brand info
  //   return forkIdentifiers.some(id => {
  //     const pattern = new RegExp(`\\b${id}\\b`, 'i');
  //     return pattern.test(ua) || brands.some(brand => this.brandContains(brand, id));
  //   });
  // }
  /** Detect Android browsers that allow desktop-style extensions (Kiwi, Yandex, ). */
  // static isAndroidBrowserThatSupportExt(): boolean {
  //   if (!this.isBrowser()) return false;
  //   try {
  //     const navigator = this.getNavigator() as any;
  //     if (!navigator) return false;
  //     const ua = typeof navigator.userAgent === 'string' ? navigator.userAgent : '';
  //     const brands = (navigator.userAgentData && 
  //       Array.isArray(navigator.userAgentData.brands)) 
  //       ? navigator.userAgentData.brands : [];
  //     // Look for fork-specific tokens
  //     const hasForkToken = this.hasForkSpecificTokens(ua, brands);
  //     // return this.browserHasExtensionAPI();
  //     return hasForkToken;
  //   } catch (e) {
  //     console.warn('Error detecting Kiwi-like browser:', e);
  //     return false;
  //   }
  // }
};
var tc = ((e) => (e.DEV_NET = "sui:devnet", e.TEST_NET = "sui:testnet", e.MAIN_NET = "sui:mainnet", e.DEVNET = "sui:devnet", e.TestNET = "sui:testnet", e))(tc || {});
var nc = {
  id: "sui:devnet",
  name: "Sui Devnet",
  rpcUrl: "https://fullnode.devnet.sui.io/"
};
var rc = {
  id: "sui:testnet",
  name: "Sui Testnet",
  rpcUrl: "https://fullnode.testnet.sui.io/"
};
var ic = {
  id: "sui:mainnet",
  name: "Sui Mainnet",
  rpcUrl: "https://rpc.mainnet.sui.io/"
};
var jt = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
};
var oc = [nc, rc, ic];
function ye(e) {
  return `Failed to call ${e}, missing context provider to run within`;
}
var sc = {
  configuredWallets: [],
  detectedWallets: [],
  allAvailableWallets: [],
  chains: [],
  chain: void 0,
  name: void 0,
  adapter: void 0,
  connecting: false,
  connected: false,
  account: void 0,
  status: Ue.DISCONNECTED,
  address: void 0,
  async select() {
    throw new _(ye("select"));
  },
  on() {
    throw new _(ye("on"));
  },
  async disconnect() {
    throw new _(ye("disconnect"));
  },
  getAccounts() {
    throw new _(ye("getAccounts"));
  },
  switchAccount() {
    throw new _(ye("switchAccount"));
  },
  async signTransaction() {
    throw new _(ye("signTransaction"));
  },
  async signAndExecuteTransaction() {
    throw new _(ye("signAndExecuteTransaction"));
  },
  async signPersonalMessage() {
    throw new _(ye("signPersonalMessage"));
  },
  async verifySignedPersonalMessage() {
    throw new _(ye("verifySignedPersonalMessage"));
  },
  async verifySignedTransaction() {
    throw new _(ye("verifySignedTransaction"));
  },
  async reportTransactionEffects() {
    throw new _(ye("reportTransactionEffects"));
  },
  verifySignedMessage() {
    throw new _(ye("verifySignedMessage"));
  },
  async signMessage() {
    throw new _(ye("signMessage"));
  },
  async signTransactionBlock() {
    throw new _(ye("signTransactionBlock"));
  },
  async signAndExecuteTransactionBlock() {
    throw new _(ye("signAndExecuteTransactionBlock"));
  }
};
var eo = (0, import_react.createContext)(sc);
function Xt() {
  return (0, import_react.useContext)(eo);
}
function Dr(e, t) {
  return Dr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Dr(e, t);
}
function Ht(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Dr(e, t);
}
var Kt = function() {
  function e() {
    this.listeners = [];
  }
  var t = e.prototype;
  return t.subscribe = function(r) {
    var o = this, s = r || function() {
    };
    return this.listeners.push(s), this.onSubscribe(), function() {
      o.listeners = o.listeners.filter(function(l) {
        return l !== s;
      }), o.onUnsubscribe();
    };
  }, t.hasListeners = function() {
    return this.listeners.length > 0;
  }, t.onSubscribe = function() {
  }, t.onUnsubscribe = function() {
  }, e;
}();
function S() {
  return S = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, S.apply(null, arguments);
}
var kn = typeof window > "u";
function fe() {
}
function ac(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function wr(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Qn(e) {
  return Array.isArray(e) ? e : [e];
}
function to(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function bn(e, t, n) {
  return Vn(e) ? typeof t == "function" ? S({}, n, {
    queryKey: e,
    queryFn: t
  }) : S({}, t, {
    queryKey: e
  }) : e;
}
function rt(e, t, n) {
  return Vn(e) ? [S({}, t, {
    queryKey: e
  }), n] : [e || {}, t];
}
function cc(e, t) {
  if (e === true && t === true || e == null && t == null)
    return "all";
  if (e === false && t === false)
    return "none";
  var n = e ?? !t;
  return n ? "active" : "inactive";
}
function ni(e, t) {
  var n = e.active, r = e.exact, o = e.fetching, s = e.inactive, l = e.predicate, c = e.queryKey, f = e.stale;
  if (Vn(c)) {
    if (r) {
      if (t.queryHash !== Gr(c, t.options))
        return false;
    } else if (!Pn(t.queryKey, c))
      return false;
  }
  var h = cc(n, s);
  if (h === "none")
    return false;
  if (h !== "all") {
    var M = t.isActive();
    if (h === "active" && !M || h === "inactive" && M)
      return false;
  }
  return !(typeof f == "boolean" && t.isStale() !== f || typeof o == "boolean" && t.isFetching() !== o || l && !l(t));
}
function ri(e, t) {
  var n = e.exact, r = e.fetching, o = e.predicate, s = e.mutationKey;
  if (Vn(s)) {
    if (!t.options.mutationKey)
      return false;
    if (n) {
      if (dt(t.options.mutationKey) !== dt(s))
        return false;
    } else if (!Pn(t.options.mutationKey, s))
      return false;
  }
  return !(typeof r == "boolean" && t.state.status === "loading" !== r || o && !o(t));
}
function Gr(e, t) {
  var n = (t == null ? void 0 : t.queryKeyHashFn) || dt;
  return n(e);
}
function dt(e) {
  var t = Qn(e);
  return uc(t);
}
function uc(e) {
  return JSON.stringify(e, function(t, n) {
    return Er(n) ? Object.keys(n).sort().reduce(function(r, o) {
      return r[o] = n[o], r;
    }, {}) : n;
  });
}
function Pn(e, t) {
  return no(Qn(e), Qn(t));
}
function no(e, t) {
  return e === t ? true : typeof e != typeof t ? false : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(function(n) {
    return !no(e[n], t[n]);
  }) : false;
}
function Wn(e, t) {
  if (e === t)
    return e;
  var n = Array.isArray(e) && Array.isArray(t);
  if (n || Er(e) && Er(t)) {
    for (var r = n ? e.length : Object.keys(e).length, o = n ? t : Object.keys(t), s = o.length, l = n ? [] : {}, c = 0, f = 0; f < s; f++) {
      var h = n ? f : o[f];
      l[h] = Wn(e[h], t[h]), l[h] === e[h] && c++;
    }
    return r === s && c === r ? e : l;
  }
  return t;
}
function lc(e, t) {
  if (e && !t || t && !e)
    return false;
  for (var n in e)
    if (e[n] !== t[n])
      return false;
  return true;
}
function Er(e) {
  if (!ii(e))
    return false;
  var t = e.constructor;
  if (typeof t > "u")
    return true;
  var n = t.prototype;
  return !(!ii(n) || !n.hasOwnProperty("isPrototypeOf"));
}
function ii(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Vn(e) {
  return typeof e == "string" || Array.isArray(e);
}
function fc(e) {
  return new Promise(function(t) {
    setTimeout(t, e);
  });
}
function oi(e) {
  Promise.resolve().then(e).catch(function(t) {
    return setTimeout(function() {
      throw t;
    });
  });
}
function ro() {
  if (typeof AbortController == "function")
    return new AbortController();
}
var dc = function(e) {
  Ht(t, e);
  function t() {
    var r;
    return r = e.call(this) || this, r.setup = function(o) {
      var s;
      if (!kn && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o();
        };
        return window.addEventListener("visibilitychange", l, false), window.addEventListener("focus", l, false), function() {
          window.removeEventListener("visibilitychange", l), window.removeEventListener("focus", l);
        };
      }
    }, r;
  }
  var n = t.prototype;
  return n.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o;
      (o = this.cleanup) == null || o.call(this), this.cleanup = void 0;
    }
  }, n.setEventListener = function(o) {
    var s, l = this;
    this.setup = o, (s = this.cleanup) == null || s.call(this), this.cleanup = o(function(c) {
      typeof c == "boolean" ? l.setFocused(c) : l.onFocus();
    });
  }, n.setFocused = function(o) {
    this.focused = o, o && this.onFocus();
  }, n.onFocus = function() {
    this.listeners.forEach(function(o) {
      o();
    });
  }, n.isFocused = function() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? true : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }, t;
}(Kt);
var Yt = new dc();
var hc = function(e) {
  Ht(t, e);
  function t() {
    var r;
    return r = e.call(this) || this, r.setup = function(o) {
      var s;
      if (!kn && ((s = window) != null && s.addEventListener)) {
        var l = function() {
          return o();
        };
        return window.addEventListener("online", l, false), window.addEventListener("offline", l, false), function() {
          window.removeEventListener("online", l), window.removeEventListener("offline", l);
        };
      }
    }, r;
  }
  var n = t.prototype;
  return n.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, n.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var o;
      (o = this.cleanup) == null || o.call(this), this.cleanup = void 0;
    }
  }, n.setEventListener = function(o) {
    var s, l = this;
    this.setup = o, (s = this.cleanup) == null || s.call(this), this.cleanup = o(function(c) {
      typeof c == "boolean" ? l.setOnline(c) : l.onOnline();
    });
  }, n.setOnline = function(o) {
    this.online = o, o && this.onOnline();
  }, n.onOnline = function() {
    this.listeners.forEach(function(o) {
      o();
    });
  }, n.isOnline = function() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? true : navigator.onLine;
  }, t;
}(Kt);
var Tn = new hc();
function gc(e) {
  return Math.min(1e3 * Math.pow(2, e), 3e4);
}
function Bn(e) {
  return typeof (e == null ? void 0 : e.cancel) == "function";
}
var io = function(t) {
  this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
};
function jn(e) {
  return e instanceof io;
}
var oo = function(t) {
  var n = this, r = false, o, s, l, c;
  this.abort = t.abort, this.cancel = function(A) {
    return o == null ? void 0 : o(A);
  }, this.cancelRetry = function() {
    r = true;
  }, this.continueRetry = function() {
    r = false;
  }, this.continue = function() {
    return s == null ? void 0 : s();
  }, this.failureCount = 0, this.isPaused = false, this.isResolved = false, this.isTransportCancelable = false, this.promise = new Promise(function(A, N) {
    l = A, c = N;
  });
  var f = function(N) {
    n.isResolved || (n.isResolved = true, t.onSuccess == null || t.onSuccess(N), s == null ? void 0 : s(), l(N));
  }, h = function(N) {
    n.isResolved || (n.isResolved = true, t.onError == null || t.onError(N), s == null ? void 0 : s(), c(N));
  }, M = function() {
    return new Promise(function(N) {
      s = N, n.isPaused = true, t.onPause == null || t.onPause();
    }).then(function() {
      s = void 0, n.isPaused = false, t.onContinue == null || t.onContinue();
    });
  }, y = function A() {
    if (!n.isResolved) {
      var N;
      try {
        N = t.fn();
      } catch (m) {
        N = Promise.reject(m);
      }
      o = function(I) {
        if (!n.isResolved && (h(new io(I)), n.abort == null || n.abort(), Bn(N)))
          try {
            N.cancel();
          } catch {
          }
      }, n.isTransportCancelable = Bn(N), Promise.resolve(N).then(f).catch(function(m) {
        var I, b;
        if (!n.isResolved) {
          var E = (I = t.retry) != null ? I : 3, C = (b = t.retryDelay) != null ? b : gc, T = typeof C == "function" ? C(n.failureCount, m) : C, z = E === true || typeof E == "number" && n.failureCount < E || typeof E == "function" && E(n.failureCount, m);
          if (r || !z) {
            h(m);
            return;
          }
          n.failureCount++, t.onFail == null || t.onFail(n.failureCount, m), fc(T).then(function() {
            if (!Yt.isFocused() || !Tn.isOnline())
              return M();
          }).then(function() {
            r ? h(m) : A();
          });
        }
      });
    }
  };
  y();
};
var Mc = function() {
  function e() {
    this.queue = [], this.transactions = 0, this.notifyFn = function(n) {
      n();
    }, this.batchNotifyFn = function(n) {
      n();
    };
  }
  var t = e.prototype;
  return t.batch = function(r) {
    var o;
    this.transactions++;
    try {
      o = r();
    } finally {
      this.transactions--, this.transactions || this.flush();
    }
    return o;
  }, t.schedule = function(r) {
    var o = this;
    this.transactions ? this.queue.push(r) : oi(function() {
      o.notifyFn(r);
    });
  }, t.batchCalls = function(r) {
    var o = this;
    return function() {
      for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++)
        l[c] = arguments[c];
      o.schedule(function() {
        r.apply(void 0, l);
      });
    };
  }, t.flush = function() {
    var r = this, o = this.queue;
    this.queue = [], o.length && oi(function() {
      r.batchNotifyFn(function() {
        o.forEach(function(s) {
          r.notifyFn(s);
        });
      });
    });
  }, t.setNotifyFunction = function(r) {
    this.notifyFn = r;
  }, t.setBatchNotifyFunction = function(r) {
    this.batchNotifyFn = r;
  }, e;
}();
var V = new Mc();
var so = console;
function Yn() {
  return so;
}
function yc(e) {
  so = e;
}
var pc = function() {
  function e(n) {
    this.abortSignalConsumed = false, this.hadObservers = false, this.defaultOptions = n.defaultOptions, this.setOptions(n.options), this.observers = [], this.cache = n.cache, this.queryKey = n.queryKey, this.queryHash = n.queryHash, this.initialState = n.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = n.meta, this.scheduleGc();
  }
  var t = e.prototype;
  return t.setOptions = function(r) {
    var o;
    this.options = S({}, this.defaultOptions, r), this.meta = r == null ? void 0 : r.meta, this.cacheTime = Math.max(this.cacheTime || 0, (o = this.options.cacheTime) != null ? o : 5 * 60 * 1e3);
  }, t.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t.scheduleGc = function() {
    var r = this;
    this.clearGcTimeout(), wr(this.cacheTime) && (this.gcTimeout = setTimeout(function() {
      r.optionalRemove();
    }, this.cacheTime));
  }, t.clearGcTimeout = function() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }, t.optionalRemove = function() {
    this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this));
  }, t.setData = function(r, o) {
    var s, l, c = this.state.data, f = ac(r, c);
    return (s = (l = this.options).isDataEqual) != null && s.call(l, c, f) ? f = c : this.options.structuralSharing !== false && (f = Wn(c, f)), this.dispatch({
      data: f,
      type: "success",
      dataUpdatedAt: o == null ? void 0 : o.updatedAt
    }), f;
  }, t.setState = function(r, o) {
    this.dispatch({
      type: "setState",
      state: r,
      setStateOptions: o
    });
  }, t.cancel = function(r) {
    var o, s = this.promise;
    return (o = this.retryer) == null || o.cancel(r), s ? s.then(fe).catch(fe) : Promise.resolve();
  }, t.destroy = function() {
    this.clearGcTimeout(), this.cancel({
      silent: true
    });
  }, t.reset = function() {
    this.destroy(), this.setState(this.initialState);
  }, t.isActive = function() {
    return this.observers.some(function(r) {
      return r.options.enabled !== false;
    });
  }, t.isFetching = function() {
    return this.state.isFetching;
  }, t.isStale = function() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(r) {
      return r.getCurrentResult().isStale;
    });
  }, t.isStaleByTime = function(r) {
    return r === void 0 && (r = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !to(this.state.dataUpdatedAt, r);
  }, t.onFocus = function() {
    var r, o = this.observers.find(function(s) {
      return s.shouldFetchOnWindowFocus();
    });
    o && o.refetch(), (r = this.retryer) == null || r.continue();
  }, t.onOnline = function() {
    var r, o = this.observers.find(function(s) {
      return s.shouldFetchOnReconnect();
    });
    o && o.refetch(), (r = this.retryer) == null || r.continue();
  }, t.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && (this.observers.push(r), this.hadObservers = true, this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: r
    }));
  }, t.removeObserver = function(r) {
    this.observers.indexOf(r) !== -1 && (this.observers = this.observers.filter(function(o) {
      return o !== r;
    }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
      revert: true
    }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: r
    }));
  }, t.getObserversCount = function() {
    return this.observers.length;
  }, t.invalidate = function() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }, t.fetch = function(r, o) {
    var s = this, l, c, f;
    if (this.state.isFetching) {
      if (this.state.dataUpdatedAt && (o == null ? void 0 : o.cancelRefetch))
        this.cancel({
          silent: true
        });
      else if (this.promise) {
        var h;
        return (h = this.retryer) == null || h.continueRetry(), this.promise;
      }
    }
    if (r && this.setOptions(r), !this.options.queryFn) {
      var M = this.observers.find(function(C) {
        return C.options.queryFn;
      });
      M && this.setOptions(M.options);
    }
    var y = Qn(this.queryKey), A = ro(), N = {
      queryKey: y,
      pageParam: void 0,
      meta: this.meta
    };
    Object.defineProperty(N, "signal", {
      enumerable: true,
      get: function() {
        if (A)
          return s.abortSignalConsumed = true, A.signal;
      }
    });
    var m = function() {
      return s.options.queryFn ? (s.abortSignalConsumed = false, s.options.queryFn(N)) : Promise.reject("Missing queryFn");
    }, I = {
      fetchOptions: o,
      options: this.options,
      queryKey: y,
      state: this.state,
      fetchFn: m,
      meta: this.meta
    };
    if ((l = this.options.behavior) != null && l.onFetch) {
      var b;
      (b = this.options.behavior) == null || b.onFetch(I);
    }
    if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((c = I.fetchOptions) == null ? void 0 : c.meta)) {
      var E;
      this.dispatch({
        type: "fetch",
        meta: (E = I.fetchOptions) == null ? void 0 : E.meta
      });
    }
    return this.retryer = new oo({
      fn: I.fetchFn,
      abort: A == null || (f = A.abort) == null ? void 0 : f.bind(A),
      onSuccess: function(T) {
        s.setData(T), s.cache.config.onSuccess == null || s.cache.config.onSuccess(T, s), s.cacheTime === 0 && s.optionalRemove();
      },
      onError: function(T) {
        jn(T) && T.silent || s.dispatch({
          type: "error",
          error: T
        }), jn(T) || (s.cache.config.onError == null || s.cache.config.onError(T, s), Yn().error(T)), s.cacheTime === 0 && s.optionalRemove();
      },
      onFail: function() {
        s.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        s.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        s.dispatch({
          type: "continue"
        });
      },
      retry: I.options.retry,
      retryDelay: I.options.retryDelay
    }), this.promise = this.retryer.promise, this.promise;
  }, t.dispatch = function(r) {
    var o = this;
    this.state = this.reducer(this.state, r), V.batch(function() {
      o.observers.forEach(function(s) {
        s.onQueryUpdate(r);
      }), o.cache.notify({
        query: o,
        type: "queryUpdated",
        action: r
      });
    });
  }, t.getDefaultState = function(r) {
    var o = typeof r.initialData == "function" ? r.initialData() : r.initialData, s = typeof r.initialData < "u", l = s ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0, c = typeof o < "u";
    return {
      data: o,
      dataUpdateCount: 0,
      dataUpdatedAt: c ? l ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchMeta: null,
      isFetching: false,
      isInvalidated: false,
      isPaused: false,
      status: c ? "success" : "idle"
    };
  }, t.reducer = function(r, o) {
    var s, l;
    switch (o.type) {
      case "failed":
        return S({}, r, {
          fetchFailureCount: r.fetchFailureCount + 1
        });
      case "pause":
        return S({}, r, {
          isPaused: true
        });
      case "continue":
        return S({}, r, {
          isPaused: false
        });
      case "fetch":
        return S({}, r, {
          fetchFailureCount: 0,
          fetchMeta: (s = o.meta) != null ? s : null,
          isFetching: true,
          isPaused: false
        }, !r.dataUpdatedAt && {
          error: null,
          status: "loading"
        });
      case "success":
        return S({}, r, {
          data: o.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: (l = o.dataUpdatedAt) != null ? l : Date.now(),
          error: null,
          fetchFailureCount: 0,
          isFetching: false,
          isInvalidated: false,
          isPaused: false,
          status: "success"
        });
      case "error":
        var c = o.error;
        return jn(c) && c.revert && this.revertState ? S({}, this.revertState) : S({}, r, {
          error: c,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          isFetching: false,
          isPaused: false,
          status: "error"
        });
      case "invalidate":
        return S({}, r, {
          isInvalidated: true
        });
      case "setState":
        return S({}, r, o.state);
      default:
        return r;
    }
  }, e;
}();
var Nc = function(e) {
  Ht(t, e);
  function t(r) {
    var o;
    return o = e.call(this) || this, o.config = r || {}, o.queries = [], o.queriesMap = {}, o;
  }
  var n = t.prototype;
  return n.build = function(o, s, l) {
    var c, f = s.queryKey, h = (c = s.queryHash) != null ? c : Gr(f, s), M = this.get(h);
    return M || (M = new pc({
      cache: this,
      queryKey: f,
      queryHash: h,
      options: o.defaultQueryOptions(s),
      state: l,
      defaultOptions: o.getQueryDefaults(f),
      meta: s.meta
    }), this.add(M)), M;
  }, n.add = function(o) {
    this.queriesMap[o.queryHash] || (this.queriesMap[o.queryHash] = o, this.queries.push(o), this.notify({
      type: "queryAdded",
      query: o
    }));
  }, n.remove = function(o) {
    var s = this.queriesMap[o.queryHash];
    s && (o.destroy(), this.queries = this.queries.filter(function(l) {
      return l !== o;
    }), s === o && delete this.queriesMap[o.queryHash], this.notify({
      type: "queryRemoved",
      query: o
    }));
  }, n.clear = function() {
    var o = this;
    V.batch(function() {
      o.queries.forEach(function(s) {
        o.remove(s);
      });
    });
  }, n.get = function(o) {
    return this.queriesMap[o];
  }, n.getAll = function() {
    return this.queries;
  }, n.find = function(o, s) {
    var l = rt(o, s), c = l[0];
    return typeof c.exact > "u" && (c.exact = true), this.queries.find(function(f) {
      return ni(c, f);
    });
  }, n.findAll = function(o, s) {
    var l = rt(o, s), c = l[0];
    return Object.keys(c).length > 0 ? this.queries.filter(function(f) {
      return ni(c, f);
    }) : this.queries;
  }, n.notify = function(o) {
    var s = this;
    V.batch(function() {
      s.listeners.forEach(function(l) {
        l(o);
      });
    });
  }, n.onFocus = function() {
    var o = this;
    V.batch(function() {
      o.queries.forEach(function(s) {
        s.onFocus();
      });
    });
  }, n.onOnline = function() {
    var o = this;
    V.batch(function() {
      o.queries.forEach(function(s) {
        s.onOnline();
      });
    });
  }, t;
}(Kt);
var Ac = function() {
  function e(n) {
    this.options = S({}, n.defaultOptions, n.options), this.mutationId = n.mutationId, this.mutationCache = n.mutationCache, this.observers = [], this.state = n.state || Ic(), this.meta = n.meta;
  }
  var t = e.prototype;
  return t.setState = function(r) {
    this.dispatch({
      type: "setState",
      state: r
    });
  }, t.addObserver = function(r) {
    this.observers.indexOf(r) === -1 && this.observers.push(r);
  }, t.removeObserver = function(r) {
    this.observers = this.observers.filter(function(o) {
      return o !== r;
    });
  }, t.cancel = function() {
    return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(fe).catch(fe)) : Promise.resolve();
  }, t.continue = function() {
    return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();
  }, t.execute = function() {
    var r = this, o, s = this.state.status === "loading", l = Promise.resolve();
    return s || (this.dispatch({
      type: "loading",
      variables: this.options.variables
    }), l = l.then(function() {
      r.mutationCache.config.onMutate == null || r.mutationCache.config.onMutate(r.state.variables, r);
    }).then(function() {
      return r.options.onMutate == null ? void 0 : r.options.onMutate(r.state.variables);
    }).then(function(c) {
      c !== r.state.context && r.dispatch({
        type: "loading",
        context: c,
        variables: r.state.variables
      });
    })), l.then(function() {
      return r.executeMutation();
    }).then(function(c) {
      o = c, r.mutationCache.config.onSuccess == null || r.mutationCache.config.onSuccess(o, r.state.variables, r.state.context, r);
    }).then(function() {
      return r.options.onSuccess == null ? void 0 : r.options.onSuccess(o, r.state.variables, r.state.context);
    }).then(function() {
      return r.options.onSettled == null ? void 0 : r.options.onSettled(o, null, r.state.variables, r.state.context);
    }).then(function() {
      return r.dispatch({
        type: "success",
        data: o
      }), o;
    }).catch(function(c) {
      return r.mutationCache.config.onError == null || r.mutationCache.config.onError(c, r.state.variables, r.state.context, r), Yn().error(c), Promise.resolve().then(function() {
        return r.options.onError == null ? void 0 : r.options.onError(c, r.state.variables, r.state.context);
      }).then(function() {
        return r.options.onSettled == null ? void 0 : r.options.onSettled(void 0, c, r.state.variables, r.state.context);
      }).then(function() {
        throw r.dispatch({
          type: "error",
          error: c
        }), c;
      });
    });
  }, t.executeMutation = function() {
    var r = this, o;
    return this.retryer = new oo({
      fn: function() {
        return r.options.mutationFn ? r.options.mutationFn(r.state.variables) : Promise.reject("No mutationFn found");
      },
      onFail: function() {
        r.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        r.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        r.dispatch({
          type: "continue"
        });
      },
      retry: (o = this.options.retry) != null ? o : 0,
      retryDelay: this.options.retryDelay
    }), this.retryer.promise;
  }, t.dispatch = function(r) {
    var o = this;
    this.state = vc(this.state, r), V.batch(function() {
      o.observers.forEach(function(s) {
        s.onMutationUpdate(r);
      }), o.mutationCache.notify(o);
    });
  }, e;
}();
function Ic() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
function vc(e, t) {
  switch (t.type) {
    case "failed":
      return S({}, e, {
        failureCount: e.failureCount + 1
      });
    case "pause":
      return S({}, e, {
        isPaused: true
      });
    case "continue":
      return S({}, e, {
        isPaused: false
      });
    case "loading":
      return S({}, e, {
        context: t.context,
        data: void 0,
        error: null,
        isPaused: false,
        status: "loading",
        variables: t.variables
      });
    case "success":
      return S({}, e, {
        data: t.data,
        error: null,
        status: "success",
        isPaused: false
      });
    case "error":
      return S({}, e, {
        data: void 0,
        error: t.error,
        failureCount: e.failureCount + 1,
        isPaused: false,
        status: "error"
      });
    case "setState":
      return S({}, e, t.state);
    default:
      return e;
  }
}
var mc = function(e) {
  Ht(t, e);
  function t(r) {
    var o;
    return o = e.call(this) || this, o.config = r || {}, o.mutations = [], o.mutationId = 0, o;
  }
  var n = t.prototype;
  return n.build = function(o, s, l) {
    var c = new Ac({
      mutationCache: this,
      mutationId: ++this.mutationId,
      options: o.defaultMutationOptions(s),
      state: l,
      defaultOptions: s.mutationKey ? o.getMutationDefaults(s.mutationKey) : void 0,
      meta: s.meta
    });
    return this.add(c), c;
  }, n.add = function(o) {
    this.mutations.push(o), this.notify(o);
  }, n.remove = function(o) {
    this.mutations = this.mutations.filter(function(s) {
      return s !== o;
    }), o.cancel(), this.notify(o);
  }, n.clear = function() {
    var o = this;
    V.batch(function() {
      o.mutations.forEach(function(s) {
        o.remove(s);
      });
    });
  }, n.getAll = function() {
    return this.mutations;
  }, n.find = function(o) {
    return typeof o.exact > "u" && (o.exact = true), this.mutations.find(function(s) {
      return ri(o, s);
    });
  }, n.findAll = function(o) {
    return this.mutations.filter(function(s) {
      return ri(o, s);
    });
  }, n.notify = function(o) {
    var s = this;
    V.batch(function() {
      s.listeners.forEach(function(l) {
        l(o);
      });
    });
  }, n.onFocus = function() {
    this.resumePausedMutations();
  }, n.onOnline = function() {
    this.resumePausedMutations();
  }, n.resumePausedMutations = function() {
    var o = this.mutations.filter(function(s) {
      return s.state.isPaused;
    });
    return V.batch(function() {
      return o.reduce(function(s, l) {
        return s.then(function() {
          return l.continue().catch(fe);
        });
      }, Promise.resolve());
    });
  }, t;
}(Kt);
function Dc() {
  return {
    onFetch: function(t) {
      t.fetchFn = function() {
        var n, r, o, s, l, c, f = (n = t.fetchOptions) == null || (r = n.meta) == null ? void 0 : r.refetchPage, h = (o = t.fetchOptions) == null || (s = o.meta) == null ? void 0 : s.fetchMore, M = h == null ? void 0 : h.pageParam, y = (h == null ? void 0 : h.direction) === "forward", A = (h == null ? void 0 : h.direction) === "backward", N = ((l = t.state.data) == null ? void 0 : l.pages) || [], m = ((c = t.state.data) == null ? void 0 : c.pageParams) || [], I = ro(), b = I == null ? void 0 : I.signal, E = m, C = false, T = t.options.queryFn || function() {
          return Promise.reject("Missing queryFn");
        }, z = function(De, Re, Ie, qe) {
          return E = qe ? [Re].concat(E) : [].concat(E, [Re]), qe ? [Ie].concat(De) : [].concat(De, [Ie]);
        }, L = function(De, Re, Ie, qe) {
          if (C)
            return Promise.reject("Cancelled");
          if (typeof Ie > "u" && !Re && De.length)
            return Promise.resolve(De);
          var Le = {
            queryKey: t.queryKey,
            signal: b,
            pageParam: Ie,
            meta: t.meta
          }, ue = T(Le), Ke = Promise.resolve(ue).then(function(w) {
            return z(De, Ie, w, qe);
          });
          if (Bn(ue)) {
            var G = Ke;
            G.cancel = ue.cancel;
          }
          return Ke;
        }, U;
        if (!N.length)
          U = L([]);
        else if (y) {
          var $ = typeof M < "u", k = $ ? M : si(t.options, N);
          U = L(N, $, k);
        } else if (A) {
          var ie = typeof M < "u", oe = ie ? M : wc(t.options, N);
          U = L(N, ie, oe, true);
        } else
          (function() {
            E = [];
            var je = typeof t.options.getNextPageParam > "u", De = f && N[0] ? f(N[0], 0, N) : true;
            U = De ? L([], je, m[0]) : Promise.resolve(z([], m[0], N[0]));
            for (var Re = function(Le) {
              U = U.then(function(ue) {
                var Ke = f && N[Le] ? f(N[Le], Le, N) : true;
                if (Ke) {
                  var G = je ? m[Le] : si(t.options, ue);
                  return L(ue, je, G);
                }
                return Promise.resolve(z(ue, m[Le], N[Le]));
              });
            }, Ie = 1; Ie < N.length; Ie++)
              Re(Ie);
          })();
        var Te = U.then(function(je) {
          return {
            pages: je,
            pageParams: E
          };
        }), ze = Te;
        return ze.cancel = function() {
          C = true, I == null ? void 0 : I.abort(), Bn(U) && U.cancel();
        }, Te;
      };
    }
  };
}
function si(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t);
}
function wc(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t);
}
var Ec = function() {
  function e(n) {
    n === void 0 && (n = {}), this.queryCache = n.queryCache || new Nc(), this.mutationCache = n.mutationCache || new mc(), this.defaultOptions = n.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];
  }
  var t = e.prototype;
  return t.mount = function() {
    var r = this;
    this.unsubscribeFocus = Yt.subscribe(function() {
      Yt.isFocused() && Tn.isOnline() && (r.mutationCache.onFocus(), r.queryCache.onFocus());
    }), this.unsubscribeOnline = Tn.subscribe(function() {
      Yt.isFocused() && Tn.isOnline() && (r.mutationCache.onOnline(), r.queryCache.onOnline());
    });
  }, t.unmount = function() {
    var r, o;
    (r = this.unsubscribeFocus) == null || r.call(this), (o = this.unsubscribeOnline) == null || o.call(this);
  }, t.isFetching = function(r, o) {
    var s = rt(r, o), l = s[0];
    return l.fetching = true, this.queryCache.findAll(l).length;
  }, t.isMutating = function(r) {
    return this.mutationCache.findAll(S({}, r, {
      fetching: true
    })).length;
  }, t.getQueryData = function(r, o) {
    var s;
    return (s = this.queryCache.find(r, o)) == null ? void 0 : s.state.data;
  }, t.getQueriesData = function(r) {
    return this.getQueryCache().findAll(r).map(function(o) {
      var s = o.queryKey, l = o.state, c = l.data;
      return [s, c];
    });
  }, t.setQueryData = function(r, o, s) {
    var l = bn(r), c = this.defaultQueryOptions(l);
    return this.queryCache.build(this, c).setData(o, s);
  }, t.setQueriesData = function(r, o, s) {
    var l = this;
    return V.batch(function() {
      return l.getQueryCache().findAll(r).map(function(c) {
        var f = c.queryKey;
        return [f, l.setQueryData(f, o, s)];
      });
    });
  }, t.getQueryState = function(r, o) {
    var s;
    return (s = this.queryCache.find(r, o)) == null ? void 0 : s.state;
  }, t.removeQueries = function(r, o) {
    var s = rt(r, o), l = s[0], c = this.queryCache;
    V.batch(function() {
      c.findAll(l).forEach(function(f) {
        c.remove(f);
      });
    });
  }, t.resetQueries = function(r, o, s) {
    var l = this, c = rt(r, o, s), f = c[0], h = c[1], M = this.queryCache, y = S({}, f, {
      active: true
    });
    return V.batch(function() {
      return M.findAll(f).forEach(function(A) {
        A.reset();
      }), l.refetchQueries(y, h);
    });
  }, t.cancelQueries = function(r, o, s) {
    var l = this, c = rt(r, o, s), f = c[0], h = c[1], M = h === void 0 ? {} : h;
    typeof M.revert > "u" && (M.revert = true);
    var y = V.batch(function() {
      return l.queryCache.findAll(f).map(function(A) {
        return A.cancel(M);
      });
    });
    return Promise.all(y).then(fe).catch(fe);
  }, t.invalidateQueries = function(r, o, s) {
    var l, c, f, h = this, M = rt(r, o, s), y = M[0], A = M[1], N = S({}, y, {
      // if filters.refetchActive is not provided and filters.active is explicitly false,
      // e.g. invalidateQueries({ active: false }), we don't want to refetch active queries
      active: (l = (c = y.refetchActive) != null ? c : y.active) != null ? l : true,
      inactive: (f = y.refetchInactive) != null ? f : false
    });
    return V.batch(function() {
      return h.queryCache.findAll(y).forEach(function(m) {
        m.invalidate();
      }), h.refetchQueries(N, A);
    });
  }, t.refetchQueries = function(r, o, s) {
    var l = this, c = rt(r, o, s), f = c[0], h = c[1], M = V.batch(function() {
      return l.queryCache.findAll(f).map(function(A) {
        return A.fetch(void 0, S({}, h, {
          meta: {
            refetchPage: f == null ? void 0 : f.refetchPage
          }
        }));
      });
    }), y = Promise.all(M).then(fe);
    return (h == null ? void 0 : h.throwOnError) || (y = y.catch(fe)), y;
  }, t.fetchQuery = function(r, o, s) {
    var l = bn(r, o, s), c = this.defaultQueryOptions(l);
    typeof c.retry > "u" && (c.retry = false);
    var f = this.queryCache.build(this, c);
    return f.isStaleByTime(c.staleTime) ? f.fetch(c) : Promise.resolve(f.state.data);
  }, t.prefetchQuery = function(r, o, s) {
    return this.fetchQuery(r, o, s).then(fe).catch(fe);
  }, t.fetchInfiniteQuery = function(r, o, s) {
    var l = bn(r, o, s);
    return l.behavior = Dc(), this.fetchQuery(l);
  }, t.prefetchInfiniteQuery = function(r, o, s) {
    return this.fetchInfiniteQuery(r, o, s).then(fe).catch(fe);
  }, t.cancelMutations = function() {
    var r = this, o = V.batch(function() {
      return r.mutationCache.getAll().map(function(s) {
        return s.cancel();
      });
    });
    return Promise.all(o).then(fe).catch(fe);
  }, t.resumePausedMutations = function() {
    return this.getMutationCache().resumePausedMutations();
  }, t.executeMutation = function(r) {
    return this.mutationCache.build(this, r).execute();
  }, t.getQueryCache = function() {
    return this.queryCache;
  }, t.getMutationCache = function() {
    return this.mutationCache;
  }, t.getDefaultOptions = function() {
    return this.defaultOptions;
  }, t.setDefaultOptions = function(r) {
    this.defaultOptions = r;
  }, t.setQueryDefaults = function(r, o) {
    var s = this.queryDefaults.find(function(l) {
      return dt(r) === dt(l.queryKey);
    });
    s ? s.defaultOptions = o : this.queryDefaults.push({
      queryKey: r,
      defaultOptions: o
    });
  }, t.getQueryDefaults = function(r) {
    var o;
    return r ? (o = this.queryDefaults.find(function(s) {
      return Pn(r, s.queryKey);
    })) == null ? void 0 : o.defaultOptions : void 0;
  }, t.setMutationDefaults = function(r, o) {
    var s = this.mutationDefaults.find(function(l) {
      return dt(r) === dt(l.mutationKey);
    });
    s ? s.defaultOptions = o : this.mutationDefaults.push({
      mutationKey: r,
      defaultOptions: o
    });
  }, t.getMutationDefaults = function(r) {
    var o;
    return r ? (o = this.mutationDefaults.find(function(s) {
      return Pn(r, s.mutationKey);
    })) == null ? void 0 : o.defaultOptions : void 0;
  }, t.defaultQueryOptions = function(r) {
    if (r == null ? void 0 : r._defaulted)
      return r;
    var o = S({}, this.defaultOptions.queries, this.getQueryDefaults(r == null ? void 0 : r.queryKey), r, {
      _defaulted: true
    });
    return !o.queryHash && o.queryKey && (o.queryHash = Gr(o.queryKey, o)), o;
  }, t.defaultQueryObserverOptions = function(r) {
    return this.defaultQueryOptions(r);
  }, t.defaultMutationOptions = function(r) {
    return (r == null ? void 0 : r._defaulted) ? r : S({}, this.defaultOptions.mutations, this.getMutationDefaults(r == null ? void 0 : r.mutationKey), r, {
      _defaulted: true
    });
  }, t.clear = function() {
    this.queryCache.clear(), this.mutationCache.clear();
  }, e;
}();
var bc = function(e) {
  Ht(t, e);
  function t(r, o) {
    var s;
    return s = e.call(this) || this, s.client = r, s.options = o, s.trackedProps = [], s.selectError = null, s.bindMethods(), s.setOptions(o), s;
  }
  var n = t.prototype;
  return n.bindMethods = function() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }, n.onSubscribe = function() {
    this.listeners.length === 1 && (this.currentQuery.addObserver(this), ai(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }, n.onUnsubscribe = function() {
    this.listeners.length || this.destroy();
  }, n.shouldFetchOnReconnect = function() {
    return br(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }, n.shouldFetchOnWindowFocus = function() {
    return br(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }, n.destroy = function() {
    this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this);
  }, n.setOptions = function(o, s) {
    var l = this.options, c = this.currentQuery;
    if (this.options = this.client.defaultQueryObserverOptions(o), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = l.queryKey), this.updateQuery();
    var f = this.hasListeners();
    f && ci(this.currentQuery, c, this.options, l) && this.executeFetch(), this.updateResult(s), f && (this.currentQuery !== c || this.options.enabled !== l.enabled || this.options.staleTime !== l.staleTime) && this.updateStaleTimeout();
    var h = this.computeRefetchInterval();
    f && (this.currentQuery !== c || this.options.enabled !== l.enabled || h !== this.currentRefetchInterval) && this.updateRefetchInterval(h);
  }, n.getOptimisticResult = function(o) {
    var s = this.client.defaultQueryObserverOptions(o), l = this.client.getQueryCache().build(this.client, s);
    return this.createResult(l, s);
  }, n.getCurrentResult = function() {
    return this.currentResult;
  }, n.trackResult = function(o, s) {
    var l = this, c = {}, f = function(M) {
      l.trackedProps.includes(M) || l.trackedProps.push(M);
    };
    return Object.keys(o).forEach(function(h) {
      Object.defineProperty(c, h, {
        configurable: false,
        enumerable: true,
        get: function() {
          return f(h), o[h];
        }
      });
    }), (s.useErrorBoundary || s.suspense) && f("error"), c;
  }, n.getNextResult = function(o) {
    var s = this;
    return new Promise(function(l, c) {
      var f = s.subscribe(function(h) {
        h.isFetching || (f(), h.isError && (o == null ? void 0 : o.throwOnError) ? c(h.error) : l(h));
      });
    });
  }, n.getCurrentQuery = function() {
    return this.currentQuery;
  }, n.remove = function() {
    this.client.getQueryCache().remove(this.currentQuery);
  }, n.refetch = function(o) {
    return this.fetch(S({}, o, {
      meta: {
        refetchPage: o == null ? void 0 : o.refetchPage
      }
    }));
  }, n.fetchOptimistic = function(o) {
    var s = this, l = this.client.defaultQueryObserverOptions(o), c = this.client.getQueryCache().build(this.client, l);
    return c.fetch().then(function() {
      return s.createResult(c, l);
    });
  }, n.fetch = function(o) {
    var s = this;
    return this.executeFetch(o).then(function() {
      return s.updateResult(), s.currentResult;
    });
  }, n.executeFetch = function(o) {
    this.updateQuery();
    var s = this.currentQuery.fetch(this.options, o);
    return (o == null ? void 0 : o.throwOnError) || (s = s.catch(fe)), s;
  }, n.updateStaleTimeout = function() {
    var o = this;
    if (this.clearStaleTimeout(), !(kn || this.currentResult.isStale || !wr(this.options.staleTime))) {
      var s = to(this.currentResult.dataUpdatedAt, this.options.staleTime), l = s + 1;
      this.staleTimeoutId = setTimeout(function() {
        o.currentResult.isStale || o.updateResult();
      }, l);
    }
  }, n.computeRefetchInterval = function() {
    var o;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (o = this.options.refetchInterval) != null ? o : false;
  }, n.updateRefetchInterval = function(o) {
    var s = this;
    this.clearRefetchInterval(), this.currentRefetchInterval = o, !(kn || this.options.enabled === false || !wr(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(function() {
      (s.options.refetchIntervalInBackground || Yt.isFocused()) && s.executeFetch();
    }, this.currentRefetchInterval));
  }, n.updateTimers = function() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }, n.clearTimers = function() {
    this.clearStaleTimeout(), this.clearRefetchInterval();
  }, n.clearStaleTimeout = function() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }, n.clearRefetchInterval = function() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }, n.createResult = function(o, s) {
    var l = this.currentQuery, c = this.options, f = this.currentResult, h = this.currentResultState, M = this.currentResultOptions, y = o !== l, A = y ? o.state : this.currentQueryInitialState, N = y ? this.currentResult : this.previousQueryResult, m = o.state, I = m.dataUpdatedAt, b = m.error, E = m.errorUpdatedAt, C = m.isFetching, T = m.status, z = false, L = false, U;
    if (s.optimisticResults) {
      var $ = this.hasListeners(), k = !$ && ai(o, s), ie = $ && ci(o, l, s, c);
      (k || ie) && (C = true, I || (T = "loading"));
    }
    if (s.keepPreviousData && !m.dataUpdateCount && (N == null ? void 0 : N.isSuccess) && T !== "error")
      U = N.data, I = N.dataUpdatedAt, T = N.status, z = true;
    else if (s.select && typeof m.data < "u")
      if (f && m.data === (h == null ? void 0 : h.data) && s.select === this.selectFn)
        U = this.selectResult;
      else
        try {
          this.selectFn = s.select, U = s.select(m.data), s.structuralSharing !== false && (U = Wn(f == null ? void 0 : f.data, U)), this.selectResult = U, this.selectError = null;
        } catch (ze) {
          Yn().error(ze), this.selectError = ze;
        }
    else
      U = m.data;
    if (typeof s.placeholderData < "u" && typeof U > "u" && (T === "loading" || T === "idle")) {
      var oe;
      if ((f == null ? void 0 : f.isPlaceholderData) && s.placeholderData === (M == null ? void 0 : M.placeholderData))
        oe = f.data;
      else if (oe = typeof s.placeholderData == "function" ? s.placeholderData() : s.placeholderData, s.select && typeof oe < "u")
        try {
          oe = s.select(oe), s.structuralSharing !== false && (oe = Wn(f == null ? void 0 : f.data, oe)), this.selectError = null;
        } catch (ze) {
          Yn().error(ze), this.selectError = ze;
        }
      typeof oe < "u" && (T = "success", U = oe, L = true);
    }
    this.selectError && (b = this.selectError, U = this.selectResult, E = Date.now(), T = "error");
    var Te = {
      status: T,
      isLoading: T === "loading",
      isSuccess: T === "success",
      isError: T === "error",
      isIdle: T === "idle",
      data: U,
      dataUpdatedAt: I,
      error: b,
      errorUpdatedAt: E,
      failureCount: m.fetchFailureCount,
      errorUpdateCount: m.errorUpdateCount,
      isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
      isFetchedAfterMount: m.dataUpdateCount > A.dataUpdateCount || m.errorUpdateCount > A.errorUpdateCount,
      isFetching: C,
      isRefetching: C && T !== "loading",
      isLoadingError: T === "error" && m.dataUpdatedAt === 0,
      isPlaceholderData: L,
      isPreviousData: z,
      isRefetchError: T === "error" && m.dataUpdatedAt !== 0,
      isStale: Zr(o, s),
      refetch: this.refetch,
      remove: this.remove
    };
    return Te;
  }, n.shouldNotifyListeners = function(o, s) {
    if (!s)
      return true;
    var l = this.options, c = l.notifyOnChangeProps, f = l.notifyOnChangePropsExclusions;
    if (!c && !f || c === "tracked" && !this.trackedProps.length)
      return true;
    var h = c === "tracked" ? this.trackedProps : c;
    return Object.keys(o).some(function(M) {
      var y = M, A = o[y] !== s[y], N = h == null ? void 0 : h.some(function(I) {
        return I === M;
      }), m = f == null ? void 0 : f.some(function(I) {
        return I === M;
      });
      return A && !m && (!h || N);
    });
  }, n.updateResult = function(o) {
    var s = this.currentResult;
    if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !lc(this.currentResult, s)) {
      var l = {
        cache: true
      };
      (o == null ? void 0 : o.listeners) !== false && this.shouldNotifyListeners(this.currentResult, s) && (l.listeners = true), this.notify(S({}, l, o));
    }
  }, n.updateQuery = function() {
    var o = this.client.getQueryCache().build(this.client, this.options);
    if (o !== this.currentQuery) {
      var s = this.currentQuery;
      this.currentQuery = o, this.currentQueryInitialState = o.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (s == null ? void 0 : s.removeObserver(this), o.addObserver(this));
    }
  }, n.onQueryUpdate = function(o) {
    var s = {};
    o.type === "success" ? s.onSuccess = true : o.type === "error" && !jn(o.error) && (s.onError = true), this.updateResult(s), this.hasListeners() && this.updateTimers();
  }, n.notify = function(o) {
    var s = this;
    V.batch(function() {
      o.onSuccess ? (s.options.onSuccess == null || s.options.onSuccess(s.currentResult.data), s.options.onSettled == null || s.options.onSettled(s.currentResult.data, null)) : o.onError && (s.options.onError == null || s.options.onError(s.currentResult.error), s.options.onSettled == null || s.options.onSettled(void 0, s.currentResult.error)), o.listeners && s.listeners.forEach(function(l) {
        l(s.currentResult);
      }), o.cache && s.client.getQueryCache().notify({
        query: s.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }, t;
}(Kt);
function Tc(e, t) {
  return t.enabled !== false && !e.state.dataUpdatedAt && !(e.state.status === "error" && t.retryOnMount === false);
}
function ai(e, t) {
  return Tc(e, t) || e.state.dataUpdatedAt > 0 && br(e, t, t.refetchOnMount);
}
function br(e, t, n) {
  if (t.enabled !== false) {
    var r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== false && Zr(e, t);
  }
  return false;
}
function ci(e, t, n, r) {
  return n.enabled !== false && (e !== t || r.enabled === false) && (!n.suspense || e.state.status !== "error") && Zr(e, n);
}
function Zr(e, t) {
  return e.isStaleByTime(t.staleTime);
}
var jc = import_react_dom.default.unstable_batchedUpdates;
V.setBatchNotifyFunction(jc);
var Lc = console;
yc(Lc);
var ui = import_react.default.createContext(void 0);
var ao = import_react.default.createContext(false);
function co(e) {
  return e && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = ui), window.ReactQueryClientContext) : ui;
}
var Sc = function() {
  var t = import_react.default.useContext(co(import_react.default.useContext(ao)));
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
};
var Cc = function(t) {
  var n = t.client, r = t.contextSharing, o = r === void 0 ? false : r, s = t.children;
  import_react.default.useEffect(function() {
    return n.mount(), function() {
      n.unmount();
    };
  }, [n]);
  var l = co(o);
  return (0, import_jsx_runtime.jsx)(ao.Provider, {
    value: o,
    children: (0, import_jsx_runtime.jsx)(l.Provider, {
      value: n,
      children: s
    })
  });
};
function Oc() {
  var e = false;
  return {
    clearReset: function() {
      e = false;
    },
    reset: function() {
      e = true;
    },
    isReset: function() {
      return e;
    }
  };
}
var xc = import_react.default.createContext(Oc());
var zc = function() {
  return import_react.default.useContext(xc);
};
function Rc(e, t, n) {
  return typeof t == "function" ? t.apply(void 0, n) : typeof t == "boolean" ? t : !!e;
}
function Uc(e, t) {
  var n = import_react.default.useRef(false), r = import_react.default.useState(0), o = r[1], s = Sc(), l = zc(), c = s.defaultQueryObserverOptions(e);
  c.optimisticResults = true, c.onError && (c.onError = V.batchCalls(c.onError)), c.onSuccess && (c.onSuccess = V.batchCalls(c.onSuccess)), c.onSettled && (c.onSettled = V.batchCalls(c.onSettled)), c.suspense && (typeof c.staleTime != "number" && (c.staleTime = 1e3), c.cacheTime === 0 && (c.cacheTime = 1)), (c.suspense || c.useErrorBoundary) && (l.isReset() || (c.retryOnMount = false));
  var f = import_react.default.useState(function() {
    return new t(s, c);
  }), h = f[0], M = h.getOptimisticResult(c);
  if (import_react.default.useEffect(function() {
    n.current = true, l.clearReset();
    var y = h.subscribe(V.batchCalls(function() {
      n.current && o(function(A) {
        return A + 1;
      });
    }));
    return h.updateResult(), function() {
      n.current = false, y();
    };
  }, [l, h]), import_react.default.useEffect(function() {
    h.setOptions(c, {
      listeners: false
    });
  }, [c, h]), c.suspense && M.isLoading)
    throw h.fetchOptimistic(c).then(function(y) {
      var A = y.data;
      c.onSuccess == null || c.onSuccess(A), c.onSettled == null || c.onSettled(A, null);
    }).catch(function(y) {
      l.clearReset(), c.onError == null || c.onError(y), c.onSettled == null || c.onSettled(void 0, y);
    });
  if (M.isError && !l.isReset() && !M.isFetching && Rc(c.suspense, c.useErrorBoundary, [M.error, h.getCurrentQuery()]))
    throw M.error;
  return c.notifyOnChangeProps === "tracked" && (M = h.trackResult(M, c)), M;
}
function kc(e, t, n) {
  var r = bn(e, t, n);
  return Uc(r, bc);
}
var uo = ((e) => (e.COIN_BALANCE = "SUIET_COIN_BALANCE", e))(uo || {});
function Qc(e, t) {
  const n = new URLSearchParams(t);
  return e + "?" + n.toString();
}
function Pc(e) {
  const t = Xt();
  return e ? (0, import_react.useMemo)(() => t.chains.find((n) => n.id === e), [e, t.chains]) : t.chain;
}
function Wc(e) {
  var _a2;
  const t = Xt(), {
    address: n = t.address,
    typeArg: r = SUI_TYPE_ARG,
    chainId: o = (_a2 = t.chain) == null ? void 0 : _a2.id
  } = e || {}, s = Pc(o), l = Qc(uo.COIN_BALANCE, {
    address: n,
    typeArg: r,
    chainId: o
  }), c = (0, import_react.useCallback)(() => !n || !s ? BigInt(0) : new Rs(n, {
    chainRpcUrl: s.rpcUrl
  }).getCoinBalance(r), [s, n]);
  return kc(l, c, {
    initialData: BigInt(0)
  });
}
function Bc(e) {
  const {
    typeArg: t,
    chainId: n
  } = e || {}, r = Wc({
    typeArg: t,
    chainId: n
  });
  return Object.assign(r, {
    // legacy interfaces
    balance: r.data,
    loading: r.isLoading
  });
}
function cf(e) {
  return (0, import_react.useMemo)(() => new SuiClient({ url: e }), [e]);
}
var lo = (0, import_react.createContext)(
  new SuiClient({
    url: jt.rpcUrl
  })
);
var uf = () => (0, import_react.useContext)(lo);
function Pe(e) {
  return Array.isArray(e) && e.length > 0;
}
function Yc() {
  const e = (0, import_react.useRef)(null), [t, n] = (0, import_react.useState)([]);
  return (0, import_react.useEffect)(() => {
    e.current || (e.current = new aa(), e.current.activate());
    const r = e.current.getDetectedWalletAdapters();
    return n(r), e.current.subscribe((o) => {
      n(o);
    }), () => {
      e.current && (e.current.deactivate(), e.current = null);
    };
  }, []), {
    data: t
  };
}
function Fc(e) {
  (0, import_react.useLayoutEffect)(() => {
    const t = [];
    return Pe(e) && e.forEach((n) => {
      var _a2;
      if (n.type === Pr.WEB && ((_a2 = n.downloadUrl) == null ? void 0 : _a2.registerWebWallet)) {
        const r = n.downloadUrl.registerWebWallet();
        t.push(r);
      }
    }), () => {
      Pe(t) && t.forEach((n) => {
        n();
      });
    };
  }, [e]);
}
var _c = (e) => {
  Fc(e);
  const { data: t } = Yc(), n = (l, c) => !!((c == null ? void 0 : c.id) && c.id === (l == null ? void 0 : l.id) || (c == null ? void 0 : c.name) && c.name === (l == null ? void 0 : l.name)), r = (0, import_react.useMemo)(() => Pe(e) ? Pe(t) ? e.map((l) => {
    const c = t.find(
      (f) => n(l, f)
    );
    return c ? {
      ...l,
      adapter: c,
      installed: true
    } : {
      ...l,
      adapter: void 0,
      installed: false
    };
  }) : e.map(
    (l) => ({
      ...l,
      adapter: void 0,
      installed: false
    })
  ) : [], [e, t]), o = (0, import_react.useMemo)(() => Pe(t) ? t.filter((l) => !e.find((c) => c.name === l.name)).map((l) => ({
    name: l.name,
    label: l.name,
    adapter: l,
    installed: true,
    iconUrl: l.icon,
    downloadUrl: {
      browserExtension: ""
      // no need to know
    }
  })) : [], [e, t]);
  return {
    allAvailableWallets: (0, import_react.useMemo)(() => [...r, ...o].filter(
      (l) => l.installed
    ), [r, o]),
    configuredWallets: r,
    detectedWallets: o
  };
};
var Tr = class {
  constructor() {
    if (!window)
      throw new Error("window not found: storage should be used in browser env");
  }
  get length() {
    return window.localStorage.length;
  }
  setItem(t, n) {
    try {
      let r = JSON.stringify(n);
      return window.localStorage.setItem(t, r);
    } catch (r) {
      throw new Error("stringify data failed when setItem: " + r.message);
    }
  }
  getItem(t) {
    const n = window.localStorage.getItem(t);
    if (!n)
      return n;
    try {
      return JSON.parse(n);
    } catch (r) {
      throw new Error("parse data failed when getItem: " + r.message);
    }
  }
  removeItem(t) {
    return window.localStorage.removeItem(t);
  }
  clear() {
    return window.localStorage.clear();
  }
};
var Fn = ((e) => (e.LAST_CONNECT_WALLET_NAME = "WK__LAST_CONNECT_WALLET_NAME", e))(Fn || {});
function Gc(e, t, n, r) {
  const o = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (!r || o.current || !Pe(n) || t !== Ue.DISCONNECTED)
      return;
    const l = new Tr().getItem(
      Fn.LAST_CONNECT_WALLET_NAME
    );
    l && n.find((c) => c.name == l) && e(l).then(() => {
      o.current = true;
    }).catch((c) => {
    });
  }, [n]);
}
function Zc(e) {
  var _a2, _b, _c2;
  return ((_c2 = (_b = (_a2 = e == null ? void 0 : e.accounts) == null ? void 0 : _a2[0]) == null ? void 0 : _b.chains) == null ? void 0 : _c2[0]) ? e.accounts[0].chains[0] : "sui:unknown";
}
var lf = (e) => {
  const {
    defaultWallets: t = Xa,
    chains: n = oc,
    autoConnect: r = true,
    children: o
  } = e, {
    allAvailableWallets: s,
    configuredWallets: l,
    detectedWallets: c
  } = _c(t), [f, h] = (0, import_react.useState)(), [M, y] = (0, import_react.useState)(Ue.DISCONNECTED), [A, N] = (0, import_react.useState)(() => Pe(n) ? n[0] : jt), m = (0, import_react.useMemo)(() => new SuiClient({
    url: A.rpcUrl
  }), [A]), I = (0, import_react.useRef)([]), b = (w, x) => w && x === Ue.CONNECTED, [E, C] = (0, import_react.useState)(void 0), T = (w, x) => {
    if (!b(w, x))
      throw new _("Failed to call function, wallet not connected");
  }, z = (0, import_react.useCallback)(() => (T(f, M), f), [f, M]), L = (0, import_react.useCallback)(() => {
    const w = z();
    if (!E)
      throw new _("no active account connected");
    return [w, E];
  }, [z, E]), U = (0, import_react.useCallback)(async (w, x) => {
    if (!w)
      throw new _("param adapter is missing");
    y(Ue.CONNECTING);
    try {
      const O = await w.connect(x);
      if (Pe(O == null ? void 0 : O.accounts)) {
        const ae = Zc(O), ge = n.find((Be) => Be.id === ae);
        N(ge ?? jt);
      }
      return h(w), y(Ue.CONNECTED), C(O.accounts[0]), new Tr().setItem(Fn.LAST_CONNECT_WALLET_NAME, w.name), O;
    } catch (O) {
      throw h(void 0), C(void 0), y(Ue.DISCONNECTED), O;
    }
  }, []), $ = (0, import_react.useCallback)(async () => {
    T(f, M);
    const w = f;
    Pe(I.current) && (I.current.forEach((O) => {
      try {
        O();
      } catch (ee) {
        console.error("error when clearing wallet listener", ee.message);
      }
    }), I.current = []), new Tr().removeItem(Fn.LAST_CONNECT_WALLET_NAME);
    try {
      w.hasFeature(q.STANDARD__DISCONNECT) && await w.disconnect();
    } finally {
      h(void 0), C(void 0), y(Ue.DISCONNECTED), N((n == null ? void 0 : n[0]) ?? jt);
    }
  }, [f, M]), k = (0, import_react.useCallback)(async (w) => {
    if (b(f, M)) {
      if (w === f.name)
        return;
      await $();
    }
    const x = s.find((O) => O.name === w);
    if (!x) {
      const O = s.map((ee) => ee.name);
      throw new _(`select failed: wallet ${w} is not available, all wallets are listed here: [${O.join(", ")}]`);
    }
    await U(x.adapter);
  }, [f, M, s]), ie = (0, import_react.useCallback)((w, x) => {
    const ee = z().on("change", (ae) => {
      var _a2, _b;
      if (w === "change") {
        x(ae);
        return;
      }
      if (ae.chains && w === "chainChange") {
        x({
          chain: (_a2 = ae.chains) == null ? void 0 : _a2[0]
        });
        return;
      }
      if (ae.accounts && w === "accountChange") {
        x({
          account: (_b = ae.accounts) == null ? void 0 : _b[0]
        });
        return;
      }
      if (ae.features && w === "featureChange") {
        x({
          features: ae.features
        });
        return;
      }
    });
    return I.current.push(ee), ee;
  }, [z]), oe = (0, import_react.useCallback)(() => z().accounts, [z]), Te = (0, import_react.useCallback)(async (w) => {
    const O = z().accounts.find((ee) => ee.address === w);
    if (!O)
      throw new _(`account not found with address: ${w}`);
    return C(O), O;
  }, [z]), ze = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    return await x.signAndExecuteTransactionBlock({
      account: O,
      chain: A.id,
      transactionBlock: w.transactionBlock
    });
  }, [L, A]), je = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    let ee, ae = await ec(w.transaction);
    if (x.hasFeature(q.SUI__SIGN_TRANSACTION))
      ee = await x.signTransaction({
        transaction: ae,
        account: O,
        chain: A.id
      });
    else if (x.hasFeature(q.SUI__SIGN_TRANSACTION_BLOCK)) {
      const ge = await x.signTransactionBlock({
        transactionBlock: ae,
        account: O,
        chain: A.id
      });
      ee = {
        signature: ge.signature,
        bytes: ge.transactionBlockBytes
      };
    } else
      throw new Qi(`${q.SUI__SIGN_TRANSACTION} or ${q.SUI__SIGN_TRANSACTION_BLOCK}`);
    return ee;
  }, [L, A]), De = (0, import_react.useCallback)(async (w, x) => {
    const [O, ee] = L(), ae = async (Je) => typeof (x == null ? void 0 : x.execute) == "function" ? await x.execute(Je) : await m.executeTransactionBlock({
      transactionBlock: Je.bytes,
      signature: Je.signature,
      options: {
        showRawEffects: true
      }
    }), ge = await je({
      transaction: w.transaction
    }), {
      digest: Be,
      effects: at,
      ...ct
    } = await ae(ge);
    let pt;
    if (at && "bcs" in at)
      pt = at == null ? void 0 : at.bcs;
    else if (ct && "rawEffects" in ct)
      pt = toB64(new Uint8Array(ct.rawEffects));
    else
      throw new Error("effects or rawEffects not found in the execution result");
    if (O.hasFeature(q.SUI__REPORT_TRANSACTION_EFFECTS))
      try {
        await O.reportTransactionEffects({
          effects: pt,
          account: ee,
          chain: A.id
        });
      } catch (Je) {
        console.warn("Failed to report transaction effects:", Je);
      }
    return {
      bytes: ge.bytes,
      signature: ge.signature,
      digest: Be,
      effects: pt,
      ...ct
    };
  }, [L, A, m]), Re = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    return await x.reportTransactionEffects({
      account: O,
      chain: A.id,
      ...w
    });
  }, [L, A]), Ie = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    return await x.signTransactionBlock({
      account: O,
      chain: A.id,
      transactionBlock: w.transactionBlock
    });
  }, [L, A]), qe = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    return await x.signMessage({
      account: O,
      message: w.message
    });
  }, [L]), Le = (0, import_react.useCallback)(async (w) => {
    const [x, O] = L();
    return await x.signPersonalMessage({
      account: O,
      message: w.message
    });
  }, [L]), ue = (0, import_react.useMemo)(() => E ? new $i(E.address) : null, [E]), Ke = (0, import_react.useCallback)(async (w) => {
    if (!ue)
      throw new _("Please connect to an account first");
    return await ue.verifySignedPersonalMessage(w);
  }, [ue]), G = (0, import_react.useCallback)(async (w) => {
    if (!ue)
      throw new _("Please connect to an account first");
    return await ue.verifySignedTransaction(w);
  }, [ue]);
  return Gc(k, M, s, r), (0, import_react.useEffect)(() => {
    if (!f || M !== "connected")
      return;
    const w = ie("chainChange", (x) => {
      if (x.chain === A.id)
        return;
      const O = n.find((ee) => ee.id === x.chain);
      if (!O) {
        N(jt);
        return;
      }
      N(O);
    });
    return () => {
      w();
    };
  }, [f, M, A, n, ie]), (0, import_jsx_runtime.jsx)(eo.Provider, {
    value: {
      name: f == null ? void 0 : f.name,
      chains: n,
      chain: A,
      allAvailableWallets: s,
      configuredWallets: l,
      detectedWallets: c,
      adapter: f,
      status: M,
      connecting: M === Ue.CONNECTING,
      connected: M === Ue.CONNECTED,
      account: E,
      address: E == null ? void 0 : E.address,
      select: k,
      disconnect: $,
      on: ie,
      getAccounts: oe,
      switchAccount: Te,
      signPersonalMessage: Le,
      signTransaction: je,
      signAndExecuteTransaction: De,
      reportTransactionEffects: Re,
      signMessage: qe,
      signTransactionBlock: Ie,
      signAndExecuteTransactionBlock: ze,
      verifySignedPersonalMessage: Ke,
      verifySignedTransaction: G,
      verifySignedMessage: Ka
    },
    children: (0, import_jsx_runtime.jsx)(Cc, {
      client: new Ec(),
      children: (0, import_jsx_runtime.jsx)(lo.Provider, {
        value: m,
        children: o
      })
    })
  });
};
function Vc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fo = { exports: {} };
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], o = 0; o < arguments.length; o++) {
        var s = arguments[o];
        if (s) {
          var l = typeof s;
          if (l === "string" || l === "number")
            r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var c = n.apply(null, s);
              c && r.push(c);
            }
          } else if (l === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue;
            }
            for (var f in s)
              t.call(s, f) && s[f] && r.push(f);
          }
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(fo);
var qc = fo.exports;
var Gt = Vc(qc);
function it(e, t, { checkForDefaultPrevented: n = true } = {}) {
  return function(o) {
    if (e == null ? void 0 : e(o), n === false || !o.defaultPrevented)
      return t == null ? void 0 : t(o);
  };
}
function Xc(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function ho(...e) {
  return (t) => e.forEach(
    (n) => Xc(n, t)
  );
}
function xt(...e) {
  return (0, import_react.useCallback)(ho(...e), e);
}
function Hc(e, t) {
  const n = (0, import_react.createContext)(t);
  function r(s) {
    const { children: l, ...c } = s, f = (0, import_react.useMemo)(
      () => c,
      Object.values(c)
    );
    return (0, import_react.createElement)(n.Provider, {
      value: f
    }, l);
  }
  function o(s) {
    const l = (0, import_react.useContext)(n);
    if (l)
      return l;
    if (t !== void 0)
      return t;
    throw new Error(`\`${s}\` must be used within \`${e}\``);
  }
  return r.displayName = e + "Provider", [
    r,
    o
  ];
}
function Kc(e, t = []) {
  let n = [];
  function r(s, l) {
    const c = (0, import_react.createContext)(l), f = n.length;
    n = [
      ...n,
      l
    ];
    function h(y) {
      const { scope: A, children: N, ...m } = y, I = (A == null ? void 0 : A[e][f]) || c, b = (0, import_react.useMemo)(
        () => m,
        Object.values(m)
      );
      return (0, import_react.createElement)(I.Provider, {
        value: b
      }, N);
    }
    function M(y, A) {
      const N = (A == null ? void 0 : A[e][f]) || c, m = (0, import_react.useContext)(N);
      if (m)
        return m;
      if (l !== void 0)
        return l;
      throw new Error(`\`${y}\` must be used within \`${s}\``);
    }
    return h.displayName = s + "Provider", [
      h,
      M
    ];
  }
  const o = () => {
    const s = n.map((l) => (0, import_react.createContext)(l));
    return function(c) {
      const f = (c == null ? void 0 : c[e]) || s;
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${e}`]: {
            ...c,
            [e]: f
          }
        }),
        [
          c,
          f
        ]
      );
    };
  };
  return o.scopeName = e, [
    r,
    Jc(o, ...t)
  ];
}
function Jc(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const n = () => {
    const r = e.map(
      (o) => ({
        useScope: o(),
        scopeName: o.scopeName
      })
    );
    return function(s) {
      const l = r.reduce((c, { useScope: f, scopeName: h }) => {
        const y = f(s)[`__scope${h}`];
        return {
          ...c,
          ...y
        };
      }, {});
      return (0, import_react.useMemo)(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
var jr = (globalThis == null ? void 0 : globalThis.document) ? import_react.useLayoutEffect : () => {
};
var $c = Q.useId || (() => {
});
var eu = 0;
function or(e) {
  const [t, n] = Q.useState($c());
  return jr(() => {
    n(
      (r) => r ?? String(eu++)
    );
  }, [
    e
  ]), e || (t ? `radix-${t}` : "");
}
function Mt(e) {
  const t = (0, import_react.useRef)(e);
  return (0, import_react.useEffect)(() => {
    t.current = e;
  }), (0, import_react.useMemo)(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
function tu({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, o] = nu({
    defaultProp: t,
    onChange: n
  }), s = e !== void 0, l = s ? e : r, c = Mt(n), f = (0, import_react.useCallback)((h) => {
    if (s) {
      const y = typeof h == "function" ? h(e) : h;
      y !== e && c(y);
    } else
      o(h);
  }, [
    s,
    e,
    o,
    c
  ]);
  return [
    l,
    f
  ];
}
function nu({ defaultProp: e, onChange: t }) {
  const n = (0, import_react.useState)(e), [r] = n, o = (0, import_react.useRef)(r), s = Mt(t);
  return (0, import_react.useEffect)(() => {
    o.current !== r && (s(r), o.current = r);
  }, [
    r,
    o,
    s
  ]), n;
}
var Vr = (0, import_react.forwardRef)((e, t) => {
  const { children: n, ...r } = e, o = import_react.Children.toArray(n), s = o.find(iu);
  if (s) {
    const l = s.props.children, c = o.map((f) => f === s ? import_react.Children.count(l) > 1 ? import_react.Children.only(null) : (0, import_react.isValidElement)(l) ? l.props.children : null : f);
    return (0, import_react.createElement)(Lr, S({}, r, {
      ref: t
    }), (0, import_react.isValidElement)(l) ? (0, import_react.cloneElement)(l, void 0, c) : null);
  }
  return (0, import_react.createElement)(Lr, S({}, r, {
    ref: t
  }), n);
});
Vr.displayName = "Slot";
var Lr = (0, import_react.forwardRef)((e, t) => {
  const { children: n, ...r } = e;
  return (0, import_react.isValidElement)(n) ? (0, import_react.cloneElement)(n, {
    ...ou(r, n.props),
    ref: ho(t, n.ref)
  }) : import_react.Children.count(n) > 1 ? import_react.Children.only(null) : null;
});
Lr.displayName = "SlotClone";
var ru = ({ children: e }) => (0, import_react.createElement)(import_react.Fragment, null, e);
function iu(e) {
  return (0, import_react.isValidElement)(e) && e.type === ru;
}
function ou(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const o = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? o && s ? n[r] = (...c) => {
      s(...c), o(...c);
    } : o && (n[r] = o) : r === "style" ? n[r] = {
      ...o,
      ...s
    } : r === "className" && (n[r] = [
      o,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
var su = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var yt = su.reduce((e, t) => {
  const n = (0, import_react.forwardRef)((r, o) => {
    const { asChild: s, ...l } = r, c = s ? Vr : t;
    return (0, import_react.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []), (0, import_react.createElement)(c, S({}, l, {
      ref: o
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function au(e, t) {
  e && (0, import_react_dom.flushSync)(
    () => e.dispatchEvent(t)
  );
}
function cu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mt(e);
  (0, import_react.useEffect)(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r), () => t.removeEventListener("keydown", r);
  }, [
    n,
    t
  ]);
}
var Sr = "dismissableLayer.update";
var uu = "dismissableLayer.pointerDownOutside";
var lu = "dismissableLayer.focusOutside";
var li;
var fu = (0, import_react.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var du = (0, import_react.forwardRef)((e, t) => {
  var n;
  const { disableOutsidePointerEvents: r = false, onEscapeKeyDown: o, onPointerDownOutside: s, onFocusOutside: l, onInteractOutside: c, onDismiss: f, ...h } = e, M = (0, import_react.useContext)(fu), [y, A] = (0, import_react.useState)(null), N = (n = y == null ? void 0 : y.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, m] = (0, import_react.useState)({}), I = xt(
    t,
    (k) => A(k)
  ), b = Array.from(M.layers), [E] = [
    ...M.layersWithOutsidePointerEventsDisabled
  ].slice(-1), C = b.indexOf(E), T = y ? b.indexOf(y) : -1, z = M.layersWithOutsidePointerEventsDisabled.size > 0, L = T >= C, U = hu((k) => {
    const ie = k.target, oe = [
      ...M.branches
    ].some(
      (Te) => Te.contains(ie)
    );
    !L || oe || (s == null ? void 0 : s(k), c == null ? void 0 : c(k), k.defaultPrevented || (f == null ? void 0 : f()));
  }, N), $ = gu((k) => {
    const ie = k.target;
    [
      ...M.branches
    ].some(
      (Te) => Te.contains(ie)
    ) || (l == null ? void 0 : l(k), c == null ? void 0 : c(k), k.defaultPrevented || (f == null ? void 0 : f()));
  }, N);
  return cu((k) => {
    T === M.layers.size - 1 && (o == null ? void 0 : o(k), !k.defaultPrevented && f && (k.preventDefault(), f()));
  }, N), (0, import_react.useEffect)(() => {
    if (y)
      return r && (M.layersWithOutsidePointerEventsDisabled.size === 0 && (li = N.body.style.pointerEvents, N.body.style.pointerEvents = "none"), M.layersWithOutsidePointerEventsDisabled.add(y)), M.layers.add(y), fi(), () => {
        r && M.layersWithOutsidePointerEventsDisabled.size === 1 && (N.body.style.pointerEvents = li);
      };
  }, [
    y,
    N,
    r,
    M
  ]), (0, import_react.useEffect)(() => () => {
    y && (M.layers.delete(y), M.layersWithOutsidePointerEventsDisabled.delete(y), fi());
  }, [
    y,
    M
  ]), (0, import_react.useEffect)(() => {
    const k = () => m({});
    return document.addEventListener(Sr, k), () => document.removeEventListener(Sr, k);
  }, []), (0, import_react.createElement)(yt.div, S({}, h, {
    ref: I,
    style: {
      pointerEvents: z ? L ? "auto" : "none" : void 0,
      ...e.style
    },
    onFocusCapture: it(e.onFocusCapture, $.onFocusCapture),
    onBlurCapture: it(e.onBlurCapture, $.onBlurCapture),
    onPointerDownCapture: it(e.onPointerDownCapture, U.onPointerDownCapture)
  }));
});
function hu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mt(e), r = (0, import_react.useRef)(false), o = (0, import_react.useRef)(() => {
  });
  return (0, import_react.useEffect)(() => {
    const s = (c) => {
      if (c.target && !r.current) {
        let h = function() {
          go(uu, n, f, {
            discrete: true
          });
        };
        const f = {
          originalEvent: c
        };
        c.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = h, t.addEventListener("click", o.current, {
          once: true
        })) : h();
      }
      r.current = false;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", o.current);
    };
  }, [
    t,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = true
  };
}
function gu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mt(e), r = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(() => {
    const o = (s) => {
      s.target && !r.current && go(lu, n, {
        originalEvent: s
      }, {
        discrete: false
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [
    t,
    n
  ]), {
    onFocusCapture: () => r.current = true,
    onBlurCapture: () => r.current = false
  };
}
function fi() {
  const e = new CustomEvent(Sr);
  document.dispatchEvent(e);
}
function go(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, s = new CustomEvent(e, {
    bubbles: false,
    cancelable: true,
    detail: n
  });
  t && o.addEventListener(e, t, {
    once: true
  }), r ? au(o, s) : o.dispatchEvent(s);
}
var sr = "focusScope.autoFocusOnMount";
var ar = "focusScope.autoFocusOnUnmount";
var di = {
  bubbles: false,
  cancelable: true
};
var Mu = (0, import_react.forwardRef)((e, t) => {
  const { loop: n = false, trapped: r = false, onMountAutoFocus: o, onUnmountAutoFocus: s, ...l } = e, [c, f] = (0, import_react.useState)(null), h = Mt(o), M = Mt(s), y = (0, import_react.useRef)(null), A = xt(
    t,
    (I) => f(I)
  ), N = (0, import_react.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react.useEffect)(() => {
    if (r) {
      let I = function(E) {
        if (N.paused || !c)
          return;
        const C = E.target;
        c.contains(C) ? y.current = C : lt(y.current, {
          select: true
        });
      }, b = function(E) {
        N.paused || !c || c.contains(E.relatedTarget) || lt(y.current, {
          select: true
        });
      };
      return document.addEventListener("focusin", I), document.addEventListener("focusout", b), () => {
        document.removeEventListener("focusin", I), document.removeEventListener("focusout", b);
      };
    }
  }, [
    r,
    c,
    N.paused
  ]), (0, import_react.useEffect)(() => {
    if (c) {
      gi.add(N);
      const I = document.activeElement;
      if (!c.contains(I)) {
        const E = new CustomEvent(sr, di);
        c.addEventListener(sr, h), c.dispatchEvent(E), E.defaultPrevented || (yu(vu(Mo(c)), {
          select: true
        }), document.activeElement === I && lt(c));
      }
      return () => {
        c.removeEventListener(sr, h), setTimeout(() => {
          const E = new CustomEvent(ar, di);
          c.addEventListener(ar, M), c.dispatchEvent(E), E.defaultPrevented || lt(I ?? document.body, {
            select: true
          }), c.removeEventListener(ar, M), gi.remove(N);
        }, 0);
      };
    }
  }, [
    c,
    h,
    M,
    N
  ]);
  const m = (0, import_react.useCallback)((I) => {
    if (!n && !r || N.paused)
      return;
    const b = I.key === "Tab" && !I.altKey && !I.ctrlKey && !I.metaKey, E = document.activeElement;
    if (b && E) {
      const C = I.currentTarget, [T, z] = pu(C);
      T && z ? !I.shiftKey && E === z ? (I.preventDefault(), n && lt(T, {
        select: true
      })) : I.shiftKey && E === T && (I.preventDefault(), n && lt(z, {
        select: true
      })) : E === C && I.preventDefault();
    }
  }, [
    n,
    r,
    N.paused
  ]);
  return (0, import_react.createElement)(yt.div, S({
    tabIndex: -1
  }, l, {
    ref: A,
    onKeyDown: m
  }));
});
function yu(e, { select: t = false } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (lt(r, {
      select: t
    }), document.activeElement !== n)
      return;
}
function pu(e) {
  const t = Mo(e), n = hi(t, e), r = hi(t.reverse(), e);
  return [
    n,
    r
  ];
}
function Mo(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}
function hi(e, t) {
  for (const n of e)
    if (!Nu(n, {
      upTo: t
    }))
      return n;
}
function Nu(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return true;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return false;
    if (getComputedStyle(e).display === "none")
      return true;
    e = e.parentElement;
  }
  return false;
}
function Au(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function lt(e, { select: t = false } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({
      preventScroll: true
    }), e !== n && Au(e) && t && e.select();
  }
}
var gi = Iu();
function Iu() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null ? void 0 : n.pause()), e = Mi(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Mi(e, t), (n = e[0]) === null || n === void 0 || n.resume();
    }
  };
}
function Mi(e, t) {
  const n = [
    ...e
  ], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function vu(e) {
  return e.filter(
    (t) => t.tagName !== "A"
  );
}
var mu = (0, import_react.forwardRef)((e, t) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...o } = e;
  return r ? import_react_dom.default.createPortal((0, import_react.createElement)(yt.div, S({}, o, {
    ref: t
  })), r) : null;
});
function Du(e, t) {
  return (0, import_react.useReducer)((n, r) => {
    const o = t[n][r];
    return o ?? n;
  }, e);
}
var qn = (e) => {
  const { present: t, children: n } = e, r = wu(t), o = typeof n == "function" ? n({
    present: r.isPresent
  }) : import_react.Children.only(n), s = xt(r.ref, o.ref);
  return typeof n == "function" || r.isPresent ? (0, import_react.cloneElement)(o, {
    ref: s
  }) : null;
};
qn.displayName = "Presence";
function wu(e) {
  const [t, n] = (0, import_react.useState)(), r = (0, import_react.useRef)({}), o = (0, import_react.useRef)(e), s = (0, import_react.useRef)("none"), l = e ? "mounted" : "unmounted", [c, f] = Du(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return (0, import_react.useEffect)(() => {
    const h = en(r.current);
    s.current = c === "mounted" ? h : "none";
  }, [
    c
  ]), jr(() => {
    const h = r.current, M = o.current;
    if (M !== e) {
      const A = s.current, N = en(h);
      e ? f("MOUNT") : N === "none" || (h == null ? void 0 : h.display) === "none" ? f("UNMOUNT") : f(M && A !== N ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [
    e,
    f
  ]), jr(() => {
    if (t) {
      const h = (y) => {
        const N = en(r.current).includes(y.animationName);
        y.target === t && N && (0, import_react_dom.flushSync)(
          () => f("ANIMATION_END")
        );
      }, M = (y) => {
        y.target === t && (s.current = en(r.current));
      };
      return t.addEventListener("animationstart", M), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        t.removeEventListener("animationstart", M), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      f("ANIMATION_END");
  }, [
    t,
    f
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(c),
    ref: (0, import_react.useCallback)((h) => {
      h && (r.current = getComputedStyle(h)), n(h);
    }, [])
  };
}
function en(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
var cr = 0;
function Eu() {
  (0, import_react.useEffect)(() => {
    var e, t;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e = n[0]) !== null && e !== void 0 ? e : yi()), document.body.insertAdjacentElement("beforeend", (t = n[1]) !== null && t !== void 0 ? t : yi()), cr++, () => {
      cr === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), cr--;
    };
  }, []);
}
function yi() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var Ge = function() {
  return Ge = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, Ge.apply(this, arguments);
};
function yo(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function bu(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, o = t.length, s; r < o; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var Ln = "right-scroll-bar-position";
var Sn = "width-before-scroll-bar";
var Tu = "with-scroll-bars-hidden";
var ju = "--removed-body-scroll-bar-size";
function ur(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Lu(e, t) {
  var n = (0, import_react.useState)(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Su = typeof window < "u" ? Q.useLayoutEffect : Q.useEffect;
var pi = /* @__PURE__ */ new WeakMap();
function Cu(e, t) {
  var n = Lu(null, function(r) {
    return e.forEach(function(o) {
      return ur(o, r);
    });
  });
  return Su(function() {
    var r = pi.get(n);
    if (r) {
      var o = new Set(r), s = new Set(e), l = n.current;
      o.forEach(function(c) {
        s.has(c) || ur(c, null);
      }), s.forEach(function(c) {
        o.has(c) || ur(c, l);
      });
    }
    pi.set(n, e);
  }, [e]), n;
}
function Ou(e) {
  return e;
}
function xu(e, t) {
  t === void 0 && (t = Ou);
  var n = [], r = false, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var l = t(s, r);
      return n.push(l), function() {
        n = n.filter(function(c) {
          return c !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = true; n.length; ) {
        var l = n;
        n = [], l.forEach(s);
      }
      n = {
        push: function(c) {
          return s(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = true;
      var l = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(s), l = n;
      }
      var f = function() {
        var M = l;
        l = [], M.forEach(s);
      }, h = function() {
        return Promise.resolve().then(f);
      };
      h(), n = {
        push: function(M) {
          l.push(M), h();
        },
        filter: function(M) {
          return l = l.filter(M), n;
        }
      };
    }
  };
  return o;
}
function zu(e) {
  e === void 0 && (e = {});
  var t = xu(null);
  return t.options = Ge({ async: true, ssr: false }, e), t;
}
var po = function(e) {
  var t = e.sideCar, n = yo(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return (0, import_jsx_runtime.jsx)(r, {
    ...Ge({}, n)
  });
};
po.isSideCarExport = true;
function Ru(e, t) {
  return e.useMedium(t), po;
}
var No = zu();
var lr = function() {
};
var Xn = Q.forwardRef(function(e, t) {
  var n = Q.useRef(null), r = Q.useState({
    onScrollCapture: lr,
    onWheelCapture: lr,
    onTouchMoveCapture: lr
  }), o = r[0], s = r[1], l = e.forwardProps, c = e.children, f = e.className, h = e.removeScrollBar, M = e.enabled, y = e.shards, A = e.sideCar, N = e.noIsolation, m = e.inert, I = e.allowPinchZoom, b = e.as, E = b === void 0 ? "div" : b, C = yo(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), T = A, z = Cu([n, t]), L = Ge(Ge({}, C), o);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [M && (0, import_jsx_runtime.jsx)(T, {
      sideCar: No,
      removeScrollBar: h,
      shards: y,
      noIsolation: N,
      inert: m,
      setCallbacks: s,
      allowPinchZoom: !!I,
      lockRef: n
    }), l ? Q.cloneElement(Q.Children.only(c), Ge(Ge({}, L), {
      ref: z
    })) : (0, import_jsx_runtime.jsx)(E, {
      ...Ge({}, L, {
        className: f,
        ref: z
      }),
      children: c
    })]
  });
});
Xn.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
Xn.classNames = {
  fullWidth: Sn,
  zeroRight: Ln
};
var Uu = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function ku() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Uu();
  return t && e.setAttribute("nonce", t), e;
}
function Qu(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Pu(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Wu = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = ku()) && (Qu(t, n), Pu(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
};
var Bu = function() {
  var e = Wu();
  return function(t, n) {
    Q.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
};
var Ao = function() {
  var e = Bu(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
};
var Yu = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var fr = function(e) {
  return parseInt(e || "", 10) || 0;
};
var Fu = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [fr(n), fr(r), fr(o)];
};
var _u = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Yu;
  var t = Fu(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
};
var Gu = Ao();
var St = "data-scroll-locked";
var Zu = function(e, t, n, r) {
  var o = e.left, s = e.top, l = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Tu, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(St, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Ln, ` {
    right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(Sn, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(Ln, " .").concat(Ln, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Sn, " .").concat(Sn, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(St, `] {
    `).concat(ju, ": ").concat(c, `px;
  }
`);
};
var Ni = function() {
  var e = parseInt(document.body.getAttribute(St) || "0", 10);
  return isFinite(e) ? e : 0;
};
var Vu = function() {
  Q.useEffect(function() {
    return document.body.setAttribute(St, (Ni() + 1).toString()), function() {
      var e = Ni() - 1;
      e <= 0 ? document.body.removeAttribute(St) : document.body.setAttribute(St, e.toString());
    };
  }, []);
};
var qu = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  Vu();
  var s = Q.useMemo(function() {
    return _u(o);
  }, [o]);
  return (0, import_jsx_runtime.jsx)(Gu, {
    styles: Zu(s, !t, o, n ? "" : "!important")
  });
};
var Cr = false;
if (typeof window < "u")
  try {
    tn = Object.defineProperty({}, "passive", {
      get: function() {
        return Cr = true, true;
      }
    });
    window.addEventListener("test", tn, tn), window.removeEventListener("test", tn, tn);
  } catch {
    Cr = false;
  }
var tn;
var mt = Cr ? { passive: false } : false;
var Xu = function(e) {
  return e.tagName === "TEXTAREA";
};
var Io = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Xu(e) && n[t] === "visible")
  );
};
var Hu = function(e) {
  return Io(e, "overflowY");
};
var Ku = function(e) {
  return Io(e, "overflowX");
};
var Ai = function(e, t) {
  var n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = vo(e, n);
    if (r) {
      var o = mo(e, n), s = o[1], l = o[2];
      if (s > l)
        return true;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return false;
};
var Ju = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
};
var $u = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
};
var vo = function(e, t) {
  return e === "v" ? Hu(t) : Ku(t);
};
var mo = function(e, t) {
  return e === "v" ? Ju(t) : $u(t);
};
var el = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
};
var tl = function(e, t, n, r, o) {
  var s = el(e, window.getComputedStyle(t).direction), l = s * r, c = n.target, f = t.contains(c), h = false, M = l > 0, y = 0, A = 0;
  do {
    var N = mo(e, c), m = N[0], I = N[1], b = N[2], E = I - b - s * m;
    (m || E) && vo(e, c) && (y += E, A += m), c = c.parentNode;
  } while (
    // portaled content
    !f && c !== document.body || // self content
    f && (t.contains(c) || t === c)
  );
  return (M && y === 0 || !M && A === 0) && (h = true), h;
};
var nn = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
};
var Ii = function(e) {
  return [e.deltaX, e.deltaY];
};
var vi = function(e) {
  return e && "current" in e ? e.current : e;
};
var nl = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
};
var rl = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
};
var il = 0;
var Dt = [];
function ol(e) {
  var t = Q.useRef([]), n = Q.useRef([0, 0]), r = Q.useRef(), o = Q.useState(il++)[0], s = Q.useState(function() {
    return Ao();
  })[0], l = Q.useRef(e);
  Q.useEffect(function() {
    l.current = e;
  }, [e]), Q.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var I = bu([e.lockRef.current], (e.shards || []).map(vi), true).filter(Boolean);
      return I.forEach(function(b) {
        return b.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), I.forEach(function(b) {
          return b.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = Q.useCallback(function(I, b) {
    if ("touches" in I && I.touches.length === 2)
      return !l.current.allowPinchZoom;
    var E = nn(I), C = n.current, T = "deltaX" in I ? I.deltaX : C[0] - E[0], z = "deltaY" in I ? I.deltaY : C[1] - E[1], L, U = I.target, $ = Math.abs(T) > Math.abs(z) ? "h" : "v";
    if ("touches" in I && $ === "h" && U.type === "range")
      return false;
    var k = Ai($, U);
    if (!k)
      return true;
    if (k ? L = $ : (L = $ === "v" ? "h" : "v", k = Ai($, U)), !k)
      return false;
    if (!r.current && "changedTouches" in I && (T || z) && (r.current = L), !L)
      return true;
    var ie = r.current || L;
    return tl(ie, b, I, ie === "h" ? T : z);
  }, []), f = Q.useCallback(function(I) {
    var b = I;
    if (!(!Dt.length || Dt[Dt.length - 1] !== s)) {
      var E = "deltaY" in b ? Ii(b) : nn(b), C = t.current.filter(function(L) {
        return L.name === b.type && L.target === b.target && nl(L.delta, E);
      })[0];
      if (C && C.should) {
        b.cancelable && b.preventDefault();
        return;
      }
      if (!C) {
        var T = (l.current.shards || []).map(vi).filter(Boolean).filter(function(L) {
          return L.contains(b.target);
        }), z = T.length > 0 ? c(b, T[0]) : !l.current.noIsolation;
        z && b.cancelable && b.preventDefault();
      }
    }
  }, []), h = Q.useCallback(function(I, b, E, C) {
    var T = {
      name: I,
      delta: b,
      target: E,
      should: C
    };
    t.current.push(T), setTimeout(function() {
      t.current = t.current.filter(function(z) {
        return z !== T;
      });
    }, 1);
  }, []), M = Q.useCallback(function(I) {
    n.current = nn(I), r.current = void 0;
  }, []), y = Q.useCallback(function(I) {
    h(I.type, Ii(I), I.target, c(I, e.lockRef.current));
  }, []), A = Q.useCallback(function(I) {
    h(I.type, nn(I), I.target, c(I, e.lockRef.current));
  }, []);
  Q.useEffect(function() {
    return Dt.push(s), e.setCallbacks({
      onScrollCapture: y,
      onWheelCapture: y,
      onTouchMoveCapture: A
    }), document.addEventListener("wheel", f, mt), document.addEventListener("touchmove", f, mt), document.addEventListener("touchstart", M, mt), function() {
      Dt = Dt.filter(function(I) {
        return I !== s;
      }), document.removeEventListener("wheel", f, mt), document.removeEventListener("touchmove", f, mt), document.removeEventListener("touchstart", M, mt);
    };
  }, []);
  var N = e.removeScrollBar, m = e.inert;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [m ? (0, import_jsx_runtime.jsx)(s, {
      styles: rl(o)
    }) : null, N ? (0, import_jsx_runtime.jsx)(qu, {
      gapMode: "margin"
    }) : null]
  });
}
var sl = Ru(No, ol);
var Do = Q.forwardRef(function(e, t) {
  return (0, import_jsx_runtime.jsx)(Xn, {
    ...Ge({}, e, {
      ref: t,
      sideCar: sl
    })
  });
});
Do.classNames = Xn.classNames;
var al = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
};
var wt = /* @__PURE__ */ new WeakMap();
var rn = /* @__PURE__ */ new WeakMap();
var on = {};
var dr = 0;
var wo = function(e) {
  return e && (e.host || wo(e.parentNode));
};
var cl = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = wo(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
};
var ul = function(e, t, n, r) {
  var o = cl(t, Array.isArray(e) ? e : [e]);
  on[n] || (on[n] = /* @__PURE__ */ new WeakMap());
  var s = on[n], l = [], c = /* @__PURE__ */ new Set(), f = new Set(o), h = function(y) {
    !y || c.has(y) || (c.add(y), h(y.parentNode));
  };
  o.forEach(h);
  var M = function(y) {
    !y || f.has(y) || Array.prototype.forEach.call(y.children, function(A) {
      if (c.has(A))
        M(A);
      else
        try {
          var N = A.getAttribute(r), m = N !== null && N !== "false", I = (wt.get(A) || 0) + 1, b = (s.get(A) || 0) + 1;
          wt.set(A, I), s.set(A, b), l.push(A), I === 1 && m && rn.set(A, true), b === 1 && A.setAttribute(n, "true"), m || A.setAttribute(r, "true");
        } catch (E) {
          console.error("aria-hidden: cannot operate on ", A, E);
        }
    });
  };
  return M(t), c.clear(), dr++, function() {
    l.forEach(function(y) {
      var A = wt.get(y) - 1, N = s.get(y) - 1;
      wt.set(y, A), s.set(y, N), A || (rn.has(y) || y.removeAttribute(r), rn.delete(y)), N || y.removeAttribute(n);
    }), dr--, dr || (wt = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap(), on = {});
  };
};
var ll = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = al(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))), ul(r, o, n, "aria-hidden")) : function() {
    return null;
  };
};
var Eo = "Dialog";
var [bo, ff] = Kc(Eo);
var [fl, Ve] = bo(Eo);
var dl = (e) => {
  const { __scopeDialog: t, children: n, open: r, defaultOpen: o, onOpenChange: s, modal: l = true } = e, c = (0, import_react.useRef)(null), f = (0, import_react.useRef)(null), [h = false, M] = tu({
    prop: r,
    defaultProp: o,
    onChange: s
  });
  return (0, import_react.createElement)(fl, {
    scope: t,
    triggerRef: c,
    contentRef: f,
    contentId: or(),
    titleId: or(),
    descriptionId: or(),
    open: h,
    onOpenChange: M,
    onOpenToggle: (0, import_react.useCallback)(
      () => M(
        (y) => !y
      ),
      [
        M
      ]
    ),
    modal: l
  }, n);
};
var hl = "DialogTrigger";
var gl = (0, import_react.forwardRef)((e, t) => {
  const { __scopeDialog: n, ...r } = e, o = Ve(hl, n), s = xt(t, o.triggerRef);
  return (0, import_react.createElement)(yt.button, S({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": o.open,
    "aria-controls": o.contentId,
    "data-state": qr(o.open)
  }, r, {
    ref: s,
    onClick: it(e.onClick, o.onOpenToggle)
  }));
});
var To = "DialogPortal";
var [Ml, jo] = bo(To, {
  forceMount: void 0
});
var yl = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, s = Ve(To, t);
  return (0, import_react.createElement)(Ml, {
    scope: t,
    forceMount: n
  }, import_react.Children.map(
    r,
    (l) => (0, import_react.createElement)(qn, {
      present: n || s.open
    }, (0, import_react.createElement)(mu, {
      asChild: true,
      container: o
    }, l))
  ));
};
var Or = "DialogOverlay";
var pl = (0, import_react.forwardRef)((e, t) => {
  const n = jo(Or, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, s = Ve(Or, e.__scopeDialog);
  return s.modal ? (0, import_react.createElement)(qn, {
    present: r || s.open
  }, (0, import_react.createElement)(Nl, S({}, o, {
    ref: t
  }))) : null;
});
var Nl = (0, import_react.forwardRef)((e, t) => {
  const { __scopeDialog: n, ...r } = e, o = Ve(Or, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    (0, import_react.createElement)(Do, {
      as: Vr,
      allowPinchZoom: true,
      shards: [
        o.contentRef
      ]
    }, (0, import_react.createElement)(yt.div, S({
      "data-state": qr(o.open)
    }, r, {
      ref: t,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
});
var Ot = "DialogContent";
var Al = (0, import_react.forwardRef)((e, t) => {
  const n = jo(Ot, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, s = Ve(Ot, e.__scopeDialog);
  return (0, import_react.createElement)(qn, {
    present: r || s.open
  }, s.modal ? (0, import_react.createElement)(Il, S({}, o, {
    ref: t
  })) : (0, import_react.createElement)(vl, S({}, o, {
    ref: t
  })));
});
var Il = (0, import_react.forwardRef)((e, t) => {
  const n = Ve(Ot, e.__scopeDialog), r = (0, import_react.useRef)(null), o = xt(t, n.contentRef, r);
  return (0, import_react.useEffect)(() => {
    const s = r.current;
    if (s)
      return ll(s);
  }, []), (0, import_react.createElement)(Lo, S({}, e, {
    ref: o,
    trapFocus: n.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: it(e.onCloseAutoFocus, (s) => {
      var l;
      s.preventDefault(), (l = n.triggerRef.current) === null || l === void 0 || l.focus();
    }),
    onPointerDownOutside: it(e.onPointerDownOutside, (s) => {
      const l = s.detail.originalEvent, c = l.button === 0 && l.ctrlKey === true;
      (l.button === 2 || c) && s.preventDefault();
    }),
    onFocusOutside: it(
      e.onFocusOutside,
      (s) => s.preventDefault()
    )
  }));
});
var vl = (0, import_react.forwardRef)((e, t) => {
  const n = Ve(Ot, e.__scopeDialog), r = (0, import_react.useRef)(false);
  return (0, import_react.createElement)(Lo, S({}, e, {
    ref: t,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (o) => {
      var s;
      if ((s = e.onCloseAutoFocus) === null || s === void 0 || s.call(e, o), !o.defaultPrevented) {
        var l;
        r.current || (l = n.triggerRef.current) === null || l === void 0 || l.focus(), o.preventDefault();
      }
      r.current = false;
    },
    onInteractOutside: (o) => {
      var s, l;
      (s = e.onInteractOutside) === null || s === void 0 || s.call(e, o), o.defaultPrevented || (r.current = true);
      const c = o.target;
      ((l = n.triggerRef.current) === null || l === void 0 ? void 0 : l.contains(c)) && o.preventDefault();
    }
  }));
});
var Lo = (0, import_react.forwardRef)((e, t) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: s, ...l } = e, c = Ve(Ot, n), f = (0, import_react.useRef)(null), h = xt(t, f);
  return Eu(), (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(Mu, {
    asChild: true,
    loop: true,
    trapped: r,
    onMountAutoFocus: o,
    onUnmountAutoFocus: s
  }, (0, import_react.createElement)(du, S({
    role: "dialog",
    id: c.contentId,
    "aria-describedby": c.descriptionId,
    "aria-labelledby": c.titleId,
    "data-state": qr(c.open)
  }, l, {
    ref: h,
    onDismiss: () => c.onOpenChange(false)
  }))), false);
});
var So = "DialogTitle";
var ml = (0, import_react.forwardRef)((e, t) => {
  const { __scopeDialog: n, ...r } = e, o = Ve(So, n);
  return (0, import_react.createElement)(yt.h2, S({
    id: o.titleId
  }, r, {
    ref: t
  }));
});
var Dl = "DialogClose";
var wl = (0, import_react.forwardRef)((e, t) => {
  const { __scopeDialog: n, ...r } = e, o = Ve(Dl, n);
  return (0, import_react.createElement)(yt.button, S({
    type: "button"
  }, r, {
    ref: t,
    onClick: it(
      e.onClick,
      () => o.onOpenChange(false)
    )
  }));
});
function qr(e) {
  return e ? "open" : "closed";
}
var El = "DialogTitleWarning";
Hc(El, {
  contentName: Ot,
  titleName: So,
  docsSlug: "dialog"
});
var bl = dl;
var Tl = gl;
var jl = yl;
var Ll = pl;
var Sl = Al;
var Zt = ml;
var Cl = wl;
var Ol = (e) => (0, import_jsx_runtime.jsxs)(bl, {
  open: e.open,
  onOpenChange: e.onOpenChange,
  children: [(0, import_jsx_runtime.jsx)(Tl, {
    asChild: true,
    children: e.trigger
  }), (0, import_jsx_runtime.jsx)(jl, {
    children: (0, import_jsx_runtime.jsx)(Ll, {
      className: "wkit-dialog__overlay",
      children: (0, import_jsx_runtime.jsx)(Sl, {
        ...e.contentProps,
        className: Gt("wkit-dialog__content", e.className),
        style: e.style,
        children: e.children
      })
    })
  })]
});
function Co() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15.8332 10.0003H4.1665M4.1665 10.0003L9.99984 15.8337M4.1665 10.0003L9.99984 4.16699",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function xl() {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M15 5L5 15M5 5L15 15",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function zl() {
  return (0, import_jsx_runtime.jsxs)("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime.jsx)("g", {
      clipPath: "url(#clip0_1790_28273)",
      children: (0, import_jsx_runtime.jsx)("path", {
        d: "M9.99989 10.9766L14.1249 6.85156L15.3032 8.0299L9.99989 13.3332L4.69656 8.0299L5.87489 6.85156L9.99989 10.9766Z",
        fill: "currentColor"
      })
    }), (0, import_jsx_runtime.jsx)("defs", {
      children: (0, import_jsx_runtime.jsx)("clipPath", {
        id: "clip0_1790_28273",
        children: (0, import_jsx_runtime.jsx)("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(20) rotate(90)"
        })
      })
    })]
  });
}
var Rl = (e) => {
  const {
    icon: t,
    alt: n = "icon"
  } = e;
  return (0, import_jsx_runtime.jsx)("div", {
    onClick: e.onClick,
    className: e.className,
    style: e.style,
    children: typeof t == "string" ? (0, import_jsx_runtime.jsx)("img", {
      src: t,
      alt: n,
      className: e.elClassName,
      style: e.elStyle
    }) : import_react.default.cloneElement(t)
  });
};
var Ul = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-dialog__header",
  children: [(0, import_jsx_runtime.jsx)(Zt, {
    className: "wkit-dialog__title",
    children: "Connect Wallet"
  }), (0, import_jsx_runtime.jsx)(Cl, {
    style: {
      position: "absolute",
      right: "16px",
      top: "16px"
    },
    className: "wkit-dialog__close",
    children: (0, import_jsx_runtime.jsx)(xl, {})
  })]
});
var kl = () => (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-new-to-sui",
  children: [(0, import_jsx_runtime.jsx)("span", {
    className: "wkit-new-to-sui__text",
    children: "New to sui? "
  }), (0, import_jsx_runtime.jsx)("a", {
    className: "wkit-new-to-sui__link",
    href: "https://suiet.app/docs/getting-started",
    target: "_blank",
    children: "Learn More Here"
  })]
});
var Ql = (e) => {
  const {
    wallet: t
  } = e, [n, r] = (0, import_react.useState)("");
  return (0, import_react.useEffect)(() => {
    t.iconUrl && r(t.iconUrl);
  }, [t.iconUrl]), (0, import_jsx_runtime.jsxs)("div", {
    className: "wkit-select-item",
    onClick: () => {
      var _a2;
      (_a2 = e.onSelect) == null ? void 0 : _a2.call(e, t);
    },
    children: [(0, import_jsx_runtime.jsx)(Rl, {
      icon: n,
      className: "wkit-select-item__icon",
      elClassName: "wkit-select-item__icon"
    }), t.label ?? t.name]
  }, t.name);
};
var mi = (e) => Pe(e.wallets) ? (0, import_jsx_runtime.jsxs)("div", {
  className: "wkit-select__container",
  children: [(0, import_jsx_runtime.jsx)("div", {
    className: "wkit-select__title",
    children: e.title
  }), Pe(e.wallets) && e.wallets.map((t) => (0, import_jsx_runtime.jsx)(Ql, {
    wallet: t,
    onSelect: e.onSelect
  }, t.name))]
}) : null;
var Pl = (e) => {
  const {
    wallet: t
  } = e;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(Zt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-8px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Co, {})
        })
      }), (0, import_jsx_runtime.jsx)(Zt, {
        className: "wkit-dialog__title",
        children: "Install Wallet"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-install",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-install__logo",
        src: t.iconUrl,
        alt: `${t.name} logo`
      }), (0, import_jsx_runtime.jsx)("h1", {
        className: "wkit-install__title",
        children: "You havent install this wallet"
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-install__description",
        children: "Install wallet via Chrome Extension Store"
      }), (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-button wkit-install__button",
        onClick: () => {
          var _a2;
          if (!((_a2 = t.downloadUrl) == null ? void 0 : _a2.browserExtension))
            throw new _(`no downloadUrl config on this wallet: ${t.name}`);
          window.open(t.downloadUrl.browserExtension, "_blank");
        },
        children: "Get Wallet"
      })]
    })]
  });
};
var Wl = (e) => {
  const {
    wallet: t
  } = e;
  return (0, import_jsx_runtime.jsxs)("section", {
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-dialog__header",
      children: [(0, import_jsx_runtime.jsx)(Zt, {
        className: "wkit-dialog__title",
        style: {
          margin: "-6px 12px -6px -8px"
        },
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-dialog__close",
          onClick: e.onNavBack,
          children: (0, import_jsx_runtime.jsx)(Co, {})
        })
      }), (0, import_jsx_runtime.jsx)(Zt, {
        className: "wkit-dialog__title",
        children: "Connecting"
      })]
    }), (0, import_jsx_runtime.jsxs)("div", {
      className: "wkit-connecting",
      children: [(0, import_jsx_runtime.jsx)("img", {
        className: "wkit-connecting__logo",
        src: t.iconUrl,
        alt: `logo of ${t.name}`
      }), (0, import_jsx_runtime.jsxs)("h1", {
        className: "wkit-connecting__title",
        children: ["Opening ", t.name]
      }), (0, import_jsx_runtime.jsx)("p", {
        className: "wkit-connecting__description",
        children: "Confirm connection in the extension"
      })]
    })]
  });
};
var Bl = (e) => {
  const {
    configuredWallets: t,
    detectedWallets: n,
    select: r,
    connecting: o
  } = Xt(), {
    onConnectSuccess: s = () => {
    },
    onConnectError: l = (y) => {
      throw y;
    }
  } = e, [c, f] = (0, import_react.useState)(), h = (0, import_react.useCallback)(async (y) => {
    if (f(y), y.installed) {
      try {
        await r(y.name);
      } catch (A) {
        l(A);
        return;
      }
      s(y.name);
    }
  }, [r]);
  function M() {
    if (c) {
      if (!c.installed)
        return (0, import_jsx_runtime.jsx)(Pl, {
          wallet: c,
          onNavBack: () => {
            f(void 0);
          }
        });
      if (o)
        return (0, import_jsx_runtime.jsx)(Wl, {
          wallet: c,
          onNavBack: () => {
            f(void 0);
          }
        });
    }
    return (0, import_jsx_runtime.jsxs)("div", {
      children: [(0, import_jsx_runtime.jsx)(Ul, {}), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-select__scroll",
        children: [(0, import_jsx_runtime.jsx)(mi, {
          title: "Popular",
          wallets: t,
          onSelect: h
        }), (0, import_jsx_runtime.jsx)(mi, {
          title: "Others",
          wallets: n,
          onSelect: h
        })]
      }), (0, import_jsx_runtime.jsx)("div", {
        style: {
          height: "41px",
          flexShrink: "0"
        }
      }), (0, import_jsx_runtime.jsx)(kl, {})]
    });
  }
  return (0, import_jsx_runtime.jsx)(Ol, {
    open: e.open,
    onOpenChange: e.onOpenChange,
    trigger: e.children,
    contentProps: {
      onOpenAutoFocus: (y) => {
        y.preventDefault();
      }
    },
    children: M()
  });
};
function Yl(e) {
  const {
    disconnect: t,
    account: n,
    chain: r,
    connected: o,
    name: s
  } = Xt(), {
    balance: l
  } = Bc(), [c, f] = (0, import_react.useState)(false), h = (0, import_react.useCallback)(() => !r || r.id === jt.id ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: "Unknown Chain"
  }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [Us(l ?? 0), " SUI"]
  }), [l, r]);
  return o ? (0, import_jsx_runtime.jsxs)("div", {
    className: Gt("wkit-connected-container", e.className),
    style: e.style,
    children: [(0, import_jsx_runtime.jsxs)("button", {
      className: Gt("wkit-connected-button"),
      onClick: () => {
        f(!c);
      },
      children: [(0, import_jsx_runtime.jsx)("span", {
        className: "wkit-connected-button__balance",
        children: h()
      }), (0, import_jsx_runtime.jsx)("div", {
        className: "wkit-connected-button__divider"
      }), (0, import_jsx_runtime.jsxs)("div", {
        className: "wkit-address-select",
        children: [(0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__address",
          children: Ps(n == null ? void 0 : n.address)
        }), (0, import_jsx_runtime.jsx)("span", {
          className: "wkit-address-select__right-arrow",
          children: (0, import_jsx_runtime.jsx)(zl, {})
        })]
      })]
    }), c && (0, import_jsx_runtime.jsx)("div", {
      className: "wkit-disconnect-button__container",
      children: (0, import_jsx_runtime.jsx)("button", {
        className: "wkit-disconnect-button",
        onClick: async () => {
          var _a2, _b;
          f(false);
          try {
            await t();
          } catch (M) {
            (_a2 = e == null ? void 0 : e.onDisconnectError) == null ? void 0 : _a2.call(e, M);
            return;
          }
          (_b = e == null ? void 0 : e.onDisconnectSuccess) == null ? void 0 : _b.call(e, s);
        },
        children: "Disconnect"
      })
    })]
  }) : null;
}
var df = (e) => {
  const {
    label: t = "Connect Button"
  } = e, [n, r] = (0, import_react.useState)(false), {
    connected: o
  } = Xt();
  return (0, import_react.useEffect)(() => {
    o && r(false);
  }, [o]), (0, import_jsx_runtime.jsx)(Bl, {
    open: n,
    onOpenChange: (s) => {
      o || r(s);
    },
    onConnectSuccess: e.onConnectSuccess,
    onConnectError: e.onConnectError,
    children: (0, import_jsx_runtime.jsx)("div", {
      children: o ? (0, import_jsx_runtime.jsx)(Yl, {
        className: Gt(e.className),
        style: e.style,
        onDisconnectSuccess: (s) => {
          var _a2;
          r(false), (_a2 = e == null ? void 0 : e.onDisconnectSuccess) == null ? void 0 : _a2.call(e, s);
        },
        onDisconnectError: e.onDisconnectError
      }) : (0, import_jsx_runtime.jsx)("button", {
        className: Gt("wkit-button", e.className),
        style: e.style,
        children: e.children || t
      })
    })
  });
};
function Oo(e) {
  if (typeof e == "string") {
    console.warn(`[DEPRECATED] ${e}`);
    return;
  }
  const { name: t, message: n, migrationDoc: r } = e;
  console.warn(`[DEPRECATED] ${t} is no longer supported. ` + n + (r ? ` | Check migration doc: ${r}` : ""));
}
function hf() {
  return Oo({
    name: "getDefaultWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
function gf() {
  return Oo({
    name: "getAllWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
export {
  Rs as AccountAssetManager,
  zs as AccountCoinManager,
  xs as AccountObjectManager,
  Xa as AllDefaultWallets,
  ki as BaseError,
  af as BrowserEnvDetector,
  kr as CoinObject,
  df as ConnectButton,
  Bl as ConnectModal,
  Ue as ConnectionStatus,
  oc as DefaultChains,
  rf as ElliWallet,
  X as ErrorCode,
  $l as EthosWallet,
  q as FeatureName,
  of as FrontierWallet,
  Fa as GlassWallet,
  _ as KitError,
  Ba as MartianWallet,
  ef as MorphisWallet,
  Ga as NightlyWallet,
  qa as OkxWallet,
  _a as OneKeyWallet,
  Va as PhantomWallet,
  pe as PresetWallet,
  Hi as PresetWalletId,
  nf as SensuiWallet,
  $i as SignatureVerifier,
  Ki as SlushWallet,
  tf as SpacecyWallet,
  tc as SuiChainId,
  nc as SuiDevnetChain,
  ic as SuiMainnetChain,
  rc as SuiTestnetChain,
  Jl as SuiWallet,
  Wa as SuietWallet,
  Ya as SurfWallet,
  Za as TokenPocketWallet,
  ft as Uint8arrayTool,
  jt as UnknownChain,
  qs as WalletAdapter,
  eo as WalletContext,
  Ee as WalletError,
  Qi as WalletNotImplementError,
  lf as WalletProvider,
  aa as WalletRadar,
  Pr as WalletType,
  Ps as addressEllipsis,
  Hl as defineSlushWallet,
  Ji as defineSlushWebWallet,
  Kl as defineStashedWallet,
  he as defineWallet,
  xi as formatCurrency,
  Us as formatSUI,
  gf as getAllWallets,
  hf as getDefaultWallets,
  Ha as handleConnectionError,
  xn as has,
  ec as normalizeTransaction,
  Pa as registerSlushWebWallet,
  $a as serializeTransaction,
  sf as stringBytesToString,
  Ja as stringBytesToUint8Array,
  Bc as useAccountBalance,
  Pc as useChain,
  Wc as useCoinBalance,
  uf as useSuiClient,
  cf as useSuiProvider,
  Xt as useWallet,
  Ka as verifySignedMessage
};
/*! Bundled license information:

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@suiet/wallet-kit/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@suiet_wallet-kit.js.map
